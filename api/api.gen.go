//go:build go1.22

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
)

const (
	AVM_SIDScopes = "AVM_SID.Scopes"
)

// Defines values for IFAlertConfigUnitsControlMode.
const (
	IFAlertConfigUnitsControlModeOff     IFAlertConfigUnitsControlMode = "off"
	IFAlertConfigUnitsControlModeOn      IFAlertConfigUnitsControlMode = "on"
	IFAlertConfigUnitsControlModeUnknown IFAlertConfigUnitsControlMode = "unknown"
)

// Defines values for IFColorControlConfigCurrentColorMode.
const (
	IFColorControlConfigCurrentColorModeHueSaturation IFColorControlConfigCurrentColorMode = "hueSaturation"
	IFColorControlConfigCurrentColorModeTemperature   IFColorControlConfigCurrentColorMode = "temperature"
	IFColorControlConfigCurrentColorModeUnknown       IFColorControlConfigCurrentColorMode = "unknown"
)

// Defines values for IFColorControlConfigSupportedColorModes.
const (
	IFColorControlConfigSupportedColorModesHueSaturation IFColorControlConfigSupportedColorModes = "hueSaturation"
	IFColorControlConfigSupportedColorModesTemperature   IFColorControlConfigSupportedColorModes = "temperature"
	IFColorControlConfigSupportedColorModesUnknown       IFColorControlConfigSupportedColorModes = "unknown"
)

// Defines values for IFColorControlOverviewCurrentColorMode.
const (
	IFColorControlOverviewCurrentColorModeHueSaturation IFColorControlOverviewCurrentColorMode = "hueSaturation"
	IFColorControlOverviewCurrentColorModeTemperature   IFColorControlOverviewCurrentColorMode = "temperature"
	IFColorControlOverviewCurrentColorModeUnknown       IFColorControlOverviewCurrentColorMode = "unknown"
)

// Defines values for IFColorControlOverviewSupportedColorModes.
const (
	IFColorControlOverviewSupportedColorModesHueSaturation IFColorControlOverviewSupportedColorModes = "hueSaturation"
	IFColorControlOverviewSupportedColorModesTemperature   IFColorControlOverviewSupportedColorModes = "temperature"
	IFColorControlOverviewSupportedColorModesUnknown       IFColorControlOverviewSupportedColorModes = "unknown"
)

// Defines values for IFTemplateHttpRequestMethod.
const (
	IFTemplateHttpRequestMethodDELETE  IFTemplateHttpRequestMethod = "DELETE"
	IFTemplateHttpRequestMethodGET     IFTemplateHttpRequestMethod = "GET"
	IFTemplateHttpRequestMethodHEAD    IFTemplateHttpRequestMethod = "HEAD"
	IFTemplateHttpRequestMethodPOST    IFTemplateHttpRequestMethod = "POST"
	IFTemplateHttpRequestMethodPUT     IFTemplateHttpRequestMethod = "PUT"
	IFTemplateHttpRequestMethodUnknown IFTemplateHttpRequestMethod = "unknown"
)

// Defines values for IFTemplateLevelControlMode.
const (
	IFTemplateLevelControlModeDecrease IFTemplateLevelControlMode = "decrease"
	IFTemplateLevelControlModeFixed    IFTemplateLevelControlMode = "fixed"
	IFTemplateLevelControlModeIncrease IFTemplateLevelControlMode = "increase"
	IFTemplateLevelControlModeUnknown  IFTemplateLevelControlMode = "unknown"
)

// Defines values for IFTemplateNotificationMode.
const (
	IFTemplateNotificationModeAppNotification IFTemplateNotificationMode = "appNotification"
	IFTemplateNotificationModePushMail        IFTemplateNotificationMode = "pushMail"
	IFTemplateNotificationModeUnknown         IFTemplateNotificationMode = "unknown"
)

// Defines values for IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUids.
const (
	IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUidsTAM0 IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUids = "TAM0"
	IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUidsTAM1 IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUids = "TAM1"
	IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUidsTAM2 IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUids = "TAM2"
	IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUidsTAM3 IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUids = "TAM3"
	IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUidsTAM4 IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUids = "TAM4"
)

// Defines values for IFTemplateThermostatMode.
const (
	IFTemplateThermostatModeBoost                   IFTemplateThermostatMode = "boost"
	IFTemplateThermostatModeDisableSpecialMode      IFTemplateThermostatMode = "disableSpecialMode"
	IFTemplateThermostatModeHolidayPeriods          IFTemplateThermostatMode = "holidayPeriods"
	IFTemplateThermostatModeSetPointTemperature     IFTemplateThermostatMode = "setPointTemperature"
	IFTemplateThermostatModeSummerAndHolidayPeriods IFTemplateThermostatMode = "summerAndHolidayPeriods"
	IFTemplateThermostatModeSummerPeriod            IFTemplateThermostatMode = "summerPeriod"
	IFTemplateThermostatModeUnknown                 IFTemplateThermostatMode = "unknown"
	IFTemplateThermostatModeWindowOpenMode          IFTemplateThermostatMode = "windowOpenMode"
)

// Defines values for IFTemplateThermostatSetPointTemperatureMode.
const (
	IFTemplateThermostatSetPointTemperatureModeComfort     IFTemplateThermostatSetPointTemperatureMode = "comfort"
	IFTemplateThermostatSetPointTemperatureModeOff         IFTemplateThermostatSetPointTemperatureMode = "off"
	IFTemplateThermostatSetPointTemperatureModeOn          IFTemplateThermostatSetPointTemperatureMode = "on"
	IFTemplateThermostatSetPointTemperatureModeReduced     IFTemplateThermostatSetPointTemperatureMode = "reduced"
	IFTemplateThermostatSetPointTemperatureModeRelative    IFTemplateThermostatSetPointTemperatureMode = "relative"
	IFTemplateThermostatSetPointTemperatureModeTemperature IFTemplateThermostatSetPointTemperatureMode = "temperature"
	IFTemplateThermostatSetPointTemperatureModeUnknown     IFTemplateThermostatSetPointTemperatureMode = "unknown"
)

// Defines values for IFThermostatConfigTemperatureOffsetSensorMode.
const (
	IFThermostatConfigTemperatureOffsetSensorModeExternal IFThermostatConfigTemperatureOffsetSensorMode = "external"
	IFThermostatConfigTemperatureOffsetSensorModeInternal IFThermostatConfigTemperatureOffsetSensorMode = "internal"
)

// Defines values for IFThermostatConfigWindowOpenModeInternalSensitivity.
const (
	IFThermostatConfigWindowOpenModeInternalSensitivityHigh    IFThermostatConfigWindowOpenModeInternalSensitivity = "high"
	IFThermostatConfigWindowOpenModeInternalSensitivityLow     IFThermostatConfigWindowOpenModeInternalSensitivity = "low"
	IFThermostatConfigWindowOpenModeInternalSensitivityMedium  IFThermostatConfigWindowOpenModeInternalSensitivity = "medium"
	IFThermostatConfigWindowOpenModeInternalSensitivityUnknown IFThermostatConfigWindowOpenModeInternalSensitivity = "unknown"
)

// Defines values for IFThermostatConfigWindowOpenModeSensorMode.
const (
	IFThermostatConfigWindowOpenModeSensorModeExternal IFThermostatConfigWindowOpenModeSensorMode = "external"
	IFThermostatConfigWindowOpenModeSensorModeInternal IFThermostatConfigWindowOpenModeSensorMode = "internal"
)

// Defines values for IFWidgetConfigAvailableWidgetsMainWifiBands.
const (
	IFWidgetConfigAvailableWidgetsMainWifiBandsN24GHz  IFWidgetConfigAvailableWidgetsMainWifiBands = "2.4GHz"
	IFWidgetConfigAvailableWidgetsMainWifiBandsN5GHz   IFWidgetConfigAvailableWidgetsMainWifiBands = "5GHz"
	IFWidgetConfigAvailableWidgetsMainWifiBandsN6GHz   IFWidgetConfigAvailableWidgetsMainWifiBands = "6GHz"
	IFWidgetConfigAvailableWidgetsMainWifiBandsTriband IFWidgetConfigAvailableWidgetsMainWifiBands = "triband"
)

// Defines values for IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUids.
const (
	IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUidsTAM0 IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUids = "TAM0"
	IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUidsTAM1 IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUids = "TAM1"
	IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUidsTAM2 IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUids = "TAM2"
	IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUidsTAM3 IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUids = "TAM3"
	IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUidsTAM4 IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUids = "TAM4"
)

// Defines values for IFWidgetConfigDefaultScreen.
const (
	IFWidgetConfigDefaultScreenFirst       IFWidgetConfigDefaultScreen = "first"
	IFWidgetConfigDefaultScreenSecond      IFWidgetConfigDefaultScreen = "second"
	IFWidgetConfigDefaultScreenTemperature IFWidgetConfigDefaultScreen = "temperature"
	IFWidgetConfigDefaultScreenThird       IFWidgetConfigDefaultScreen = "third"
	IFWidgetConfigDefaultScreenUnknown     IFWidgetConfigDefaultScreen = "unknown"
)

// Defines values for ActionGroupTemperature.
const (
	ActionGroupTemperatureLowerThreshold ActionGroupTemperature = "lowerThreshold"
	ActionGroupTemperatureUnknown        ActionGroupTemperature = "unknown"
	ActionGroupTemperatureUpperThreshold ActionGroupTemperature = "upperThreshold"
)

// Defines values for ActionTemperaturePreset.
const (
	ActionTemperaturePresetComfort ActionTemperaturePreset = "comfort"
	ActionTemperaturePresetReduced ActionTemperaturePreset = "reduced"
	ActionTemperaturePresetUnknown ActionTemperaturePreset = "unknown"
)

// Defines values for ColorControlUnitCurrentColorMode.
const (
	ColorControlUnitCurrentColorModeHueSaturation ColorControlUnitCurrentColorMode = "hueSaturation"
	ColorControlUnitCurrentColorModeTemperature   ColorControlUnitCurrentColorMode = "temperature"
	ColorControlUnitCurrentColorModeUnknown       ColorControlUnitCurrentColorMode = "unknown"
)

// Defines values for ColorControlUnitSupportedColorModes.
const (
	ColorControlUnitSupportedColorModesHueSaturation ColorControlUnitSupportedColorModes = "hueSaturation"
	ColorControlUnitSupportedColorModesTemperature   ColorControlUnitSupportedColorModes = "temperature"
	ColorControlUnitSupportedColorModesUnknown       ColorControlUnitSupportedColorModes = "unknown"
)

// Defines values for DeviceBaseBatteryState.
const (
	DeviceBaseBatteryStateKnown   DeviceBaseBatteryState = "known"
	DeviceBaseBatteryStateUnknown DeviceBaseBatteryState = "unknown"
)

// Defines values for DeviceBaseProductCategory.
const (
	DeviceBaseProductCategoryBlind      DeviceBaseProductCategory = "blind"
	DeviceBaseProductCategoryControl    DeviceBaseProductCategory = "control"
	DeviceBaseProductCategoryLamp       DeviceBaseProductCategory = "lamp"
	DeviceBaseProductCategoryOther      DeviceBaseProductCategory = "other"
	DeviceBaseProductCategorySensor     DeviceBaseProductCategory = "sensor"
	DeviceBaseProductCategorySocket     DeviceBaseProductCategory = "socket"
	DeviceBaseProductCategoryThermostat DeviceBaseProductCategory = "thermostat"
)

// Defines values for EndpointConfigurationDeviceBatteryState.
const (
	EndpointConfigurationDeviceBatteryStateKnown   EndpointConfigurationDeviceBatteryState = "known"
	EndpointConfigurationDeviceBatteryStateUnknown EndpointConfigurationDeviceBatteryState = "unknown"
)

// Defines values for EndpointConfigurationDeviceProductCategory.
const (
	EndpointConfigurationDeviceProductCategoryBlind      EndpointConfigurationDeviceProductCategory = "blind"
	EndpointConfigurationDeviceProductCategoryControl    EndpointConfigurationDeviceProductCategory = "control"
	EndpointConfigurationDeviceProductCategoryLamp       EndpointConfigurationDeviceProductCategory = "lamp"
	EndpointConfigurationDeviceProductCategoryOther      EndpointConfigurationDeviceProductCategory = "other"
	EndpointConfigurationDeviceProductCategorySensor     EndpointConfigurationDeviceProductCategory = "sensor"
	EndpointConfigurationDeviceProductCategorySocket     EndpointConfigurationDeviceProductCategory = "socket"
	EndpointConfigurationDeviceProductCategoryThermostat EndpointConfigurationDeviceProductCategory = "thermostat"
)

// Defines values for EndpointConfigurationGetTemplateCapabilitiesInterfaces.
const (
	ColorControlInterface              EndpointConfigurationGetTemplateCapabilitiesInterfaces = "colorControlInterface"
	DialHelperInterface                EndpointConfigurationGetTemplateCapabilitiesInterfaces = "dialHelperInterface"
	GroupInterface                     EndpointConfigurationGetTemplateCapabilitiesInterfaces = "groupInterface"
	GuestWifiInterface                 EndpointConfigurationGetTemplateCapabilitiesInterfaces = "guestWifiInterface"
	HttpRequestInterface               EndpointConfigurationGetTemplateCapabilitiesInterfaces = "httpRequestInterface"
	LevelControlInterface              EndpointConfigurationGetTemplateCapabilitiesInterfaces = "levelControlInterface"
	MainWifiInterface                  EndpointConfigurationGetTemplateCapabilitiesInterfaces = "mainWifiInterface"
	NotificationInterface              EndpointConfigurationGetTemplateCapabilitiesInterfaces = "notificationInterface"
	OnOffInterface                     EndpointConfigurationGetTemplateCapabilitiesInterfaces = "onOffInterface"
	TelephoneAnsweringMachineInterface EndpointConfigurationGetTemplateCapabilitiesInterfaces = "telephoneAnsweringMachineInterface"
	ThermostatInterface                EndpointConfigurationGetTemplateCapabilitiesInterfaces = "thermostatInterface"
	TriggerInterface                   EndpointConfigurationGetTemplateCapabilitiesInterfaces = "triggerInterface"
)

// Defines values for EndpointConfigurationGroupGroupCategory.
const (
	EndpointConfigurationGroupGroupCategoryBlind      EndpointConfigurationGroupGroupCategory = "blind"
	EndpointConfigurationGroupGroupCategoryOther      EndpointConfigurationGroupGroupCategory = "other"
	EndpointConfigurationGroupGroupCategorySwitchable EndpointConfigurationGroupGroupCategory = "switchable"
	EndpointConfigurationGroupGroupCategoryThermostat EndpointConfigurationGroupGroupCategory = "thermostat"
)

// Defines values for EndpointConfigurationPostGroupGroupCategory.
const (
	EndpointConfigurationPostGroupGroupCategoryBlind      EndpointConfigurationPostGroupGroupCategory = "blind"
	EndpointConfigurationPostGroupGroupCategoryOther      EndpointConfigurationPostGroupGroupCategory = "other"
	EndpointConfigurationPostGroupGroupCategorySwitchable EndpointConfigurationPostGroupGroupCategory = "switchable"
	EndpointConfigurationPostGroupGroupCategoryThermostat EndpointConfigurationPostGroupGroupCategory = "thermostat"
)

// Defines values for EndpointConfigurationPutDeviceBatteryState.
const (
	EndpointConfigurationPutDeviceBatteryStateKnown   EndpointConfigurationPutDeviceBatteryState = "known"
	EndpointConfigurationPutDeviceBatteryStateUnknown EndpointConfigurationPutDeviceBatteryState = "unknown"
)

// Defines values for EndpointConfigurationPutDeviceProductCategory.
const (
	EndpointConfigurationPutDeviceProductCategoryBlind      EndpointConfigurationPutDeviceProductCategory = "blind"
	EndpointConfigurationPutDeviceProductCategoryControl    EndpointConfigurationPutDeviceProductCategory = "control"
	EndpointConfigurationPutDeviceProductCategoryLamp       EndpointConfigurationPutDeviceProductCategory = "lamp"
	EndpointConfigurationPutDeviceProductCategoryOther      EndpointConfigurationPutDeviceProductCategory = "other"
	EndpointConfigurationPutDeviceProductCategorySensor     EndpointConfigurationPutDeviceProductCategory = "sensor"
	EndpointConfigurationPutDeviceProductCategorySocket     EndpointConfigurationPutDeviceProductCategory = "socket"
	EndpointConfigurationPutDeviceProductCategoryThermostat EndpointConfigurationPutDeviceProductCategory = "thermostat"
)

// Defines values for EndpointConfigurationPutGroupGroupCategory.
const (
	EndpointConfigurationPutGroupGroupCategoryBlind      EndpointConfigurationPutGroupGroupCategory = "blind"
	EndpointConfigurationPutGroupGroupCategoryOther      EndpointConfigurationPutGroupGroupCategory = "other"
	EndpointConfigurationPutGroupGroupCategorySwitchable EndpointConfigurationPutGroupGroupCategory = "switchable"
	EndpointConfigurationPutGroupGroupCategoryThermostat EndpointConfigurationPutGroupGroupCategory = "thermostat"
)

// Defines values for EndpointSubscriptionStateState.
const (
	EndpointSubscriptionStateStateAbortedByUser  EndpointSubscriptionStateState = "abortedByUser"
	EndpointSubscriptionStateStateAlreadyRunning EndpointSubscriptionStateState = "alreadyRunning"
	EndpointSubscriptionStateStateDectPending    EndpointSubscriptionStateState = "dectPending"
	EndpointSubscriptionStateStateGenericError   EndpointSubscriptionStateState = "genericError"
	EndpointSubscriptionStateStateInitial        EndpointSubscriptionStateState = "initial"
	EndpointSubscriptionStateStateSuccess        EndpointSubscriptionStateState = "success"
	EndpointSubscriptionStateStateTimeout        EndpointSubscriptionStateState = "timeout"
	EndpointSubscriptionStateStateUnknown        EndpointSubscriptionStateState = "unknown"
	EndpointSubscriptionStateStateZigbeePending  EndpointSubscriptionStateState = "zigbeePending"
)

// Defines values for GroupBaseGroupCategory.
const (
	GroupBaseGroupCategoryBlind      GroupBaseGroupCategory = "blind"
	GroupBaseGroupCategoryOther      GroupBaseGroupCategory = "other"
	GroupBaseGroupCategorySwitchable GroupBaseGroupCategory = "switchable"
	GroupBaseGroupCategoryThermostat GroupBaseGroupCategory = "thermostat"
)

// Defines values for HelperActivePeriodAlertButtonMode.
const (
	HelperActivePeriodAlertButtonModeAstronomic HelperActivePeriodAlertButtonMode = "astronomic"
	HelperActivePeriodAlertButtonModeFixed      HelperActivePeriodAlertButtonMode = "fixed"
	HelperActivePeriodAlertButtonModePermanent  HelperActivePeriodAlertButtonMode = "permanent"
	HelperActivePeriodAlertButtonModeUnknown    HelperActivePeriodAlertButtonMode = "unknown"
)

// Defines values for HelperAstronomicSunRiseFallTurnOffMode.
const (
	HelperAstronomicSunRiseFallTurnOffModeDuration     HelperAstronomicSunRiseFallTurnOffMode = "duration"
	HelperAstronomicSunRiseFallTurnOffModeFixed        HelperAstronomicSunRiseFallTurnOffMode = "fixed"
	HelperAstronomicSunRiseFallTurnOffModeNextSunEvent HelperAstronomicSunRiseFallTurnOffMode = "nextSunEvent"
	HelperAstronomicSunRiseFallTurnOffModeOffset       HelperAstronomicSunRiseFallTurnOffMode = "offset"
	HelperAstronomicSunRiseFallTurnOffModeUnknown      HelperAstronomicSunRiseFallTurnOffMode = "unknown"
)

// Defines values for HelperAstronomicSunRiseFallTurnOnMode.
const (
	HelperAstronomicSunRiseFallTurnOnModeFixed   HelperAstronomicSunRiseFallTurnOnMode = "fixed"
	HelperAstronomicSunRiseFallTurnOnModeOffset  HelperAstronomicSunRiseFallTurnOnMode = "offset"
	HelperAstronomicSunRiseFallTurnOnModeUnknown HelperAstronomicSunRiseFallTurnOnMode = "unknown"
)

// Defines values for HelperAstronomicSunRiseFallTurnOnWithActionsMode.
const (
	HelperAstronomicSunRiseFallTurnOnWithActionsModeFixed   HelperAstronomicSunRiseFallTurnOnWithActionsMode = "fixed"
	HelperAstronomicSunRiseFallTurnOnWithActionsModeOffset  HelperAstronomicSunRiseFallTurnOnWithActionsMode = "offset"
	HelperAstronomicSunRiseFallTurnOnWithActionsModeUnknown HelperAstronomicSunRiseFallTurnOnWithActionsMode = "unknown"
)

// Defines values for HelperBaseTimerCountdownMode.
const (
	HelperBaseTimerCountdownModeTurnOff HelperBaseTimerCountdownMode = "turnOff"
	HelperBaseTimerCountdownModeTurnOn  HelperBaseTimerCountdownMode = "turnOn"
	HelperBaseTimerCountdownModeUnknown HelperBaseTimerCountdownMode = "unknown"
)

// Defines values for HelperBaseTimerOnceMode.
const (
	HelperBaseTimerOnceModeTurnOff HelperBaseTimerOnceMode = "turnOff"
	HelperBaseTimerOnceModeTurnOn  HelperBaseTimerOnceMode = "turnOn"
	HelperBaseTimerOnceModeUnknown HelperBaseTimerOnceMode = "unknown"
)

// Defines values for HelperBlindAction.
const (
	MoveDown HelperBlindAction = "moveDown"
	MoveUp   HelperBlindAction = "moveUp"
	Stop     HelperBlindAction = "stop"
)

// Defines values for HelperControlMode.
const (
	HelperControlModeOff     HelperControlMode = "off"
	HelperControlModeOn      HelperControlMode = "on"
	HelperControlModeToggle  HelperControlMode = "toggle"
	HelperControlModeUnknown HelperControlMode = "unknown"
)

// Defines values for HelperDestinationMode.
const (
	HelperDestinationModeDisabled  HelperDestinationMode = "disabled"
	HelperDestinationModeTemplates HelperDestinationMode = "templates"
	HelperDestinationModeUnits     HelperDestinationMode = "units"
	HelperDestinationModeUnknown   HelperDestinationMode = "unknown"
)

// Defines values for HelperNoiseControlCustomSignalSwitchingMode.
const (
	HelperNoiseControlCustomSignalSwitchingModeSignal  HelperNoiseControlCustomSignalSwitchingMode = "signal"
	HelperNoiseControlCustomSignalSwitchingModeSilence HelperNoiseControlCustomSignalSwitchingMode = "silence"
	HelperNoiseControlCustomSignalSwitchingModeUnknown HelperNoiseControlCustomSignalSwitchingMode = "unknown"
)

// Defines values for HelperNoiseControlNoiseMode.
const (
	HelperNoiseControlNoiseModeClap         HelperNoiseControlNoiseMode = "clap"
	HelperNoiseControlNoiseModeCustomSignal HelperNoiseControlNoiseMode = "customSignal"
	HelperNoiseControlNoiseModeDisabled     HelperNoiseControlNoiseMode = "disabled"
)

// Defines values for HelperOverviewDeviceBatteryState.
const (
	HelperOverviewDeviceBatteryStateKnown   HelperOverviewDeviceBatteryState = "known"
	HelperOverviewDeviceBatteryStateUnknown HelperOverviewDeviceBatteryState = "unknown"
)

// Defines values for HelperOverviewDeviceProductCategory.
const (
	HelperOverviewDeviceProductCategoryBlind      HelperOverviewDeviceProductCategory = "blind"
	HelperOverviewDeviceProductCategoryControl    HelperOverviewDeviceProductCategory = "control"
	HelperOverviewDeviceProductCategoryLamp       HelperOverviewDeviceProductCategory = "lamp"
	HelperOverviewDeviceProductCategoryOther      HelperOverviewDeviceProductCategory = "other"
	HelperOverviewDeviceProductCategorySensor     HelperOverviewDeviceProductCategory = "sensor"
	HelperOverviewDeviceProductCategorySocket     HelperOverviewDeviceProductCategory = "socket"
	HelperOverviewDeviceProductCategoryThermostat HelperOverviewDeviceProductCategory = "thermostat"
)

// Defines values for HelperPowerOnBehaviourModes.
const (
	HelperPowerOnBehaviourModesColorTemperature HelperPowerOnBehaviourModes = "colorTemperature"
	HelperPowerOnBehaviourModesHsColor          HelperPowerOnBehaviourModes = "hsColor"
	HelperPowerOnBehaviourModesLastState        HelperPowerOnBehaviourModes = "lastState"
	HelperPowerOnBehaviourModesLevel            HelperPowerOnBehaviourModes = "level"
	HelperPowerOnBehaviourModesOff              HelperPowerOnBehaviourModes = "off"
	HelperPowerOnBehaviourModesOn               HelperPowerOnBehaviourModes = "on"
	HelperPowerOnBehaviourModesUnknown          HelperPowerOnBehaviourModes = "unknown"
)

// Defines values for HelperPushMailUnitIntervalDriven.
const (
	HelperPushMailUnitIntervalDrivenDaily    HelperPushMailUnitIntervalDriven = "daily"
	HelperPushMailUnitIntervalDrivenDisabled HelperPushMailUnitIntervalDriven = "disabled"
	HelperPushMailUnitIntervalDrivenMonthly  HelperPushMailUnitIntervalDriven = "monthly"
	HelperPushMailUnitIntervalDrivenWeekly   HelperPushMailUnitIntervalDriven = "weekly"
)

// Defines values for HelperPushMailUnitPowerStatisticsPeriod.
const (
	HelperPushMailUnitPowerStatisticsPeriodDay     HelperPushMailUnitPowerStatisticsPeriod = "day"
	HelperPushMailUnitPowerStatisticsPeriodMonth   HelperPushMailUnitPowerStatisticsPeriod = "month"
	HelperPushMailUnitPowerStatisticsPeriodUnknown HelperPushMailUnitPowerStatisticsPeriod = "unknown"
	HelperPushMailUnitPowerStatisticsPeriodWeek    HelperPushMailUnitPowerStatisticsPeriod = "week"
	HelperPushMailUnitPowerStatisticsPeriodYear    HelperPushMailUnitPowerStatisticsPeriod = "year"
)

// Defines values for HelperScreenWidgetsMainWifiBands.
const (
	HelperScreenWidgetsMainWifiBandsN24GHz  HelperScreenWidgetsMainWifiBands = "2.4GHz"
	HelperScreenWidgetsMainWifiBandsN5GHz   HelperScreenWidgetsMainWifiBands = "5GHz"
	HelperScreenWidgetsMainWifiBandsN6GHz   HelperScreenWidgetsMainWifiBands = "6GHz"
	HelperScreenWidgetsMainWifiBandsTriband HelperScreenWidgetsMainWifiBands = "triband"
	HelperScreenWidgetsMainWifiBandsUnknown HelperScreenWidgetsMainWifiBands = "unknown"
)

// Defines values for HelperScreenWidgetsPosition.
const (
	BottomCenter HelperScreenWidgetsPosition = "bottomCenter"
	BottomLeft   HelperScreenWidgetsPosition = "bottomLeft"
	BottomRight  HelperScreenWidgetsPosition = "bottomRight"
	Center       HelperScreenWidgetsPosition = "center"
	TopCenter    HelperScreenWidgetsPosition = "topCenter"
	TopLeft      HelperScreenWidgetsPosition = "topLeft"
	TopRight     HelperScreenWidgetsPosition = "topRight"
)

// Defines values for HelperScreenWidgetsTelephoneAnsweringMachineUid.
const (
	TAM0 HelperScreenWidgetsTelephoneAnsweringMachineUid = "TAM0"
	TAM1 HelperScreenWidgetsTelephoneAnsweringMachineUid = "TAM1"
	TAM2 HelperScreenWidgetsTelephoneAnsweringMachineUid = "TAM2"
	TAM3 HelperScreenWidgetsTelephoneAnsweringMachineUid = "TAM3"
	TAM4 HelperScreenWidgetsTelephoneAnsweringMachineUid = "TAM4"
)

// Defines values for HelperStatisticsObjectStatisticsState.
const (
	HelperStatisticsObjectStatisticsStateNotConnected HelperStatisticsObjectStatisticsState = "notConnected"
	HelperStatisticsObjectStatisticsStateOutdated     HelperStatisticsObjectStatisticsState = "outdated"
	HelperStatisticsObjectStatisticsStateUnknown      HelperStatisticsObjectStatisticsState = "unknown"
	HelperStatisticsObjectStatisticsStateValid        HelperStatisticsObjectStatisticsState = "valid"
)

// Defines values for HelperStatisticsPeriod.
const (
	HelperStatisticsPeriodDay      HelperStatisticsPeriod = "day"
	HelperStatisticsPeriodHour     HelperStatisticsPeriod = "hour"
	HelperStatisticsPeriodMonth    HelperStatisticsPeriod = "month"
	HelperStatisticsPeriodTwoYears HelperStatisticsPeriod = "twoYears"
	HelperStatisticsPeriodUnknown  HelperStatisticsPeriod = "unknown"
	HelperStatisticsPeriodWeek     HelperStatisticsPeriod = "week"
)

// Defines values for HelperStatisticsUnitEnergiesStatisticsState.
const (
	HelperStatisticsUnitEnergiesStatisticsStateNotConnected HelperStatisticsUnitEnergiesStatisticsState = "notConnected"
	HelperStatisticsUnitEnergiesStatisticsStateOutdated     HelperStatisticsUnitEnergiesStatisticsState = "outdated"
	HelperStatisticsUnitEnergiesStatisticsStateUnknown      HelperStatisticsUnitEnergiesStatisticsState = "unknown"
	HelperStatisticsUnitEnergiesStatisticsStateValid        HelperStatisticsUnitEnergiesStatisticsState = "valid"
)

// Defines values for HelperStatisticsUnitHumiditiesStatisticsState.
const (
	HelperStatisticsUnitHumiditiesStatisticsStateNotConnected HelperStatisticsUnitHumiditiesStatisticsState = "notConnected"
	HelperStatisticsUnitHumiditiesStatisticsStateOutdated     HelperStatisticsUnitHumiditiesStatisticsState = "outdated"
	HelperStatisticsUnitHumiditiesStatisticsStateUnknown      HelperStatisticsUnitHumiditiesStatisticsState = "unknown"
	HelperStatisticsUnitHumiditiesStatisticsStateValid        HelperStatisticsUnitHumiditiesStatisticsState = "valid"
)

// Defines values for HelperStatisticsUnitPowersStatisticsState.
const (
	HelperStatisticsUnitPowersStatisticsStateNotConnected HelperStatisticsUnitPowersStatisticsState = "notConnected"
	HelperStatisticsUnitPowersStatisticsStateOutdated     HelperStatisticsUnitPowersStatisticsState = "outdated"
	HelperStatisticsUnitPowersStatisticsStateUnknown      HelperStatisticsUnitPowersStatisticsState = "unknown"
	HelperStatisticsUnitPowersStatisticsStateValid        HelperStatisticsUnitPowersStatisticsState = "valid"
)

// Defines values for HelperStatisticsUnitTemperaturesStatisticsState.
const (
	HelperStatisticsUnitTemperaturesStatisticsStateNotConnected HelperStatisticsUnitTemperaturesStatisticsState = "notConnected"
	HelperStatisticsUnitTemperaturesStatisticsStateOutdated     HelperStatisticsUnitTemperaturesStatisticsState = "outdated"
	HelperStatisticsUnitTemperaturesStatisticsStateUnknown      HelperStatisticsUnitTemperaturesStatisticsState = "unknown"
	HelperStatisticsUnitTemperaturesStatisticsStateValid        HelperStatisticsUnitTemperaturesStatisticsState = "valid"
)

// Defines values for HelperStatisticsUnitVoltagesStatisticsState.
const (
	HelperStatisticsUnitVoltagesStatisticsStateNotConnected HelperStatisticsUnitVoltagesStatisticsState = "notConnected"
	HelperStatisticsUnitVoltagesStatisticsStateOutdated     HelperStatisticsUnitVoltagesStatisticsState = "outdated"
	HelperStatisticsUnitVoltagesStatisticsStateUnknown      HelperStatisticsUnitVoltagesStatisticsState = "unknown"
	HelperStatisticsUnitVoltagesStatisticsStateValid        HelperStatisticsUnitVoltagesStatisticsState = "valid"
)

// Defines values for HelperSwitchDurationMode.
const (
	HelperSwitchDurationModePermanent  HelperSwitchDurationMode = "permanent"
	HelperSwitchDurationModeToggleBack HelperSwitchDurationMode = "toggleBack"
	HelperSwitchDurationModeUnknown    HelperSwitchDurationMode = "unknown"
)

// Defines values for HelperSwitchDurationWithSensorMode.
const (
	HelperSwitchDurationWithSensorModePermanent  HelperSwitchDurationWithSensorMode = "permanent"
	HelperSwitchDurationWithSensorModeSensor     HelperSwitchDurationWithSensorMode = "sensor"
	HelperSwitchDurationWithSensorModeToggleBack HelperSwitchDurationWithSensorMode = "toggleBack"
	HelperSwitchDurationWithSensorModeUnknown    HelperSwitchDurationWithSensorMode = "unknown"
)

// Defines values for HelperTemperatureMode.
const (
	HelperTemperatureModeOff         HelperTemperatureMode = "off"
	HelperTemperatureModeOn          HelperTemperatureMode = "on"
	HelperTemperatureModeTemperature HelperTemperatureMode = "temperature"
	HelperTemperatureModeUnknown     HelperTemperatureMode = "unknown"
)

// Defines values for HelperTemplateMemberType.
const (
	HelperTemplateMemberTypeBlind      HelperTemplateMemberType = "blind"
	HelperTemplateMemberTypeNone       HelperTemplateMemberType = "none"
	HelperTemplateMemberTypeOnOff      HelperTemplateMemberType = "onOff"
	HelperTemplateMemberTypeThermostat HelperTemplateMemberType = "thermostat"
	HelperTemplateMemberTypeTrigger    HelperTemplateMemberType = "trigger"
	HelperTemplateMemberTypeUnknown    HelperTemplateMemberType = "unknown"
)

// Defines values for HelperTemplateTimerSunSimulationMode.
const (
	HelperTemplateTimerSunSimulationModeBoth        HelperTemplateTimerSunSimulationMode = "both"
	HelperTemplateTimerSunSimulationModeDisabled    HelperTemplateTimerSunSimulationMode = "disabled"
	HelperTemplateTimerSunSimulationModeSunrise     HelperTemplateTimerSunSimulationMode = "sunrise"
	HelperTemplateTimerSunSimulationModeSunriseOnce HelperTemplateTimerSunSimulationMode = "sunriseOnce"
	HelperTemplateTimerSunSimulationModeSunset      HelperTemplateTimerSunSimulationMode = "sunset"
	HelperTemplateTimerSunSimulationModeSunsetOnce  HelperTemplateTimerSunSimulationMode = "sunsetOnce"
)

// Defines values for HelperTemplateTimerTimerMode.
const (
	HelperTemplateTimerTimerModeAstronomic HelperTemplateTimerTimerMode = "astronomic"
	HelperTemplateTimerTimerModeCountdown  HelperTemplateTimerTimerMode = "countdown"
	HelperTemplateTimerTimerModeDaily      HelperTemplateTimerTimerMode = "daily"
	HelperTemplateTimerTimerModeDisabled   HelperTemplateTimerTimerMode = "disabled"
	HelperTemplateTimerTimerModeOnce       HelperTemplateTimerTimerMode = "once"
	HelperTemplateTimerTimerModeRandom     HelperTemplateTimerTimerMode = "random"
	HelperTemplateTimerTimerModeRhythmic   HelperTemplateTimerTimerMode = "rhythmic"
	HelperTemplateTimerTimerModeUnknown    HelperTemplateTimerTimerMode = "unknown"
	HelperTemplateTimerTimerModeWeekly     HelperTemplateTimerTimerMode = "weekly"
)

// Defines values for HelperUnitTimerSunSimulationMode.
const (
	HelperUnitTimerSunSimulationModeBoth     HelperUnitTimerSunSimulationMode = "both"
	HelperUnitTimerSunSimulationModeDisabled HelperUnitTimerSunSimulationMode = "disabled"
	HelperUnitTimerSunSimulationModeSunrise  HelperUnitTimerSunSimulationMode = "sunrise"
	HelperUnitTimerSunSimulationModeSunset   HelperUnitTimerSunSimulationMode = "sunset"
)

// Defines values for HelperUnitTimerTimerMode.
const (
	Astronomic             HelperUnitTimerTimerMode = "astronomic"
	Calendar               HelperUnitTimerTimerMode = "calendar"
	Countdown              HelperUnitTimerTimerMode = "countdown"
	Daily                  HelperUnitTimerTimerMode = "daily"
	Disabled               HelperUnitTimerTimerMode = "disabled"
	GroupTemperatureWeekly HelperUnitTimerTimerMode = "groupTemperatureWeekly"
	Once                   HelperUnitTimerTimerMode = "once"
	Random                 HelperUnitTimerTimerMode = "random"
	Rhythmic               HelperUnitTimerTimerMode = "rhythmic"
	Weekly                 HelperUnitTimerTimerMode = "weekly"
)

// Defines values for HelperWidgetMode.
const (
	HelperWidgetModeBlindLevel              HelperWidgetMode = "blindLevel"
	HelperWidgetModeColorTemperaturePalette HelperWidgetMode = "colorTemperaturePalette"
	HelperWidgetModeGuestWifi               HelperWidgetMode = "guestWifi"
	HelperWidgetModeHsColorPalette          HelperWidgetMode = "hsColorPalette"
	HelperWidgetModeMainWifi                HelperWidgetMode = "mainWifi"
	HelperWidgetModeOff                     HelperWidgetMode = "off"
	HelperWidgetModeOn                      HelperWidgetMode = "on"
	HelperWidgetModeOnOff                   HelperWidgetMode = "onOff"
	HelperWidgetModeTamControl              HelperWidgetMode = "tamControl"
	HelperWidgetModeTemplate                HelperWidgetMode = "template"
	HelperWidgetModeThermostatFull          HelperWidgetMode = "thermostatFull"
	HelperWidgetModeThermostatTemperature   HelperWidgetMode = "thermostatTemperature"
	HelperWidgetModeToggle                  HelperWidgetMode = "toggle"
	HelperWidgetModeTrigger                 HelperWidgetMode = "trigger"
)

// Defines values for HelperWidgetSize.
const (
	HelperWidgetSizeFull    HelperWidgetSize = "full"
	HelperWidgetSizeHalf    HelperWidgetSize = "half"
	HelperWidgetSizeQuarter HelperWidgetSize = "quarter"
	HelperWidgetSizeUnknown HelperWidgetSize = "unknown"
)

// Defines values for StateBlindState.
const (
	StateBlindStateEndPositionConfigured    StateBlindState = "endPositionConfigured"
	StateBlindStateEndPositionNotConfigured StateBlindState = "endPositionNotConfigured"
	StateBlindStateUnknown                  StateBlindState = "unknown"
)

// Defines values for StateGenericState.
const (
	StateGenericStateNotConnected StateGenericState = "notConnected"
	StateGenericStateUnknown      StateGenericState = "unknown"
	StateGenericStateValid        StateGenericState = "valid"
)

// Defines values for StateOutletState.
const (
	StateOutletStateOvercurrent StateOutletState = "overcurrent"
	StateOutletStateRelayStuck  StateOutletState = "relayStuck"
	StateOutletStateValid       StateOutletState = "valid"
)

// Defines values for StateThermostatState.
const (
	NoAdapt         StateThermostatState = "noAdapt"
	NoError         StateThermostatState = "noError"
	ValveAdapt      StateThermostatState = "valveAdapt"
	ValveInstall    StateThermostatState = "valveInstall"
	ValveInstallRun StateThermostatState = "valveInstallRun"
	ValveMotion     StateThermostatState = "valveMotion"
	ValveShort      StateThermostatState = "valveShort"
)

// Defines values for TypeAlertTypeDefinitions.
const (
	Alert       TypeAlertTypeDefinitions = "alert"
	Closed      TypeAlertTypeDefinitions = "closed"
	Flood       TypeAlertTypeDefinitions = "flood"
	Gas         TypeAlertTypeDefinitions = "gas"
	GlassBreak  TypeAlertTypeDefinitions = "glassBreak"
	Motion      TypeAlertTypeDefinitions = "motion"
	None        TypeAlertTypeDefinitions = "none"
	Obstacle    TypeAlertTypeDefinitions = "obstacle"
	Open        TypeAlertTypeDefinitions = "open"
	Smoke       TypeAlertTypeDefinitions = "smoke"
	Temperature TypeAlertTypeDefinitions = "temperature"
	Unknown     TypeAlertTypeDefinitions = "unknown"
	Vibration   TypeAlertTypeDefinitions = "vibration"
)

// Defines values for TypeApplyTypeDefinitions.
const (
	TypeApplyTypeDefinitionsColor                 TypeApplyTypeDefinitions = "color"
	TypeApplyTypeDefinitionsCustomNotification    TypeApplyTypeDefinitions = "customNotification"
	TypeApplyTypeDefinitionsDialHelper            TypeApplyTypeDefinitions = "dialHelper"
	TypeApplyTypeDefinitionsGuestWifi             TypeApplyTypeDefinitions = "guestWifi"
	TypeApplyTypeDefinitionsHttpRequest           TypeApplyTypeDefinitions = "httpRequest"
	TypeApplyTypeDefinitionsLevel                 TypeApplyTypeDefinitions = "level"
	TypeApplyTypeDefinitionsMainWifi              TypeApplyTypeDefinitions = "mainWifi"
	TypeApplyTypeDefinitionsRelayAutomatic        TypeApplyTypeDefinitions = "relayAutomatic"
	TypeApplyTypeDefinitionsRelayManual           TypeApplyTypeDefinitions = "relayManual"
	TypeApplyTypeDefinitionsSubTemplates          TypeApplyTypeDefinitions = "subTemplates"
	TypeApplyTypeDefinitionsSunSimulation         TypeApplyTypeDefinitions = "sunSimulation"
	TypeApplyTypeDefinitionsSwitchMaster          TypeApplyTypeDefinitions = "switchMaster"
	TypeApplyTypeDefinitionsTamControl            TypeApplyTypeDefinitions = "tamControl"
	TypeApplyTypeDefinitionsThermostatHoliday     TypeApplyTypeDefinitions = "thermostatHoliday"
	TypeApplyTypeDefinitionsThermostatOnOff       TypeApplyTypeDefinitions = "thermostatOnOff"
	TypeApplyTypeDefinitionsThermostatTemperature TypeApplyTypeDefinitions = "thermostatTemperature"
	TypeApplyTypeDefinitionsThermostatTimetable   TypeApplyTypeDefinitions = "thermostatTimetable"
	TypeApplyTypeDefinitionsTimerControl          TypeApplyTypeDefinitions = "timerControl"
)

// Defines values for TypeScenarioType.
const (
	Coming  TypeScenarioType = "coming"
	Leaving TypeScenarioType = "leaving"
)

// Defines values for TypeUnitType.
const (
	AcOutlet                          TypeUnitType = "acOutlet"
	AcOutletSimplePowerMetering       TypeUnitType = "acOutletSimplePowerMetering"
	AvmButton                         TypeUnitType = "avmButton"
	AvmMeter                          TypeUnitType = "avmMeter"
	AvmMeterFeedIn                    TypeUnitType = "avmMeterFeedIn"
	AvmPlugSocket                     TypeUnitType = "avmPlugSocket"
	AvmThermostat                     TypeUnitType = "avmThermostat"
	AvmWidgetButton                   TypeUnitType = "avmWidgetButton"
	Blind                             TypeUnitType = "blind"
	BlindGroup                        TypeUnitType = "blindGroup"
	ColorBulb                         TypeUnitType = "colorBulb"
	DimmableColorBulb                 TypeUnitType = "dimmableColorBulb"
	DimmableLight                     TypeUnitType = "dimmableLight"
	DimmerSwitch                      TypeUnitType = "dimmerSwitch"
	DoorOpenCloseDetector             TypeUnitType = "doorOpenCloseDetector"
	FloodDetector                     TypeUnitType = "floodDetector"
	GasDetector                       TypeUnitType = "gasDetector"
	Generic                           TypeUnitType = "generic"
	GenericApplicationLogic           TypeUnitType = "genericApplicationLogic"
	GlassBreakDetector                TypeUnitType = "glassBreakDetector"
	Lamellar                          TypeUnitType = "lamellar"
	MotionDetector                    TypeUnitType = "motionDetector"
	OtherGroup                        TypeUnitType = "otherGroup"
	SimpleButton                      TypeUnitType = "simpleButton"
	SimpleDetector                    TypeUnitType = "simpleDetector"
	SimpleDoorBell                    TypeUnitType = "simpleDoorBell"
	SimpleDoorLock                    TypeUnitType = "simpleDoorLock"
	SimpleHumiditySensor              TypeUnitType = "simpleHumiditySensor"
	SimpleLevelControllable           TypeUnitType = "simpleLevelControllable"
	SimpleLevelControllableSwitchable TypeUnitType = "simpleLevelControllableSwitchable"
	SimpleLight                       TypeUnitType = "simpleLight"
	SimpleOnOffSwitchable             TypeUnitType = "simpleOnOffSwitchable"
	SimpleTemperatureSensor           TypeUnitType = "simpleTemperatureSensor"
	Siren                             TypeUnitType = "siren"
	SmokeDetector                     TypeUnitType = "smokeDetector"
	SwitchableGroup                   TypeUnitType = "switchableGroup"
	ThermostatGroup                   TypeUnitType = "thermostatGroup"
	UserInterface                     TypeUnitType = "userInterface"
	VibrationDetector                 TypeUnitType = "vibrationDetector"
	WindowOpenCloseDetector           TypeUnitType = "windowOpenCloseDetector"
)

// IFAlertConfig defines model for IF_alert_config.
type IFAlertConfig = map[string]interface{}

// IFAlertConfigBase defines model for IF_alert_config_base.
type IFAlertConfigBase struct {
	ActivePeriod *HelperActivePeriodAlertButton `json:"activePeriod,omitempty"`

	// Alerts type of alert
	Alerts             *[]IFAlertConfigBase_Alerts_Item `json:"alerts,omitempty"`
	AvailableTemplates *HelperAvailableTemplates        `json:"availableTemplates,omitempty"`

	// AvailableThermostats list of thermostat unit UIDs that can be added to the thermostatDestinationUids
	AvailableThermostats *[]string              `json:"availableThermostats,omitempty"`
	AvailableUnits       *HelperAvailableUnits  `json:"availableUnits,omitempty"`
	DestinationMode      *HelperDestinationMode `json:"destinationMode,omitempty"`
	DestinationUids      *HelperDestinationUids `json:"destinationUids,omitempty"`

	// LastAlertTime - timestamp of last alert
	// - only valid, if there was an event and host has valid time
	LastAlertTime *HelperTimestamp  `json:"lastAlertTime,omitempty"`
	State         StateGenericState `json:"state"`

	// ThermostatDestinationUids - only available for units with the unitType `doorOpenCloseDetector` or `windowOpenCloseDetector`
	// - besides switching onOff-units this allows for automatically enabling/disabling the `windowOpenMode` of thermostats
	// - when adding a thermostat to this list, the `internal` `windowOpenMode.sensorMode` of the added thermostat will be overwritten
	ThermostatDestinationUids *[]string `json:"thermostatDestinationUids,omitempty"`
}

// IFAlertConfigBase_Alerts_Item defines model for IF_alert_config_base.alerts.Item.
type IFAlertConfigBase_Alerts_Item struct {
	union json.RawMessage
}

// IFAlertConfigUnits defines model for IF_alert_config_units.
type IFAlertConfigUnits struct {
	ActivePeriod *HelperActivePeriodAlertButton `json:"activePeriod,omitempty"`

	// Alerts type of alert
	Alerts             *[]IFAlertConfigUnits_Alerts_Item `json:"alerts,omitempty"`
	AvailableTemplates *HelperAvailableTemplates         `json:"availableTemplates,omitempty"`

	// AvailableThermostats list of thermostat unit UIDs that can be added to the thermostatDestinationUids
	AvailableThermostats *[]string             `json:"availableThermostats,omitempty"`
	AvailableUnits       *HelperAvailableUnits `json:"availableUnits,omitempty"`

	// ControlMode - only available for units
	// - event in case of sensor event
	ControlMode     *IFAlertConfigUnitsControlMode `json:"controlMode,omitempty"`
	DestinationMode *HelperDestinationMode         `json:"destinationMode,omitempty"`
	DestinationUids *HelperDestinationUids         `json:"destinationUids,omitempty"`

	// LastAlertTime - timestamp of last alert
	// - only valid, if there was an event and host has valid time
	LastAlertTime  *HelperTimestamp                `json:"lastAlertTime,omitempty"`
	State          StateGenericState               `json:"state"`
	SwitchDuration *HelperSwitchDurationWithSensor `json:"switchDuration,omitempty"`

	// ThermostatDestinationUids - only available for units with the unitType `doorOpenCloseDetector` or `windowOpenCloseDetector`
	// - besides switching onOff-units this allows for automatically enabling/disabling the `windowOpenMode` of thermostats
	// - when adding a thermostat to this list, the `internal` `windowOpenMode.sensorMode` of the added thermostat will be overwritten
	ThermostatDestinationUids *[]string `json:"thermostatDestinationUids,omitempty"`
}

// IFAlertConfigUnits_Alerts_Item defines model for IF_alert_config_units.alerts.Item.
type IFAlertConfigUnits_Alerts_Item struct {
	union json.RawMessage
}

// IFAlertConfigUnitsControlMode - only available for units
// - event in case of sensor event
type IFAlertConfigUnitsControlMode string

// IFAlertOverview defines model for IF_alert_overview.
type IFAlertOverview struct {
	// Alerts type of alert
	Alerts *[]IFAlertOverview_Alerts_Item `json:"alerts,omitempty"`

	// LastAlertTime - timestamp of last alert
	// - only valid, if there was an event and host has valid time
	LastAlertTime *HelperTimestamp  `json:"lastAlertTime,omitempty"`
	State         StateGenericState `json:"state"`
}

// IFAlertOverview_Alerts_Item defines model for IF_alert_overview.alerts.Item.
type IFAlertOverview_Alerts_Item struct {
	union json.RawMessage
}

// IFBlindConfig defines model for IF_blind_config.
type IFBlindConfig struct {
	// BlindAction When reading, this describes the last known state, which the blind send; when writing you can tell the blind to move into a certain (blind-specific) direction or to stop
	BlindAction           *HelperBlindAction                `json:"blindAction,omitempty"`
	BlindState            *StateBlindState                  `json:"blindState,omitempty"`
	CurrentSensingEnabled *HelperCurrentSensingEnabled      `json:"currentSensingEnabled,omitempty"`
	EndPositions          *HelperEndPositions               `json:"endPositions,omitempty"`
	FlyScreenProtection   *HelperFlyScreenProtectionEnabled `json:"flyScreenProtection,omitempty"`
	FreezeProtection      *HelperFreezeProtectionEnabled    `json:"freezeProtection,omitempty"`
	LamellarEnabled       *HelperLamellarEnabled            `json:"lamellarEnabled,omitempty"`
	LamellarSlatRuntime   *HelperLamellarSlatRuntime        `json:"lamellarSlatRuntime,omitempty"`
	State                 StateGenericState                 `json:"state"`
}

// IFBlindOverview defines model for IF_blind_overview.
type IFBlindOverview struct {
	// BlindAction When reading, this describes the last known state, which the blind send; when writing you can tell the blind to move into a certain (blind-specific) direction or to stop
	BlindAction *HelperBlindAction `json:"blindAction,omitempty"`
	BlindState  *StateBlindState   `json:"blindState,omitempty"`
	State       StateGenericState  `json:"state"`
}

// IFButtonConfig defines model for IF_button_config.
type IFButtonConfig = map[string]interface{}

// IFButtonConfigBase defines model for IF_button_config_base.
type IFButtonConfigBase struct {
	ActivePeriod       *HelperActivePeriodAlertButton `json:"activePeriod,omitempty"`
	AvailableTemplates *HelperAvailableTemplates      `json:"availableTemplates,omitempty"`
	AvailableUnits     *HelperAvailableUnits          `json:"availableUnits,omitempty"`
	DestinationMode    *HelperDestinationMode         `json:"destinationMode,omitempty"`
	DestinationUids    *HelperDestinationUids         `json:"destinationUids,omitempty"`

	// LastEventTime Timestamp of last button press. Only valid, if there was an event and host has valid time.
	LastEventTime *HelperTimestamp  `json:"lastEventTime,omitempty"`
	State         StateGenericState `json:"state"`
}

// IFButtonConfigUnits defines model for IF_button_config_units.
type IFButtonConfigUnits struct {
	ActivePeriod       *HelperActivePeriodAlertButton `json:"activePeriod,omitempty"`
	AvailableTemplates *HelperAvailableTemplates      `json:"availableTemplates,omitempty"`
	AvailableUnits     *HelperAvailableUnits          `json:"availableUnits,omitempty"`

	// ControlMode - only available for units
	// - event in case of button press
	// - when setting `controlMode` to `toggle`, `switchDuration.mode` will automatically be set to `permanent`
	// - TODO: info about what on/off/toggle means for blinds
	ControlMode     *HelperControlMode     `json:"controlMode,omitempty"`
	DestinationMode *HelperDestinationMode `json:"destinationMode,omitempty"`
	DestinationUids *HelperDestinationUids `json:"destinationUids,omitempty"`

	// LastEventTime Timestamp of last button press. Only valid, if there was an event and host has valid time.
	LastEventTime *HelperTimestamp  `json:"lastEventTime,omitempty"`
	State         StateGenericState `json:"state"`

	// SwitchDuration - only available for units
	// - choose whether switching of unit should be permanent or toggle back after configured time
	// - `toggleBack` mode only available if `controlMode` is set to either `on` or `off`
	SwitchDuration *HelperSwitchDuration `json:"switchDuration,omitempty"`
}

// IFButtonOverview functional interface for a simple button sensor
type IFButtonOverview = ButtonBase

// IFColorControlConfig defines model for IF_colorControl_config.
type IFColorControlConfig struct {
	ActiveHsColorPreset *HelperActiveHsColorPreset `json:"activeHsColorPreset,omitempty"`
	AvmPresets          *HelperAvmPresets          `json:"avmPresets,omitempty"`

	// ColorTemperature - "Kelvin (usually 2700..6500)"
	// - when setting the color on a unit with an onOffInterface, the onOff will not be modified automatically
	ColorTemperature *int `json:"colorTemperature,omitempty"`

	// CurrentColorMode what color mode is currently active
	CurrentColorMode *IFColorControlConfigCurrentColorMode `json:"currentColorMode,omitempty"`
	HsColor          *HelperHsColor                        `json:"hsColor,omitempty"`
	State            StateGenericState                     `json:"state"`

	// SupportedColorModes hueSaturation, temperature, unknown
	SupportedColorModes *[]IFColorControlConfigSupportedColorModes `json:"supportedColorModes,omitempty"`
}

// IFColorControlConfigCurrentColorMode what color mode is currently active
type IFColorControlConfigCurrentColorMode string

// IFColorControlConfigSupportedColorModes defines model for IFColorControlConfig.SupportedColorModes.
type IFColorControlConfigSupportedColorModes string

// IFColorControlOverview defines model for IF_colorControl_overview.
type IFColorControlOverview struct {
	ActiveHsColorPreset *HelperActiveHsColorPreset `json:"activeHsColorPreset,omitempty"`

	// ColorTemperature - "Kelvin (usually 2700..6500)"
	// - when setting the color on a unit with an onOffInterface, the onOff will not be modified automatically
	ColorTemperature *int `json:"colorTemperature,omitempty"`

	// CurrentColorMode what color mode is currently active
	CurrentColorMode *IFColorControlOverviewCurrentColorMode `json:"currentColorMode,omitempty"`
	HsColor          *HelperHsColor                          `json:"hsColor,omitempty"`
	State            StateGenericState                       `json:"state"`

	// SupportedColorModes hueSaturation, temperature, unknown
	SupportedColorModes *[]IFColorControlOverviewSupportedColorModes `json:"supportedColorModes,omitempty"`
}

// IFColorControlOverviewCurrentColorMode what color mode is currently active
type IFColorControlOverviewCurrentColorMode string

// IFColorControlOverviewSupportedColorModes defines model for IFColorControlOverview.SupportedColorModes.
type IFColorControlOverviewSupportedColorModes string

// IFHumidity functional interface for devices with humidity sensors
type IFHumidity struct {
	// RelativeHumidity current relative humidity
	RelativeHumidity *int              `json:"relativeHumidity,omitempty"`
	State            StateGenericState `json:"state"`
}

// IFLevelControl functional interface for devices with a level (lights or blinds)
type IFLevelControl struct {
	// Level - level of bulb or blind
	// - when setting the level on a unit with an onOffInterface, the onOffInterface.active will not be modified automatically
	Level *int              `json:"level,omitempty"`
	State StateGenericState `json:"state"`
}

// IFMultimeter defines model for IF_multimeter.
type IFMultimeter struct {
	// Current current [mA], resolution: 1 mA
	Current *int `json:"current,omitempty"`

	// Energy - energy [Wh], resolution: 1 Wh
	// - total energy since start of record
	Energy           *int `json:"energy,omitempty"`
	EnergyKeyFigures *struct {
		// Co2emmissions CO2-emmissions [g] - g/kWh
		Co2emmissions *float32 `json:"co2emmissions,omitempty"`

		// ElectricityRate price [] - electricity rate in /kWh, resolution: 0.01 cents
		ElectricityRate *float32 `json:"electricityRate,omitempty"`
	} `json:"energyKeyFigures,omitempty"`

	// Power power [milliWatts], resolution: 10 mW
	Power *int              `json:"power,omitempty"`
	State StateGenericState `json:"state"`

	// Voltage voltage [mV], resolution: 1 mV
	Voltage *int `json:"voltage,omitempty"`
}

// IFMultimeterConfig defines model for IF_multimeter_config.
type IFMultimeterConfig struct {
	// Current current [mA], resolution: 1 mA
	Current *int `json:"current,omitempty"`

	// Energy - energy [Wh], resolution: 1 Wh
	// - total energy since start of record
	Energy           *int `json:"energy,omitempty"`
	EnergyKeyFigures *struct {
		// Co2emmissions CO2-emmissions [g] - g/kWh
		Co2emmissions *float32 `json:"co2emmissions,omitempty"`

		// ElectricityRate price [] - electricity rate in /kWh, resolution: 0.01 cents
		ElectricityRate *float32 `json:"electricityRate,omitempty"`
	} `json:"energyKeyFigures,omitempty"`

	// Power power [milliWatts], resolution: 10 mW
	Power *int              `json:"power,omitempty"`
	State StateGenericState `json:"state"`

	// Voltage voltage [mV], resolution: 1 mV
	Voltage *int `json:"voltage,omitempty"`
}

// IFOnOffConfig defines model for IF_onOff_config.
type IFOnOffConfig struct {
	// Active The unit is turned on if true. For FRITZ!Smart Energy plugsockets onOff will only be returned, if the outletState is valid.
	Active *bool `json:"active,omitempty"`

	// ButtonLedEnabled - only available for FRITZ!Smart Energy plugosckets
	// - set state of button LED of FRITZ!Smart Energy plugsockets
	// - if turned off, LED will only be turned on in case of an error
	ButtonLedEnabled *bool `json:"buttonLedEnabled,omitempty"`

	// LockedDeviceApiEnabled operation via API (App, UI, REST) of device is locked
	LockedDeviceApiEnabled *bool `json:"lockedDeviceApiEnabled,omitempty"`

	// LockedDeviceLocalEnabled local operation of device is locked (HAN-FUN plug has no lock)
	LockedDeviceLocalEnabled *bool                     `json:"lockedDeviceLocalEnabled,omitempty"`
	NoiseControl             *HelperNoiseControl       `json:"noiseControl,omitempty"`
	OutletState              *StateOutletState         `json:"outletState,omitempty"`
	PowerOnBehaviour         *HelperPowerOnBehaviour   `json:"powerOnBehaviour,omitempty"`
	StandbyAutoTurnOff       *HelperStandbyAutoTurnOff `json:"standbyAutoTurnOff,omitempty"`
	State                    StateGenericState         `json:"state"`
}

// IFOnOffOverview defines model for IF_onOff_overview.
type IFOnOffOverview struct {
	// Active The unit is turned on if true. For FRITZ!Smart Energy plugsockets onOff will only be returned, if the outletState is valid.
	Active *bool `json:"active,omitempty"`

	// IsLockedDeviceApi operation via API (App, UI, REST) of device is locked
	IsLockedDeviceApi *bool `json:"isLockedDeviceApi,omitempty"`

	// IsLockedDeviceLocal local operation of device is locked (HAN-FUN plug has no lock)
	IsLockedDeviceLocal *bool             `json:"isLockedDeviceLocal,omitempty"`
	OutletState         *StateOutletState `json:"outletState,omitempty"`
	State               StateGenericState `json:"state"`
}

// IFPutUnitInterfaces defines model for IF_putUnitInterfaces.
type IFPutUnitInterfaces struct {
	AlertInterface *IFAlertOverview `json:"alertInterface,omitempty"`
	BlindInterface *struct {
		// BlindAction When reading, this describes the last known state, which the blind send; when writing you can tell the blind to move into a certain (blind-specific) direction or to stop
		BlindAction HelperBlindAction `json:"blindAction"`
		BlindState  *StateBlindState  `json:"blindState,omitempty"`
		State       StateGenericState `json:"state"`
	} `json:"blindInterface,omitempty"`
	ButtonInterface       *IFButtonOverview       `json:"buttonInterface,omitempty"`
	ColorControlInterface *IFColorControlOverview `json:"colorControlInterface,omitempty"`
	HumidityInterface     *IFHumidity             `json:"humidityInterface,omitempty"`
	LevelControlInterface *struct {
		// Level - level of bulb or blind
		// - when setting the level on a unit with an onOffInterface, the onOffInterface.active will not be modified automatically
		Level int               `json:"level"`
		State StateGenericState `json:"state"`
	} `json:"levelControlInterface,omitempty"`
	MultimeterInterface *IFMultimeter `json:"multimeterInterface,omitempty"`
	OnOffInterface      *struct {
		// Active The unit is turned on if true. For FRITZ!Smart Energy plugsockets onOff will only be returned, if the outletState is valid.
		Active bool `json:"active"`

		// IsLockedDeviceApi operation via API (App, UI, REST) of device is locked
		IsLockedDeviceApi *bool `json:"isLockedDeviceApi,omitempty"`

		// IsLockedDeviceLocal local operation of device is locked (HAN-FUN plug has no lock)
		IsLockedDeviceLocal *bool             `json:"isLockedDeviceLocal,omitempty"`
		OutletState         *StateOutletState `json:"outletState,omitempty"`
		State               StateGenericState `json:"state"`
	} `json:"onOffInterface,omitempty"`
	SmartmeterInterface  *IFSmartmeter          `json:"smartmeterInterface,omitempty"`
	TemperatureInterface *IFTemperatureOverview `json:"temperatureInterface,omitempty"`
	ThermostatInterface  *IFThermostatOverview  `json:"thermostatInterface,omitempty"`
}

// IFSmartmeter defines model for IF_smartmeter.
type IFSmartmeter struct {
	SmartmeterState *StateSmartmeterState `json:"smartmeterState,omitempty"`
	State           StateGenericState     `json:"state"`
}

// IFTemperatureConfig defines model for IF_temperature_config.
type IFTemperatureConfig struct {
	// Celsius - temperature [C] of device
	// - if a temperature offset is configured (either here on in the thermostatInterface) you may want to display the temperature including the offset for ease of use
	Celsius *float32 `json:"celsius,omitempty"`

	// Offset - only available for FRITZ! FRITZ!Smart Energy plugsockets
	// - temperature offset in Celsius
	Offset *float32          `json:"offset,omitempty"`
	State  StateGenericState `json:"state"`
}

// IFTemperatureOverview defines model for IF_temperature_overview.
type IFTemperatureOverview struct {
	// Celsius - temperature [C] of device
	// - if a temperature offset is configured (either here on in the thermostatInterface) you may want to display the temperature including the offset for ease of use
	Celsius *float32          `json:"celsius,omitempty"`
	State   StateGenericState `json:"state"`
}

// IFTemplateColorControl defines model for IF_template_colorControl.
type IFTemplateColorControl struct {
	ActiveHsColorPreset *HelperActiveHsColorPreset `json:"activeHsColorPreset,omitempty"`

	// AvmPresets curated hsColors and colorTemperatures
	AvmPresets *HelperAvmPresets `json:"avmPresets,omitempty"`

	// ColorTemperature - "Kelvin (usually 2700..6500)"
	// - when setting the color on a unit with an onOffInterface, the onOff will not be modified automatically
	ColorTemperature *int           `json:"colorTemperature,omitempty"`
	HsColor          *HelperHsColor `json:"hsColor,omitempty"`
}

// IFTemplateDialHelper - functional interface for templates with dial helper capability
type IFTemplateDialHelper struct {
	// DestinationNumbers - numbers which will be called
	// - if setting an external number as destination, only one is allowed with a maximum length of 32 characters
	// - if setting internal number as destinations, up to 4 are allowed
	// - internal numbers start with '**'
	DestinationNumbers *[]string `json:"destinationNumbers,omitempty"`

	// Message - optional text message, which will be displayed on the display of the configured phone
	// - if empty, the phone will display the name of the template
	// - up to 39 2-Byte UTF-8 characters or up to 80 bytes allowed
	Message *string `json:"message,omitempty"`
}

// IFTemplateGroup functional interface for templates with onOff-group units for setting the onOffMasterUnit
type IFTemplateGroup struct {
	// AvailableOnOffUnits List of UIDs of possible units that can be configured as a onOffMasterUnit
	AvailableOnOffUnits *[]string                `json:"availableOnOffUnits,omitempty"`
	OnOffMasterUnitUid  HelperOnOffMasterUnitUid `json:"onOffMasterUnitUid"`
}

// IFTemplateGuestWifi functional interface for templates with guest wifi capability
type IFTemplateGuestWifi struct {
	// Enabled turn guest wifi on or off
	Enabled bool `json:"enabled"`
}

// IFTemplateHttpRequest functional interface for templates with http request capability
type IFTemplateHttpRequest struct {
	// Body - http body for the request
	// - up to 255 bytes allowed
	Body *string `json:"body,omitempty"`

	// Header - http header for the request
	// - up to 255 bytes allowed
	Header *string `json:"header,omitempty"`

	// Method http method for the request
	Method *IFTemplateHttpRequestMethod `json:"method,omitempty"`

	// Url - url to send the http request to
	// - up to 255 bytes allowed
	Url *string `json:"url,omitempty"`
}

// IFTemplateHttpRequestMethod http method for the request
type IFTemplateHttpRequestMethod string

// IFTemplateLevelControl - functional interface for templates with level capability (lamps & blinds)
// - when setting the levelControl for lamps, it is advisable to also set the `onOffInterface`, as it will be activated automatically
type IFTemplateLevelControl struct {
	// Level - fixed or relative level for lamp or blind
	// - when setting a fixed level on a unit with an onOffInterface, the onOffInterface.active will not be modified automatically
	Level *int `json:"level,omitempty"`

	// Mode set the level to a fixed amount or inc-/decrease it
	Mode *IFTemplateLevelControlMode `json:"mode,omitempty"`
}

// IFTemplateLevelControlMode set the level to a fixed amount or inc-/decrease it
type IFTemplateLevelControlMode string

// IFTemplateMainWifi functional interface for templates with main wifi capability
type IFTemplateMainWifi struct {
	// Enabled turn wifi on or off
	Enabled bool `json:"enabled"`
}

// IFTemplateNotification functional interface for templates with custom notification capability
type IFTemplateNotification struct {
	// Message - message text for the notification
	// - up to 500 2-Byte UTF-8 characters or up to 1000 bytes allowed
	Message *string `json:"message,omitempty"`

	// Mode whether to send a pushMail to the configured recipient or a push notification to all configured F!Smarthome-Apps
	Mode IFTemplateNotificationMode `json:"mode"`

	// Recipient - E-mail adress of push-mail recipient
	// - required if `mode` is set to `pushMail`
	// - user defined name of physical device, up to 127 2-Byte UTF-8 characters or up to 255 bytes allowed
	Recipient *string `json:"recipient,omitempty"`

	// Subject - subject for the notification
	// - up to 100 2-Byte UTF-8 characters or up to 200 bytes allowed
	Subject *string `json:"subject,omitempty"`
}

// IFTemplateNotificationMode whether to send a pushMail to the configured recipient or a push notification to all configured F!Smarthome-Apps
type IFTemplateNotificationMode string

// IFTemplateOnOff functional interface for templates with on/off capability (plugs & lamps)
type IFTemplateOnOff struct {
	// ControlMode - turn the destination on, off or toggle it
	// - when setting `controlMode` to `toggle`, `switchDuration.mode` will automatically be set to `permanent`
	ControlMode    HelperControlMode     `json:"controlMode"`
	SwitchDuration *HelperSwitchDuration `json:"switchDuration,omitempty"`
}

// IFTemplateTelephoneAnsweringMachine functional interface for templates with telephone answering machine capability
type IFTemplateTelephoneAnsweringMachine struct {
	// Enabled turn configured telephone answering machines on or off
	Enabled *bool `json:"enabled,omitempty"`

	// TelephoneAnsweringMachineUids UIDs of assigned telephoneAnsweringMachine (if empty -> none assigned)
	TelephoneAnsweringMachineUids *[]IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUids `json:"telephoneAnsweringMachineUids,omitempty"`
}

// IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUids unique identifier corresponding to telephone anwering machine
type IFTemplateTelephoneAnsweringMachineTelephoneAnsweringMachineUids string

// IFTemplateThermostat functional interface for templates with thermostat capability
type IFTemplateThermostat struct {
	HolidayPeriods *HelperHolidayPeriods `json:"holidayPeriods,omitempty"`

	// Mode - set the destination to a fixed or relative setpointTemperature
	// - activate the boost/windowOpen special mode or deactivate it, if one of them is active
	// - configure the holidayPeriods and/or summerPeriod
	Mode IFTemplateThermostatMode `json:"mode"`

	// SetPointTemperature - required if `mode` is set to `setPointTemperature`
	// - set to fixed setpoint temperature, the currently configured comfort/reduced temperature or increase/decrease the setpointtemperature
	SetPointTemperature *struct {
		// Celsius Only valid if 'mode' is set to `temperature`
		Celsius *float32                                    `json:"celsius,omitempty"`
		Mode    IFTemplateThermostatSetPointTemperatureMode `json:"mode"`

		// RelativeCelsius - required if `mode` is set to `relative`
		// - increase/decrease the currently configured setPointTemperature by a certain value
		RelativeCelsius *float32 `json:"relativeCelsius,omitempty"`
	} `json:"setPointTemperature,omitempty"`

	// SpecialModeTime - required if `mode` is set to either `boost` or `windowOpenMode`
	// - time in seconds for chosen special mode to be active
	SpecialModeTime *int                `json:"specialModeTime,omitempty"`
	SummerPeriod    *HelperSummerPeriod `json:"summerPeriod,omitempty"`
}

// IFTemplateThermostatMode - set the destination to a fixed or relative setpointTemperature
// - activate the boost/windowOpen special mode or deactivate it, if one of them is active
// - configure the holidayPeriods and/or summerPeriod
type IFTemplateThermostatMode string

// IFTemplateThermostatSetPointTemperatureMode defines model for IFTemplateThermostat.SetPointTemperature.Mode.
type IFTemplateThermostatSetPointTemperatureMode string

// IFTemplateTrigger functional interface for templates with trigger capability
type IFTemplateTrigger struct {
	// Enabled turn configured trigger on or off
	Enabled bool `json:"enabled"`
}

// IFTemplatesInterfaces - object grouping all functional interfaces for templates together
// - may be empty if no supported interface is present
// - for deleting one specific interface, you need to send the interfaces-object without it
// - **hence when editing interfaces you always need to send all interface-sub-objects you want to keep**
type IFTemplatesInterfaces struct {
	ColorControlInterface              *IFTemplateColorControl              `json:"colorControlInterface,omitempty"`
	DialHelperInterface                *IFTemplateDialHelper                `json:"dialHelperInterface,omitempty"`
	GroupInterface                     *IFTemplateGroup                     `json:"groupInterface,omitempty"`
	GuestWifiInterface                 *IFTemplateGuestWifi                 `json:"guestWifiInterface,omitempty"`
	HttpRequestInterface               *IFTemplateHttpRequest               `json:"httpRequestInterface,omitempty"`
	LevelControlInterface              *IFTemplateLevelControl              `json:"levelControlInterface,omitempty"`
	MainWifiInterface                  *IFTemplateMainWifi                  `json:"mainWifiInterface,omitempty"`
	NotificationInterface              *IFTemplateNotification              `json:"notificationInterface,omitempty"`
	OnOffInterface                     *IFTemplateOnOff                     `json:"onOffInterface,omitempty"`
	TelephoneAnsweringMachineInterface *IFTemplateTelephoneAnsweringMachine `json:"telephoneAnsweringMachineInterface,omitempty"`
	ThermostatInterface                *IFTemplateThermostat                `json:"thermostatInterface,omitempty"`
	TriggerInterface                   *IFTemplateTrigger                   `json:"triggerInterface,omitempty"`
}

// IFThermostatConfig defines model for IF_thermostat_config.
type IFThermostatConfig struct {
	// AdaptiveHeatingModeEnabled Enable the adaptive heating period
	AdaptiveHeatingModeEnabled *bool `json:"adaptiveHeatingModeEnabled,omitempty"`

	// Boost Boost special mode.
	Boost *HelperSpecialModeThermostat `json:"boost,omitempty"`

	// ComfortTemperature Comfort temperature preset used for timer of thermostat
	ComfortTemperature *HelperTemperature    `json:"comfortTemperature,omitempty"`
	HolidayPeriods     *HelperHolidayPeriods `json:"holidayPeriods,omitempty"`

	// IsAdaptiveRunning Adaptive heating period is active (up to an hour before the comfort temperature timer-configuration). Not available for Comet DECT and FRITZ!DECT 300.
	IsAdaptiveRunning *bool `json:"isAdaptiveRunning,omitempty"`

	// IsHolidayActive Holiday period is active (e.g. thermostat is in freeze protection mode)
	IsHolidayActive *bool `json:"isHolidayActive,omitempty"`

	// IsSummertimeActive Summertime is active (e.g. thermostat is in freeze protection mode)
	IsSummertimeActive *bool `json:"isSummertimeActive,omitempty"`

	// LockedDeviceApiEnabled Operation via API (App, UI, REST) of device is locked
	LockedDeviceApiEnabled *bool `json:"lockedDeviceApiEnabled,omitempty"`

	// LockedDeviceLocalEnabled Local operation of device is locked
	LockedDeviceLocalEnabled *bool             `json:"lockedDeviceLocalEnabled,omitempty"`
	NextChange               *HelperNextChange `json:"nextChange,omitempty"`

	// ReducedTemperature Reduced temperature preset used for timer of thermostat
	ReducedTemperature *HelperTemperature `json:"reducedTemperature,omitempty"`

	// SetPointTemperature Current setpoint temperature of thermostat
	SetPointTemperature *HelperTemperature  `json:"setPointTemperature,omitempty"`
	State               StateGenericState   `json:"state"`
	SummerPeriod        *HelperSummerPeriod `json:"summerPeriod,omitempty"`

	// TemperatureOffset Offset configuration for thermostat
	TemperatureOffset *struct {
		// ExternalAvailableSensors List of UIDs of possible UIDs that can be configured as an external temperature Sensor
		ExternalAvailableSensors *[]string `json:"externalAvailableSensors,omitempty"`

		// ExternalSensorUid UID of active external temperature sensor unit, if empty, no external sensor is configured
		ExternalSensorUid *string `json:"externalSensorUid,omitempty"`

		// InternalOffset Manual offset configuration. Only valid if internal mode is active.
		InternalOffset *float32 `json:"internalOffset,omitempty"`

		// SensorMode - internal: Manual configuration of temperature offset. The thermostat uses its internal temperature readings as a base.
		// - external: An external temperature-sensor (chosen from the externalAvailableSensors) automatically detects the temperature offset.
		// - internal and external sensorMode are mutually exclusive
		// - internal is the default value
		// - Comet DECT and FRITZ!DECT 300 only support the `internal` sensorMode
		SensorMode IFThermostatConfigTemperatureOffsetSensorMode `json:"sensorMode"`
	} `json:"temperatureOffset,omitempty"`
	TemperatureRangeLock *struct {
		// Maximum Maximum temperature
		Maximum *HelperTemperature `json:"maximum,omitempty"`

		// Minimum Minimum temperature
		Minimum *HelperTemperature `json:"minimum,omitempty"`

		// TemperatureLockEnabled Temperature Range is locked
		TemperatureLockEnabled *bool `json:"temperatureLockEnabled,omitempty"`
	} `json:"temperatureRangeLock,omitempty"`
	ThermostatState *StateThermostatState `json:"thermostatState,omitempty"`
	WindowOpenMode  *struct {
		// Enabled Special mode is active. Only valid if Host has a valid time.
		Enabled *bool `json:"enabled,omitempty"`

		// EndTime Unix timestamp for end of special mode. Required when enabling special mode. *null* means time is unknown, -1 means no (end-)time is set.
		EndTime *int `json:"endTime"`

		// ExternalAvailableSensors List of UIDs of possible units that can be configured as an external window Sensor
		ExternalAvailableSensors *[]string `json:"externalAvailableSensors,omitempty"`

		// ExternalSensorUids - list of UIDs of active external window sensor units
		// - if empty, no external sensor is configured
		// - when configuring externalSensors, sensorMode is required to be set to `external`
		ExternalSensorUids *[]string `json:"externalSensorUids,omitempty"`

		// InternalDuration Time in minutes freeze protection should stay turned on after thermostat detected open window. Only valid if internal mode is active.
		InternalDuration *int `json:"internalDuration,omitempty"`

		// InternalSensitivity Sensitivity for automatically detecting temperature drops (e.g. open window) while the internal sensorMode is active.
		InternalSensitivity *IFThermostatConfigWindowOpenModeInternalSensitivity `json:"internalSensitivity,omitempty"`

		// SensorMode - internal: The thermostat automatically detects temperature drops and interprets them as an open window
		// - external: An external window-open-sensor (chosen from the externalAvailableSensors) acts as a trigger for detecting open windows
		// - internal and external sensorMode are mutually exclusive
		// - internal is the default value
		// - Comet DECT and FRITZ!DECT 300 only support the `internal` sensorMode
		SensorMode *IFThermostatConfigWindowOpenModeSensorMode `json:"sensorMode,omitempty"`
	} `json:"windowOpenMode,omitempty"`
}

// IFThermostatConfigTemperatureOffsetSensorMode - internal: Manual configuration of temperature offset. The thermostat uses its internal temperature readings as a base.
// - external: An external temperature-sensor (chosen from the externalAvailableSensors) automatically detects the temperature offset.
// - internal and external sensorMode are mutually exclusive
// - internal is the default value
// - Comet DECT and FRITZ!DECT 300 only support the `internal` sensorMode
type IFThermostatConfigTemperatureOffsetSensorMode string

// IFThermostatConfigWindowOpenModeInternalSensitivity Sensitivity for automatically detecting temperature drops (e.g. open window) while the internal sensorMode is active.
type IFThermostatConfigWindowOpenModeInternalSensitivity string

// IFThermostatConfigWindowOpenModeSensorMode - internal: The thermostat automatically detects temperature drops and interprets them as an open window
// - external: An external window-open-sensor (chosen from the externalAvailableSensors) acts as a trigger for detecting open windows
// - internal and external sensorMode are mutually exclusive
// - internal is the default value
// - Comet DECT and FRITZ!DECT 300 only support the `internal` sensorMode
type IFThermostatConfigWindowOpenModeSensorMode string

// IFThermostatOverview defines model for IF_thermostat_overview.
type IFThermostatOverview struct {
	// Boost Boost special mode.
	Boost *HelperSpecialModeThermostat `json:"boost,omitempty"`

	// ComfortTemperature Comfort temperature preset used for timer of thermostat
	ComfortTemperature *HelperTemperature `json:"comfortTemperature,omitempty"`

	// IsAdaptiveRunning Adaptive heating period is active (up to an hour before the comfort temperature timer-configuration). Not available for Comet DECT and FRITZ!DECT 300.
	IsAdaptiveRunning *bool `json:"isAdaptiveRunning,omitempty"`

	// IsHolidayActive Holiday period is active (e.g. thermostat is in freeze protection mode)
	IsHolidayActive *bool `json:"isHolidayActive,omitempty"`

	// IsLockedDeviceApi Operation via API (App, UI, REST) of device is locked
	IsLockedDeviceApi *bool `json:"isLockedDeviceApi,omitempty"`

	// IsLockedDeviceLocal Local operation of device is locked
	IsLockedDeviceLocal *bool `json:"isLockedDeviceLocal,omitempty"`

	// IsSummertimeActive Summertime is active (e.g. thermostat is in freeze protection mode)
	IsSummertimeActive *bool             `json:"isSummertimeActive,omitempty"`
	NextChange         *HelperNextChange `json:"nextChange,omitempty"`

	// ReducedTemperature Reduced temperature preset used for timer of thermostat
	ReducedTemperature *HelperTemperature `json:"reducedTemperature,omitempty"`

	// SetPointTemperature Current setpoint temperature of thermostat
	SetPointTemperature  *HelperTemperature `json:"setPointTemperature,omitempty"`
	State                StateGenericState  `json:"state"`
	TemperatureRangeLock *struct {
		// IsTemperatureLock Temperature Range is locked
		IsTemperatureLock *bool `json:"isTemperatureLock,omitempty"`

		// Maximum Maximum temperature
		Maximum *HelperTemperature `json:"maximum,omitempty"`

		// Minimum Minimum temperature
		Minimum *HelperTemperature `json:"minimum,omitempty"`
	} `json:"temperatureRangeLock,omitempty"`
	ThermostatState *StateThermostatState `json:"thermostatState,omitempty"`

	// WindowOpenMode WindowOpen special mode.
	WindowOpenMode *HelperSpecialModeThermostat `json:"windowOpenMode,omitempty"`
}

// IFUnitInterfaces - functional interfaces for units
// - may be empty if no supported interface is present
type IFUnitInterfaces struct {
	AlertInterface        *IFAlertOverview        `json:"alertInterface,omitempty"`
	BlindInterface        *IFBlindOverview        `json:"blindInterface,omitempty"`
	ButtonInterface       *IFButtonOverview       `json:"buttonInterface,omitempty"`
	ColorControlInterface *IFColorControlOverview `json:"colorControlInterface,omitempty"`
	HumidityInterface     *IFHumidity             `json:"humidityInterface,omitempty"`
	LevelControlInterface *IFLevelControl         `json:"levelControlInterface,omitempty"`
	MultimeterInterface   *IFMultimeter           `json:"multimeterInterface,omitempty"`
	OnOffInterface        *IFOnOffOverview        `json:"onOffInterface,omitempty"`
	SmartmeterInterface   *IFSmartmeter           `json:"smartmeterInterface,omitempty"`
	TemperatureInterface  *IFTemperatureOverview  `json:"temperatureInterface,omitempty"`
	ThermostatInterface   *IFThermostatOverview   `json:"thermostatInterface,omitempty"`
}

// IFUnitInterfacesConfig - functional interfaces for units
// - may be empty if no supported interface is present
type IFUnitInterfacesConfig struct {
	AlertInterface        *IFAlertConfig        `json:"alertInterface,omitempty"`
	BlindInterface        *IFBlindConfig        `json:"blindInterface,omitempty"`
	ButtonInterface       *IFButtonConfig       `json:"buttonInterface,omitempty"`
	ColorControlInterface *IFColorControlConfig `json:"colorControlInterface,omitempty"`
	HumidityInterface     *IFHumidity           `json:"humidityInterface,omitempty"`
	LevelControlInterface *IFLevelControl       `json:"levelControlInterface,omitempty"`
	MultimeterInterface   *IFMultimeterConfig   `json:"multimeterInterface,omitempty"`
	OnOffInterface        *IFOnOffConfig        `json:"onOffInterface,omitempty"`
	SmartmeterInterface   *IFSmartmeter         `json:"smartmeterInterface,omitempty"`
	TemperatureInterface  *IFTemperatureConfig  `json:"temperatureInterface,omitempty"`
	ThermostatInterface   *IFThermostatConfig   `json:"thermostatInterface,omitempty"`
	WidgetInterface       *IFWidgetConfig       `json:"widgetInterface,omitempty"`
}

// IFWidgetConfig functional configuration interface for screen widgets (only available for the FRITZ!Smart Control 440)
type IFWidgetConfig struct {
	// AvailableWidgets - collection of available widgetModes and destinationUids for the unit
	// - configuring a specific widgetMode is only available if it appears here
	AvailableWidgets *struct {
		// BlindLevelUnitUids - list of UIDs of units to be controlled by following widgetMode: `blindLevel`
		BlindLevelUnitUids *[]string `json:"blindLevelUnitUids,omitempty"`

		// ColorUnitUids - list of UIDs of units to be controlled by following widgetModes: `hsColorPalette` & `colorTemperaturePalette`
		// - it is theoretically possible to configure the `hsColorPalette` for colorTemperature-only-Lamps
		// - this is because the supported color modes are only available for online bulbs
		// - after a reboot a once configured valid hsColor-lamp, would become 'invalid', hence there is no check
		ColorUnitUids *[]string `json:"colorUnitUids,omitempty"`

		// MainWifiBands - list of UIDs of main wifi band to be controlled by following widgetMode: `mainWifi`
		MainWifiBands *[]IFWidgetConfigAvailableWidgetsMainWifiBands `json:"mainWifiBands,omitempty"`

		// OnOffUnitUids - list of UIDs of units to be controlled by following widgetModes: `on`, `off`, `toggle` & `onOff`
		OnOffUnitUids *[]string `json:"onOffUnitUids,omitempty"`

		// TelephoneAnsweringMachineUids - list of UIDs of telephone answering machines to be controlled by following widgetMode: `tamControl`
		TelephoneAnsweringMachineUids *[]IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUids `json:"telephoneAnsweringMachineUids,omitempty"`

		// TemplateUids - list of UIDs of templates to be controlled by following widgetMode: `template`
		TemplateUids *[]string `json:"templateUids,omitempty"`

		// ThermostatFullUnitUids - list of UIDs of units to be controlled by following widgetModes: `thermostatFull`
		ThermostatFullUnitUids *[]string `json:"thermostatFullUnitUids,omitempty"`

		// ThermostatTemperatureUnitUids - list of UIDs of units to be controlled by following widgetMode: `thermostatTemperature`
		ThermostatTemperatureUnitUids *[]string `json:"thermostatTemperatureUnitUids,omitempty"`

		// TriggerUids - list of UIDs of triggers to be controlled by following widgetMode: `trigger`
		TriggerUids *[]string `json:"triggerUids,omitempty"`

		// WidgetModes depending on the firmware-version of the FSC!440, some widgets may not be available
		WidgetModes *[]HelperWidgetMode `json:"widgetModes,omitempty"`
	} `json:"availableWidgets,omitempty"`
	DefaultScreen *IFWidgetConfigDefaultScreen `json:"defaultScreen,omitempty"`

	// FirstScreenWidgets - screens allow for a collection of different widgets
	// - depending on the positioning of the widgets, up to 4 are allowed per screen
	FirstScreenWidgets *HelperScreenWidgets `json:"firstScreenWidgets,omitempty"`

	// SecondScreenWidgets - screens allow for a collection of different widgets
	// - depending on the positioning of the widgets, up to 4 are allowed per screen
	SecondScreenWidgets *HelperScreenWidgets `json:"secondScreenWidgets,omitempty"`

	// TemperatureChartEnabled whether an additional widget with a temperature and humidity chart of the last 24 hours should be displayed
	TemperatureChartEnabled *bool `json:"temperatureChartEnabled,omitempty"`

	// ThirdScreenWidgets - screens allow for a collection of different widgets
	// - depending on the positioning of the widgets, up to 4 are allowed per screen
	ThirdScreenWidgets *HelperScreenWidgets `json:"thirdScreenWidgets,omitempty"`
}

// IFWidgetConfigAvailableWidgetsMainWifiBands defines model for IFWidgetConfig.AvailableWidgets.MainWifiBands.
type IFWidgetConfigAvailableWidgetsMainWifiBands string

// IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUids unique identifier corresponding to telephone anwering machine
type IFWidgetConfigAvailableWidgetsTelephoneAnsweringMachineUids string

// IFWidgetConfigDefaultScreen defines model for IFWidgetConfig.DefaultScreen.
type IFWidgetConfigDefaultScreen string

// ActionColorTemperature Color temperature action (usually 2700..6500 Kelvin)
type ActionColorTemperature = int

// ActionGroupTemperature - group temperature action
// - provide an even amount of entries, the only exception to this is setting one entry which is set to "comfort" with time 0
// - setting only one entry, which is set to "reduced" is not allowed
type ActionGroupTemperature string

// ActionHsColor Hue-Saturation Color action
type ActionHsColor struct {
	Hue        int `json:"hue"`
	Saturation int `json:"saturation"`
}

// ActionLevel Level action
type ActionLevel = int

// ActionOnOff OnOff action
type ActionOnOff = bool

// ActionTemperature Helper object for getting/setting temperature on a thermostat
type ActionTemperature = HelperTemperature

// ActionTemperaturePreset - thermostat temperature preset action
// - the FRITZ!Smart thermostat supports 4 comfort und 4 reduced temperatures each day of the week
// - this allows for a maximum number of 56 items for thermostats
// - provide an even amount of entries, the only exception to this is setting one entry which is set to "comfort" with time 0
// - setting only one entry, which is set to "reduced" is not allowed
type ActionTemperaturePreset string

// AlertBase defines model for alert_base.
type AlertBase struct {
	// Alerts type of alert
	Alerts *[]AlertBase_Alerts_Item `json:"alerts,omitempty"`

	// LastAlertTime - timestamp of last alert
	// - only valid, if there was an event and host has valid time
	LastAlertTime *HelperTimestamp  `json:"lastAlertTime,omitempty"`
	State         StateGenericState `json:"state"`
}

// AlertBase_Alerts_Item defines model for alert_base.alerts.Item.
type AlertBase_Alerts_Item struct {
	union json.RawMessage
}

// BlindBase defines model for blind_base.
type BlindBase struct {
	// BlindAction When reading, this describes the last known state, which the blind send; when writing you can tell the blind to move into a certain (blind-specific) direction or to stop
	BlindAction *HelperBlindAction `json:"blindAction,omitempty"`
	BlindState  *StateBlindState   `json:"blindState,omitempty"`
	State       StateGenericState  `json:"state"`
}

// ButtonBase functional interface for a simple button sensor
type ButtonBase struct {
	// LastEventTime Timestamp of last button press. Only valid, if there was an event and host has valid time.
	LastEventTime *HelperTimestamp  `json:"lastEventTime,omitempty"`
	State         StateGenericState `json:"state"`
}

// ColorControlBase defines model for colorControl_base.
type ColorControlBase struct {
	ActiveHsColorPreset *HelperActiveHsColorPreset `json:"activeHsColorPreset,omitempty"`

	// ColorTemperature - "Kelvin (usually 2700..6500)"
	// - when setting the color on a unit with an onOffInterface, the onOff will not be modified automatically
	ColorTemperature *int           `json:"colorTemperature,omitempty"`
	HsColor          *HelperHsColor `json:"hsColor,omitempty"`
}

// ColorControlUnit defines model for colorControl_unit.
type ColorControlUnit struct {
	ActiveHsColorPreset *HelperActiveHsColorPreset `json:"activeHsColorPreset,omitempty"`

	// ColorTemperature - "Kelvin (usually 2700..6500)"
	// - when setting the color on a unit with an onOffInterface, the onOff will not be modified automatically
	ColorTemperature *int `json:"colorTemperature,omitempty"`

	// CurrentColorMode what color mode is currently active
	CurrentColorMode *ColorControlUnitCurrentColorMode `json:"currentColorMode,omitempty"`
	HsColor          *HelperHsColor                    `json:"hsColor,omitempty"`
	State            StateGenericState                 `json:"state"`

	// SupportedColorModes hueSaturation, temperature, unknown
	SupportedColorModes *[]ColorControlUnitSupportedColorModes `json:"supportedColorModes,omitempty"`
}

// ColorControlUnitCurrentColorMode what color mode is currently active
type ColorControlUnitCurrentColorMode string

// ColorControlUnitSupportedColorModes defines model for ColorControlUnit.SupportedColorModes.
type ColorControlUnitSupportedColorModes string

// CreateGroupResponse response for creating new group
type CreateGroupResponse struct {
	// UID UID of newly created group
	UID string `json:"UID"`
}

// CreateTemplateResponse response for creating new template
type CreateTemplateResponse struct {
	// UID UID of newly created template
	UID string `json:"UID"`
}

// DeviceBase defines model for device_base.
type DeviceBase struct {
	// UID unique identifier corresponding to ain of device
	UID string `json:"UID"`

	// Ain unique hardware identifier of device
	Ain string `json:"ain"`

	// BatteryState - 'known': the device sends infos about its batteryValue
	// - 'unknown': the device doesn't have a battery, or hasn't send its batteryValue yet (e.g. after reboot etc)
	BatteryState DeviceBaseBatteryState `json:"batteryState"`

	// BatteryValue Battery in 0..100 percent. Only available for battery-powered devices.
	BatteryValue *int `json:"batteryValue,omitempty"`

	// FirmwareVersion firmware version of device, may be empty
	FirmwareVersion string `json:"firmwareVersion"`

	// HardwareModelId product hardware model id
	HardwareModelId *string `json:"hardwareModelId,omitempty"`

	// Icons device can have multiple icons (for example for multiple units), can be empty
	Icons []int `json:"icons"`

	// IsBatteryLow - true: battery low warning from device
	// - false: battery ok (only available for FRITZ! thermostats and FRITZ! buttons)"
	IsBatteryLow *bool `json:"isBatteryLow,omitempty"`

	// IsBatteryPowered whether the device has batteries
	IsBatteryPowered *bool `json:"isBatteryPowered,omitempty"`

	// IsConnected - false: no connection / connection lose
	// - true: connection established
	// - when the device, and therefore its units, are not connected you may get the last known infos or default values; which might not be valid
	IsConnected bool `json:"isConnected"`

	// IsDeviceDeletable Whether the deletion of the device is supported. This is mostly relevant in mesh-setups, as it is not allowed to delete remotely subscribed devices from a client.
	IsDeviceDeletable *bool `json:"isDeviceDeletable,omitempty"`

	// IsDeviceSubscribedLocally - true: device is subscribed locally
	// - false: device is subscribed to other F!Box/Gateway in Mesh
	IsDeviceSubscribedLocally bool `json:"isDeviceSubscribedLocally"`

	// IsExternallyPowered whether the device has an external power source
	IsExternallyPowered *bool `json:"isExternallyPowered,omitempty"`

	// IsZigbeeDevice true if device uses zigbee-protocol to communicate
	IsZigbeeDevice bool `json:"isZigbeeDevice"`

	// LastConnectionTime - since when is the device in connection state (`isConnected`)
	// - only valid, if host has valid time
	LastConnectionTime *HelperTimestamp `json:"lastConnectionTime,omitempty"`

	// Manufacturer manufacturer of device, may be empty
	Manufacturer string `json:"manufacturer"`

	// Name user defined name of physical device, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name *string `json:"name,omitempty"`

	// ProductCategory describes the category, and therefore main feature, of the device
	ProductCategory DeviceBaseProductCategory `json:"productCategory"`

	// ProductName product name set by manufacturer
	ProductName string `json:"productName"`

	// RadioBaseSerial Serial (based on MAC-Address) of F!Box/Gateway on which the device is locally subscribed, can be other F!Box/Gateway in Mesh
	RadioBaseSerial *string `json:"radioBaseSerial,omitempty"`

	// UnitUids UIDs of units (children) belonging to physical device
	UnitUids []string `json:"unitUids"`
}

// DeviceBaseBatteryState - 'known': the device sends infos about its batteryValue
// - 'unknown': the device doesn't have a battery, or hasn't send its batteryValue yet (e.g. after reboot etc)
type DeviceBaseBatteryState string

// DeviceBaseProductCategory describes the category, and therefore main feature, of the device
type DeviceBaseProductCategory string

// EndpointConfigurationDevice defines model for endpoint_configuration_device.
type EndpointConfigurationDevice struct {
	// UID unique identifier corresponding to ain of device
	UID string `json:"UID"`

	// Ain unique hardware identifier of device
	Ain string `json:"ain"`

	// BatteryState - 'known': the device sends infos about its batteryValue
	// - 'unknown': the device doesn't have a battery, or hasn't send its batteryValue yet (e.g. after reboot etc)
	BatteryState EndpointConfigurationDeviceBatteryState `json:"batteryState"`

	// BatteryValue Battery in 0..100 percent. Only available for battery-powered devices.
	BatteryValue *int `json:"batteryValue,omitempty"`

	// FirmwareVersion firmware version of device, may be empty
	FirmwareVersion string `json:"firmwareVersion"`

	// HardwareModelId product hardware model id
	HardwareModelId *string `json:"hardwareModelId,omitempty"`

	// Icons device can have multiple icons (for example for multiple units), can be empty
	Icons []int `json:"icons"`

	// IsBatteryLow - true: battery low warning from device
	// - false: battery ok (only available for FRITZ! thermostats and FRITZ! buttons)"
	IsBatteryLow *bool `json:"isBatteryLow,omitempty"`

	// IsBatteryPowered whether the device has batteries
	IsBatteryPowered *bool `json:"isBatteryPowered,omitempty"`

	// IsConnected - false: no connection / connection lose
	// - true: connection established
	// - when the device, and therefore its units, are not connected you may get the last known infos or default values; which might not be valid
	IsConnected bool `json:"isConnected"`

	// IsDeviceDeletable Whether the deletion of the device is supported. This is mostly relevant in mesh-setups, as it is not allowed to delete remotely subscribed devices from a client.
	IsDeviceDeletable *bool `json:"isDeviceDeletable,omitempty"`

	// IsDeviceSubscribedLocally - true: device is subscribed locally
	// - false: device is subscribed to other F!Box/Gateway in Mesh
	IsDeviceSubscribedLocally bool `json:"isDeviceSubscribedLocally"`

	// IsExternallyPowered whether the device has an external power source
	IsExternallyPowered *bool `json:"isExternallyPowered,omitempty"`

	// IsZigbeeDevice true if device uses zigbee-protocol to communicate
	IsZigbeeDevice bool `json:"isZigbeeDevice"`

	// LastConnectionTime - since when is the device in connection state (`isConnected`)
	// - only valid, if host has valid time
	LastConnectionTime *HelperTimestamp `json:"lastConnectionTime,omitempty"`

	// Manufacturer manufacturer of device, may be empty
	Manufacturer string `json:"manufacturer"`

	// Name user defined name of physical device, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name string `json:"name"`

	// ProductCategory describes the category, and therefore main feature, of the device
	ProductCategory EndpointConfigurationDeviceProductCategory `json:"productCategory"`

	// ProductName product name set by manufacturer
	ProductName string         `json:"productName"`
	PushMail    HelperPushMail `json:"pushMail"`

	// RadioBaseSerial Serial (based on MAC-Address) of F!Box/Gateway on which the device is locally subscribed, can be other F!Box/Gateway in Mesh
	RadioBaseSerial *string `json:"radioBaseSerial,omitempty"`

	// UnitUids UIDs of units (children) belonging to physical device
	UnitUids []string `json:"unitUids"`

	// Units Detailed list of unit-configuration belonging to device
	Units []EndpointConfigurationUnit `json:"units"`
}

// EndpointConfigurationDeviceBatteryState - 'known': the device sends infos about its batteryValue
// - 'unknown': the device doesn't have a battery, or hasn't send its batteryValue yet (e.g. after reboot etc)
type EndpointConfigurationDeviceBatteryState string

// EndpointConfigurationDeviceProductCategory describes the category, and therefore main feature, of the device
type EndpointConfigurationDeviceProductCategory string

// EndpointConfigurationGetTemplate defines model for endpoint_configuration_getTemplate.
type EndpointConfigurationGetTemplate struct {
	// UID unique identifier corresponding to UID of template
	UID string `json:"UID"`

	// Ain unique identifier of template
	Ain       string            `json:"ain"`
	ApplyType TypeApplyTypeList `json:"applyType"`

	// AvailableDestinations contains lists of unit uids that are allowed to be added to the template
	AvailableDestinations *struct {
		BlindLevelUnitUids            *HelperAvailableTemplateBlindLevelUids                `json:"blindLevelUnitUids,omitempty"`
		ColorUnitUids                 *HelperAvailableTemplateColorUnitUids                 `json:"colorUnitUids,omitempty"`
		LampLevelUnitUids             *HelperAvailableTemplateLampLevelUids                 `json:"lampLevelUnitUids,omitempty"`
		OnOffUnitUids                 *HelperAvailableTemplateOnOffUids                     `json:"onOffUnitUids,omitempty"`
		TelephoneAnsweringMachineUids *HelperAvailableTemplateTelephoneAnsweringMachineUids `json:"telephoneAnsweringMachineUids,omitempty"`
		TemplateUids                  *HelperAvailableTemplateTemplateUids                  `json:"templateUids,omitempty"`
		ThermostatUnitUids            *HelperAvailableTemplateThermostatUids                `json:"thermostatUnitUids,omitempty"`
		TriggerUids                   *HelperAvailableTemplateTriggerUids                   `json:"triggerUids,omitempty"`
	} `json:"availableDestinations,omitempty"`

	// DelayTime - delay time in seconds
	// - if set, applying a template will not execute it immediately, but after configured time
	DelayTime *int `json:"delayTime,omitempty"`

	// Name user defined name of template, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name     string `json:"name"`
	Scenario *struct {
		// Icons list of icon-IDs, can be empty
		Icons []int `json:"icons"`

		// TemplateUids UIDs of assigned templates (if empty -> none assigned)
		TemplateUids []string `json:"templateUids"`

		// Type only available for preset-scenarios
		Type *TypeScenarioType `json:"type,omitempty"`
	} `json:"scenario,omitempty"`
	Template *struct {
		Interfaces    *IFTemplatesInterfaces      `json:"interfaces,omitempty"`
		IsAutoCreated HelperTemplateIsAutoCreated `json:"isAutoCreated"`
		MemberType    *HelperTemplateMemberType   `json:"memberType,omitempty"`

		// MemberUnitUids - UIDs of assigned member Units or Triggers
		// - if the list is empty -> no members assigned
		// - trigger templates *always* need at least one assigned trigger
		MemberUnitUids []string             `json:"memberUnitUids"`
		Timer          *HelperTemplateTimer `json:"timer,omitempty"`
	} `json:"template,omitempty"`
}

// EndpointConfigurationGetTemplateCapabilities groups extended template options
type EndpointConfigurationGetTemplateCapabilities struct {
	// ApplyTypes list of available applyTypes based on connected devices and current configuration of the F!Box/Gateway
	ApplyTypes         *TypeApplyTypeList                     `json:"applyTypes,omitempty"`
	BlindLevelUnitUids *HelperAvailableTemplateBlindLevelUids `json:"blindLevelUnitUids,omitempty"`
	ColorUnitUids      *HelperAvailableTemplateColorUnitUids  `json:"colorUnitUids,omitempty"`

	// Interfaces list of available interfaces based on connected devices and current configuration of the F!Box/Gateway
	Interfaces                    *[]EndpointConfigurationGetTemplateCapabilitiesInterfaces `json:"interfaces,omitempty"`
	LampLevelUnitUids             *HelperAvailableTemplateLampLevelUids                     `json:"lampLevelUnitUids,omitempty"`
	OnOffUnitUids                 *HelperAvailableTemplateOnOffUids                         `json:"onOffUnitUids,omitempty"`
	TelephoneAnsweringMachineUids *HelperAvailableTemplateTelephoneAnsweringMachineUids     `json:"telephoneAnsweringMachineUids,omitempty"`
	TemplateUids                  *HelperAvailableTemplateTemplateUids                      `json:"templateUids,omitempty"`
	ThermostatUnitUids            *HelperAvailableTemplateThermostatUids                    `json:"thermostatUnitUids,omitempty"`
	TriggerUids                   *HelperAvailableTemplateTriggerUids                       `json:"triggerUids,omitempty"`
}

// EndpointConfigurationGetTemplateCapabilitiesInterfaces defines model for EndpointConfigurationGetTemplateCapabilities.Interfaces.
type EndpointConfigurationGetTemplateCapabilitiesInterfaces string

// EndpointConfigurationGroup defines model for endpoint_configuration_group.
type EndpointConfigurationGroup struct {
	// UID unique identifier corresponding to ain of group
	UID string `json:"UID"`

	// Ain ain of group
	Ain string `json:"ain"`

	// AvailableOnOffUnits List of UIDs of possible units that can be configured as a onOffMasterUnit
	AvailableOnOffUnits *[]string `json:"availableOnOffUnits,omitempty"`

	// GroupCategory describes the category, and therefore main feature, of the group
	GroupCategory EndpointConfigurationGroupGroupCategory `json:"groupCategory"`

	// Icons device can have multiple icons (for example for multiple units), can be empty
	Icons []int `json:"icons"`

	// IsConnected - false: no connection / connection lost
	// - true: connection established to **at least one memberUnit**
	// - if the group is not connected you may get the last known infos or default values. These may not be valid.
	IsConnected *bool `json:"isConnected,omitempty"`

	// MemberUnitUids - Uids of member units in group
	// - always provide the complete list of memberUnits, otherwise they will be deleted from the group
	// - a unit is only allowed to be in on group at a time
	// - adding a unit, that is already a member of another group, will delete it from the old group
	MemberUnitUids []string `json:"memberUnitUids"`

	// Name user defined name of group, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name           string                    `json:"name"`
	OnOffMasterUid *HelperOnOffMasterUnitUid `json:"onOffMasterUid,omitempty"`

	// Unit Detailed unit-configuration belonging to group
	Unit *EndpointConfigurationUnit `json:"unit,omitempty"`

	// UnitUid Uid of Unit(child) belonging to this group
	UnitUid *string `json:"unitUid,omitempty"`
}

// EndpointConfigurationGroupGroupCategory describes the category, and therefore main feature, of the group
type EndpointConfigurationGroupGroupCategory string

// EndpointConfigurationPostGroup defines model for endpoint_configuration_postGroup.
type EndpointConfigurationPostGroup struct {
	// UID unique identifier corresponding to ain of group
	UID string `json:"UID"`

	// Ain ain of group
	Ain string `json:"ain"`

	// GroupCategory describes the category, and therefore main feature, of the group
	GroupCategory EndpointConfigurationPostGroupGroupCategory `json:"groupCategory"`

	// Icons device can have multiple icons (for example for multiple units), can be empty
	Icons []int `json:"icons"`

	// IsConnected - false: no connection / connection lost
	// - true: connection established to **at least one memberUnit**
	// - if the group is not connected you may get the last known infos or default values. These may not be valid.
	IsConnected *bool `json:"isConnected,omitempty"`

	// MemberUnitUids - Uids of member units in group
	// - always provide the complete list of memberUnits, otherwise they will be deleted from the group
	// - a unit is only allowed to be in on group at a time
	// - adding a unit, that is already a member of another group, will delete it from the old group
	MemberUnitUids []string `json:"memberUnitUids"`

	// Name user defined name of group, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name string `json:"name"`

	// UnitUid Uid of Unit(child) belonging to this group
	UnitUid *string `json:"unitUid,omitempty"`
}

// EndpointConfigurationPostGroupGroupCategory describes the category, and therefore main feature, of the group
type EndpointConfigurationPostGroupGroupCategory string

// EndpointConfigurationPostTemplate defines model for endpoint_configuration_postTemplate.
type EndpointConfigurationPostTemplate struct {
	// UID unique identifier corresponding to UID of template
	UID *string `json:"UID,omitempty"`

	// Ain unique identifier of template
	Ain       *string            `json:"ain,omitempty"`
	ApplyType *TypeApplyTypeList `json:"applyType,omitempty"`

	// AvailableDestinations contains lists of unit uids that are allowed to be added to the template
	AvailableDestinations *struct {
		BlindLevelUnitUids            *HelperAvailableTemplateBlindLevelUids                `json:"blindLevelUnitUids,omitempty"`
		ColorUnitUids                 *HelperAvailableTemplateColorUnitUids                 `json:"colorUnitUids,omitempty"`
		LampLevelUnitUids             *HelperAvailableTemplateLampLevelUids                 `json:"lampLevelUnitUids,omitempty"`
		OnOffUnitUids                 *HelperAvailableTemplateOnOffUids                     `json:"onOffUnitUids,omitempty"`
		TelephoneAnsweringMachineUids *HelperAvailableTemplateTelephoneAnsweringMachineUids `json:"telephoneAnsweringMachineUids,omitempty"`
		TemplateUids                  *HelperAvailableTemplateTemplateUids                  `json:"templateUids,omitempty"`
		ThermostatUnitUids            *HelperAvailableTemplateThermostatUids                `json:"thermostatUnitUids,omitempty"`
		TriggerUids                   *HelperAvailableTemplateTriggerUids                   `json:"triggerUids,omitempty"`
	} `json:"availableDestinations,omitempty"`

	// DelayTime - delay time in seconds
	// - if set, applying a template will not execute it immediately, but after configured time
	DelayTime *int `json:"delayTime,omitempty"`

	// Name user defined name of template, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name     string `json:"name"`
	Scenario *struct {
		// Icons list of icon-IDs, can be empty
		Icons *[]int `json:"icons,omitempty"`

		// TemplateUids UIDs of assigned templates (if empty -> none assigned)
		TemplateUids []string `json:"templateUids"`

		// Type only available for preset-scenarios
		Type *TypeScenarioType `json:"type,omitempty"`
	} `json:"scenario,omitempty"`
	Template *struct {
		Interfaces    *IFTemplatesInterfaces       `json:"interfaces,omitempty"`
		IsAutoCreated *HelperTemplateIsAutoCreated `json:"isAutoCreated,omitempty"`
		MemberType    HelperTemplateMemberType     `json:"memberType"`

		// MemberUnitUids - UIDs of assigned member Units or Triggers
		// - if the list is empty -> no members assigned
		// - trigger templates *always* need at least one assigned trigger
		MemberUnitUids []string             `json:"memberUnitUids"`
		Timer          *HelperTemplateTimer `json:"timer,omitempty"`
	} `json:"template,omitempty"`
}

// EndpointConfigurationPutDevice defines model for endpoint_configuration_putDevice.
type EndpointConfigurationPutDevice struct {
	// UID unique identifier corresponding to ain of device
	UID string `json:"UID"`

	// Ain unique hardware identifier of device
	Ain string `json:"ain"`

	// BatteryState - 'known': the device sends infos about its batteryValue
	// - 'unknown': the device doesn't have a battery, or hasn't send its batteryValue yet (e.g. after reboot etc)
	BatteryState EndpointConfigurationPutDeviceBatteryState `json:"batteryState"`

	// BatteryValue Battery in 0..100 percent. Only available for battery-powered devices.
	BatteryValue *int `json:"batteryValue,omitempty"`

	// FirmwareVersion firmware version of device, may be empty
	FirmwareVersion string `json:"firmwareVersion"`

	// HardwareModelId product hardware model id
	HardwareModelId *string `json:"hardwareModelId,omitempty"`

	// Icons device can have multiple icons (for example for multiple units), can be empty
	Icons []int `json:"icons"`

	// IsBatteryLow - true: battery low warning from device
	// - false: battery ok (only available for FRITZ! thermostats and FRITZ! buttons)"
	IsBatteryLow *bool `json:"isBatteryLow,omitempty"`

	// IsBatteryPowered whether the device has batteries
	IsBatteryPowered *bool `json:"isBatteryPowered,omitempty"`

	// IsConnected - false: no connection / connection lose
	// - true: connection established
	// - when the device, and therefore its units, are not connected you may get the last known infos or default values; which might not be valid
	IsConnected bool `json:"isConnected"`

	// IsDeviceDeletable Whether the deletion of the device is supported. This is mostly relevant in mesh-setups, as it is not allowed to delete remotely subscribed devices from a client.
	IsDeviceDeletable *bool `json:"isDeviceDeletable,omitempty"`

	// IsDeviceSubscribedLocally - true: device is subscribed locally
	// - false: device is subscribed to other F!Box/Gateway in Mesh
	IsDeviceSubscribedLocally bool `json:"isDeviceSubscribedLocally"`

	// IsExternallyPowered whether the device has an external power source
	IsExternallyPowered *bool `json:"isExternallyPowered,omitempty"`

	// IsZigbeeDevice true if device uses zigbee-protocol to communicate
	IsZigbeeDevice bool `json:"isZigbeeDevice"`

	// LastConnectionTime - since when is the device in connection state (`isConnected`)
	// - only valid, if host has valid time
	LastConnectionTime *HelperTimestamp `json:"lastConnectionTime,omitempty"`

	// Manufacturer manufacturer of device, may be empty
	Manufacturer string `json:"manufacturer"`

	// Name user defined name of physical device, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name *string `json:"name,omitempty"`

	// ProductCategory describes the category, and therefore main feature, of the device
	ProductCategory EndpointConfigurationPutDeviceProductCategory `json:"productCategory"`

	// ProductName product name set by manufacturer
	ProductName string          `json:"productName"`
	PushMail    *HelperPushMail `json:"pushMail,omitempty"`

	// RadioBaseSerial Serial (based on MAC-Address) of F!Box/Gateway on which the device is locally subscribed, can be other F!Box/Gateway in Mesh
	RadioBaseSerial *string `json:"radioBaseSerial,omitempty"`

	// UnitUids UIDs of units (children) belonging to physical device
	UnitUids []string `json:"unitUids"`
}

// EndpointConfigurationPutDeviceBatteryState - 'known': the device sends infos about its batteryValue
// - 'unknown': the device doesn't have a battery, or hasn't send its batteryValue yet (e.g. after reboot etc)
type EndpointConfigurationPutDeviceBatteryState string

// EndpointConfigurationPutDeviceProductCategory describes the category, and therefore main feature, of the device
type EndpointConfigurationPutDeviceProductCategory string

// EndpointConfigurationPutGroup defines model for endpoint_configuration_putGroup.
type EndpointConfigurationPutGroup struct {
	// UID unique identifier corresponding to ain of group
	UID string `json:"UID"`

	// Ain ain of group
	Ain string `json:"ain"`

	// GroupCategory describes the category, and therefore main feature, of the group
	GroupCategory EndpointConfigurationPutGroupGroupCategory `json:"groupCategory"`

	// Icons device can have multiple icons (for example for multiple units), can be empty
	Icons []int `json:"icons"`

	// IsConnected - false: no connection / connection lost
	// - true: connection established to **at least one memberUnit**
	// - if the group is not connected you may get the last known infos or default values. These may not be valid.
	IsConnected *bool `json:"isConnected,omitempty"`

	// MemberUnitUids - Uids of member units in group
	// - always provide the complete list of memberUnits, otherwise they will be deleted from the group
	// - a unit is only allowed to be in on group at a time
	// - adding a unit, that is already a member of another group, will delete it from the old group
	MemberUnitUids *[]string `json:"memberUnitUids,omitempty"`

	// Name user defined name of group, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name               *string                   `json:"name,omitempty"`
	OnOffMasterUnitUid *HelperOnOffMasterUnitUid `json:"onOffMasterUnitUid,omitempty"`

	// UnitUid Uid of Unit(child) belonging to this group
	UnitUid *string `json:"unitUid,omitempty"`
}

// EndpointConfigurationPutGroupGroupCategory describes the category, and therefore main feature, of the group
type EndpointConfigurationPutGroupGroupCategory string

// EndpointConfigurationPutTemplate defines model for endpoint_configuration_putTemplate.
type EndpointConfigurationPutTemplate struct {
	// UID unique identifier corresponding to UID of template
	UID string `json:"UID"`

	// Ain unique identifier of template
	Ain       *string            `json:"ain,omitempty"`
	ApplyType *TypeApplyTypeList `json:"applyType,omitempty"`

	// AvailableDestinations contains lists of unit uids that are allowed to be added to the template
	AvailableDestinations *struct {
		BlindLevelUnitUids            *HelperAvailableTemplateBlindLevelUids                `json:"blindLevelUnitUids,omitempty"`
		ColorUnitUids                 *HelperAvailableTemplateColorUnitUids                 `json:"colorUnitUids,omitempty"`
		LampLevelUnitUids             *HelperAvailableTemplateLampLevelUids                 `json:"lampLevelUnitUids,omitempty"`
		OnOffUnitUids                 *HelperAvailableTemplateOnOffUids                     `json:"onOffUnitUids,omitempty"`
		TelephoneAnsweringMachineUids *HelperAvailableTemplateTelephoneAnsweringMachineUids `json:"telephoneAnsweringMachineUids,omitempty"`
		TemplateUids                  *HelperAvailableTemplateTemplateUids                  `json:"templateUids,omitempty"`
		ThermostatUnitUids            *HelperAvailableTemplateThermostatUids                `json:"thermostatUnitUids,omitempty"`
		TriggerUids                   *HelperAvailableTemplateTriggerUids                   `json:"triggerUids,omitempty"`
	} `json:"availableDestinations,omitempty"`

	// DelayTime - delay time in seconds
	// - if set, applying a template will not execute it immediately, but after configured time
	DelayTime *int `json:"delayTime,omitempty"`

	// Name user defined name of template, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name     *string         `json:"name,omitempty"`
	Scenario *HelperScenario `json:"scenario,omitempty"`
	Template *struct {
		Interfaces *IFTemplatesInterfaces `json:"interfaces,omitempty"`

		// MemberUnitUids - UIDs of assigned member Units or Triggers
		// - if the list is empty -> no members assigned
		// - trigger templates *always* need at least one assigned trigger
		MemberUnitUids *[]string            `json:"memberUnitUids,omitempty"`
		Timer          *HelperTemplateTimer `json:"timer,omitempty"`
	} `json:"template,omitempty"`
}

// EndpointConfigurationPutUnit defines model for endpoint_configuration_putUnit.
type EndpointConfigurationPutUnit struct {
	// UID unique identifier corresponding to ain of unit
	UID *string `json:"UID,omitempty"`

	// Ain unique hardware identifier of unit
	Ain *string `json:"ain,omitempty"`

	// DeviceUid UID of parent Device; if not present: parent is group
	DeviceUid *string `json:"deviceUid,omitempty"`

	// GroupUid - UID of group, if unit is member in a group
	// - if not present the unit has a group as a parent
	// - if present, but not set, the unit is not in a group
	GroupUid *string `json:"groupUid,omitempty"`

	// Icons icon-IDs from Iconlist (TBD), can be empty
	Icons      *[]int                  `json:"icons,omitempty"`
	Interfaces *IFUnitInterfacesConfig `json:"interfaces,omitempty"`

	// IsConnected - false: no connection / connection lost
	// - true: connection established
	// - if the device (and therefore its units) are not connected you may get the last known infos or default values. These may not be valid.
	// - for groupUnits (`isGroupUnit` == true) `isConnected` will be true, if at least one memberUnit of the Group is connected
	IsConnected *bool `json:"isConnected,omitempty"`

	// IsGroupUnit - false: parent is device
	// - true: parent is group
	IsGroupUnit *bool `json:"isGroupUnit,omitempty"`

	// Name user defined name of funcitonal Unit, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed (may be automatically set through the device name if only 1 unit exists)
	Name *UnitNameConfiguration `json:"name,omitempty"`

	// ParentUid UID of parent device or group
	ParentUid *string          `json:"parentUid,omitempty"`
	Timer     *HelperUnitTimer `json:"timer,omitempty"`
	UnitType  *TypeUnitType    `json:"unitType,omitempty"`
}

// EndpointConfigurationUnit defines model for endpoint_configuration_unit.
type EndpointConfigurationUnit struct {
	// UID unique identifier corresponding to ain of unit
	UID string `json:"UID"`

	// Ain unique hardware identifier of unit
	Ain string `json:"ain"`

	// DeviceUid UID of parent Device; if not present: parent is group
	DeviceUid *string `json:"deviceUid,omitempty"`

	// GroupUid - UID of group, if unit is member in a group
	// - if not present the unit has a group as a parent
	// - if present, but not set, the unit is not in a group
	GroupUid *string `json:"groupUid,omitempty"`

	// Icons icon-IDs from Iconlist (TBD), can be empty
	Icons      []int                  `json:"icons"`
	Interfaces IFUnitInterfacesConfig `json:"interfaces"`

	// IsConnected - false: no connection / connection lost
	// - true: connection established
	// - if the device (and therefore its units) are not connected you may get the last known infos or default values. These may not be valid.
	// - for groupUnits (`isGroupUnit` == true) `isConnected` will be true, if at least one memberUnit of the Group is connected
	IsConnected bool `json:"isConnected"`

	// IsGroupUnit - false: parent is device
	// - true: parent is group
	IsGroupUnit bool `json:"isGroupUnit"`

	// Name user defined name of funcitonal Unit, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed (may be automatically set through the device name if only 1 unit exists)
	Name UnitNameConfiguration `json:"name"`

	// ParentUid UID of parent device or group
	ParentUid  string                `json:"parentUid"`
	Statistics *HelperStatisticsUnit `json:"statistics,omitempty"`
	Timer      *HelperUnitTimer      `json:"timer,omitempty"`
	UnitType   TypeUnitType          `json:"unitType"`
}

// EndpointInstallCode groups zigbee install code infos
type EndpointInstallCode struct {
	// DeviceAddress The Zigbee device address needed for using the install code.
	DeviceAddress string `json:"deviceAddress"`

	// InstallCode The device-specific Zigbee installation code allows for a secure pairing of Zigbee devices to the radioBase.
	InstallCode string `json:"installCode"`

	// Serial serial (based on MAC-address) of zigbee radioBase to post install code on
	Serial string `json:"serial"`
}

// EndpointOverview object for devices, groups, template und triggers info
type EndpointOverview struct {
	// Devices list of devices
	Devices []EndpointOverviewMultipleDevices `json:"devices"`

	// Globals smart home globals
	Globals HelperOverviewGlobals `json:"globals"`

	// Groups list of groups
	Groups []EndpointOverviewGroup `json:"groups"`

	// Templates list of templates
	Templates []EndpointOverviewGetTemplate `json:"templates"`

	// Triggers list of triggers
	Triggers []EndpointOverviewTrigger `json:"triggers"`

	// Units list of functionUnits
	Units []EndpointOverviewMultipleUnits `json:"units"`
}

// EndpointOverviewGetTemplate defines model for endpoint_overview_getTemplate.
type EndpointOverviewGetTemplate struct {
	// UID unique identifier corresponding to UID of template
	UID string `json:"UID"`

	// Ain unique identifier of template
	Ain       string            `json:"ain"`
	ApplyType TypeApplyTypeList `json:"applyType"`

	// Name user defined name of template, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name     string `json:"name"`
	Scenario *struct {
		// Icons list of icon-IDs, can be empty
		Icons []int `json:"icons"`

		// TemplateUids UIDs of assigned templates (if empty -> none assigned)
		TemplateUids []string `json:"templateUids"`

		// Type only available for preset-scenarios
		Type *TypeScenarioType `json:"type,omitempty"`
	} `json:"scenario,omitempty"`
	Template *struct {
		IsAutoCreated HelperTemplateIsAutoCreated `json:"isAutoCreated"`
		MemberType    *HelperTemplateMemberType   `json:"memberType,omitempty"`

		// MemberUnitUids - UIDs of assigned member Units or Triggers
		// - if the list is empty -> no members assigned
		// - trigger templates *always* need at least one assigned trigger
		MemberUnitUids []string `json:"memberUnitUids"`
	} `json:"template,omitempty"`
}

// EndpointOverviewGroup defines model for endpoint_overview_group.
type EndpointOverviewGroup = GroupBase

// EndpointOverviewMultipleDevices groups basic overview infos of device
type EndpointOverviewMultipleDevices = HelperOverviewDevice

// EndpointOverviewMultipleUnits groups basic functionUnit info
type EndpointOverviewMultipleUnits = HelperOverviewUnit

// EndpointOverviewPostTemplate groups basic template info (including templates for units and scenarios)
type EndpointOverviewPostTemplate struct {
	// TriggerEvent trigger/apply the template
	TriggerEvent *bool `json:"triggerEvent,omitempty"`
}

// EndpointOverviewPutUnit defines model for endpoint_overview_putUnit.
type EndpointOverviewPutUnit struct {
	// UID unique identifier corresponding to ain of unit
	UID *string `json:"UID,omitempty"`

	// Ain unique hardware identifier of unit
	Ain *string `json:"ain,omitempty"`

	// DeviceUid UID of parent Device; if not present: parent is group
	DeviceUid *string `json:"deviceUid,omitempty"`

	// GroupUid - UID of group, if unit is member in a group
	// - if not present the unit has a group as a parent
	// - if present, but not set, the unit is not in a group
	GroupUid *string `json:"groupUid,omitempty"`

	// Icons icon-IDs from Iconlist (TBD), can be empty
	Icons      *[]int              `json:"icons,omitempty"`
	Interfaces IFPutUnitInterfaces `json:"interfaces"`

	// IsConnected - false: no connection / connection lost
	// - true: connection established
	// - if the device (and therefore its units) are not connected you may get the last known infos or default values. These may not be valid.
	// - for groupUnits (`isGroupUnit` == true) `isConnected` will be true, if at least one memberUnit of the Group is connected
	IsConnected *bool `json:"isConnected,omitempty"`

	// IsGroupUnit - false: parent is device
	// - true: parent is group
	IsGroupUnit *bool `json:"isGroupUnit,omitempty"`

	// ParentUid UID of parent device or group
	ParentUid *string       `json:"parentUid,omitempty"`
	UnitType  *TypeUnitType `json:"unitType,omitempty"`
}

// EndpointOverviewSingleDevice groups basic overview infos of device
type EndpointOverviewSingleDevice = HelperOverviewDevice

// EndpointOverviewSingleUnit defines model for endpoint_overview_singleUnit.
type EndpointOverviewSingleUnit struct {
	// UID unique identifier corresponding to ain of unit
	UID string `json:"UID"`

	// Ain unique hardware identifier of unit
	Ain string `json:"ain"`

	// DeviceUid UID of parent Device; if not present: parent is group
	DeviceUid *string `json:"deviceUid,omitempty"`

	// GroupUid - UID of group, if unit is member in a group
	// - if not present the unit has a group as a parent
	// - if present, but not set, the unit is not in a group
	GroupUid *string `json:"groupUid,omitempty"`

	// Icons icon-IDs from Iconlist (TBD), can be empty
	Icons      []int            `json:"icons"`
	Interfaces IFUnitInterfaces `json:"interfaces"`

	// IsConnected - false: no connection / connection lost
	// - true: connection established
	// - if the device (and therefore its units) are not connected you may get the last known infos or default values. These may not be valid.
	// - for groupUnits (`isGroupUnit` == true) `isConnected` will be true, if at least one memberUnit of the Group is connected
	IsConnected *bool `json:"isConnected,omitempty"`

	// IsGroupUnit - false: parent is device
	// - true: parent is group
	IsGroupUnit bool `json:"isGroupUnit"`

	// Name user defined name of funcitonal Unit, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed (may be automatically set through the device name if only 1 unit exists)
	Name UnitNameOverview `json:"name"`

	// ParentUid UID of parent device or group
	ParentUid  string                `json:"parentUid"`
	Statistics *HelperStatisticsUnit `json:"statistics,omitempty"`
	Timer      *HelperUnitTimer      `json:"timer,omitempty"`
	UnitType   TypeUnitType          `json:"unitType"`
}

// EndpointOverviewTrigger defines model for endpoint_overview_trigger.
type EndpointOverviewTrigger struct {
	// UID unique identifier corresponding to ain of trigger
	UID string `json:"UID"`

	// Ain unique identifier of trigger
	Ain string `json:"ain"`

	// Enabled is the trigger activated
	Enabled bool `json:"enabled"`

	// Name user defined name of trigger, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name string `json:"name"`
}

// EndpointRadioBases groups radioBase infos
type EndpointRadioBases struct {
	// ActiveSubscriptionUid - UID of active subscription on radioBase
	// - empty if no active subscription
	ActiveSubscriptionUid *string `json:"activeSubscriptionUid,omitempty"`

	// IsDectAvailable is subscription via DECT available on radioBase
	IsDectAvailable bool `json:"isDectAvailable"`

	// IsSmarthomeMaster - whether the radioBase is configured as the master in the smart home mesh
	// - if yes, this allows for starting subscriptions and deleting devices on remote radioBases
	// - if no, only a local subscription and deletion is available
	IsSmarthomeMaster bool `json:"isSmarthomeMaster"`

	// IsZigbeeAvailable is subscription via Zigbee available on radioBase
	IsZigbeeAvailable bool `json:"isZigbeeAvailable"`

	// Serial serial (based on MAC-address) of smart home radioBase
	Serial string `json:"serial"`
}

// EndpointResetCode groups zigbee reset code infos
type EndpointResetCode struct {
	// ResetCode The device-specific Zigbee reset code will unpair a device from it's gateway/radioBase. This is independent of the manufacturer of the gateway/radioBase.
	ResetCode string `json:"resetCode"`

	// Serial serial (based on MAC-address) of zigbee radioBase to post reset code on
	Serial string `json:"serial"`
}

// EndpointStartSubscription groups start subscription infos
type EndpointStartSubscription struct {
	// Serial serial (based on the MAC-Address) of smart home radioBase to start subscription on
	Serial *string `json:"serial,omitempty"`

	// TriggerDect - start DECT subscription on radioBase
	// - if not provided, default is true
	TriggerDect *bool `json:"triggerDect,omitempty"`

	// TriggerResubscription - for DECT devices only
	// - allows for renewal of subscription of already known DECT devices
	// - if not provided, default is false
	TriggerResubscription *bool `json:"triggerResubscription,omitempty"`

	// TriggerZigbee - start Zigbee subscription on radioBase
	// - if not provided, default is true
	TriggerZigbee *bool `json:"triggerZigbee,omitempty"`
}

// EndpointSubscriptionState groups subscription state infos
type EndpointSubscriptionState struct {
	// UID UID of subscription to return
	UID string `json:"UID"`

	// DeviceUid - if subscription was successful, contains UID of newly subscribed device
	// - otherwise empty
	DeviceUid *string `json:"deviceUid,omitempty"`

	// State state of subscription
	State EndpointSubscriptionStateState `json:"state"`

	// Time unix timestamp of last update of state
	Time *int `json:"time"`
}

// EndpointSubscriptionStateState state of subscription
type EndpointSubscriptionStateState string

// ErrorList list of F!OS errors
type ErrorList = []struct {
	// Code property-based-fails:
	//
	// | Code | Description            |
	// | ---- | -----------            |
	// | 1000 | bad value (PUT/POST)   |
	// | 1001 | wrong type             |
	// | 1002 | out of range           |
	// | 1003 | too short              |
	// | 1004 | too long               |
	// | 1005 | invalid characters     |
	// | 1006 | wrong lead character   |
	// | 1007 | wrong end character    |
	// | 1008 | invalid format         |
	// | 1009 | missing data / payload |
	//
	// collection-based-fails:
	//
	// | Code | Description                 |
	// | ---- | -----------                 |
	// | 2000 | invalid collection handling |
	// | 2001 | UID not found               |
	// | 2002 | list/collection full        |
	// | 2003 | list empty                  |
	// | 2004 | item not valid              |
	// | 2005 | not deletable               |
	// | 2006 | already exists              |
	// | 2007 | item conflict               |
	//
	// permissions/functionality-based-fails:
	//
	// | Code  | Description |
	// | ----- | -----------                       |
	// | 3000  | permissions/functionality         |
	// | 3001  | no permission / not enough rights |
	// | 3002  | bad path                          |
	// | 3003  | bad payload                       |
	// | 3004  | bad key                           |
	// | 3005  | not supported                     |
	// | 3006  | busy                              |
	// | 3007  | not active                        |
	// | 3008  | 2fa needed                        |
	// | 3009  | 2fa busy                          |
	// | 3010  | 2fa blocked                       |
	// | 3011  | not supported version             |
	//
	// other errors
	//
	// | Code   | Description                      |
	// | ------ | -----------                      |
	// | 4000   | unexpected internal error        |
	// | 10000+ | special-purpose error codes      |
	Code int `json:"code"`

	// Extension extended error information, if available
	Extension *map[string]interface{} `json:"extension,omitempty"`

	// Field path of attribute, which causes the error. Mandatory in case of property-based-fails codes
	Field *string `json:"field,omitempty"`

	// Message human readable error description (optional)
	Message *string `json:"message,omitempty"`
}

// ErrorResponse defines model for error_response.
type ErrorResponse struct {
	// Errors list of F!OS errors
	Errors *ErrorList `json:"errors,omitempty"`
}

// GroupBase defines model for group_base.
type GroupBase struct {
	// UID unique identifier corresponding to ain of group
	UID string `json:"UID"`

	// Ain ain of group
	Ain string `json:"ain"`

	// GroupCategory describes the category, and therefore main feature, of the group
	GroupCategory GroupBaseGroupCategory `json:"groupCategory"`

	// Icons device can have multiple icons (for example for multiple units), can be empty
	Icons []int `json:"icons"`

	// IsConnected - false: no connection / connection lost
	// - true: connection established to **at least one memberUnit**
	// - if the group is not connected you may get the last known infos or default values. These may not be valid.
	IsConnected *bool `json:"isConnected,omitempty"`

	// MemberUnitUids - Uids of member units in group
	// - always provide the complete list of memberUnits, otherwise they will be deleted from the group
	// - a unit is only allowed to be in on group at a time
	// - adding a unit, that is already a member of another group, will delete it from the old group
	MemberUnitUids *[]string `json:"memberUnitUids,omitempty"`

	// Name user defined name of group, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name *string `json:"name,omitempty"`

	// UnitUid Uid of Unit(child) belonging to this group
	UnitUid *string `json:"unitUid,omitempty"`
}

// GroupBaseGroupCategory describes the category, and therefore main feature, of the group
type GroupBaseGroupCategory string

// HelperActiveHsColorPreset defines model for helper_activeHsColorPreset.
type HelperActiveHsColorPreset = HelperHsColorPaletteItem

// HelperActivePeriod - allows for enabling the feature in a certain period
// - time per day allows for further restrictions
// - the feature will only be active during the specified time of day
// - when setting startTime, endTime needs to be set too (and vice versa)
// - when setting startTimePerDay, endTimePerDay needs to be set too (and vice versa)
// - by not setting the startDate & endDate only the daily restriction will be active
// - by not setting the startTimePerDay & endTimePerDay, or setting them to the same value, only the date restriction will be active
type HelperActivePeriod struct {
	// EndDate - end of active period
	// - unix timestamp
	// - only day, month and year are relevant
	EndDate *int `json:"endDate,omitempty"`

	// EndTimePerDay - minutes since beginning of day (00:00)
	// - if startTimePerDay & endTimePerDay are set to the same value, activePeriod will be enabled all day
	// - for wrapping into a new day set endTimePerDay < startTimePerDay
	EndTimePerDay *int `json:"endTimePerDay,omitempty"`

	// StartDate - start of active period
	// - unix timestamp
	// - only day, month and year are relevant
	StartDate *int `json:"startDate,omitempty"`

	// StartTimePerDay - minutes since beginning of day (00:00)
	// - if startTimePerDay & endTimePerDay are set to the same value, activePeriod will be enabled all day
	// - for wrapping into a new day set startTimePerDay > endTimePerDay
	StartTimePerDay *int `json:"startTimePerDay,omitempty"`
}

// HelperActivePeriodAlertButton button presses/sensor events will only be registered in the configured period
type HelperActivePeriodAlertButton struct {
	// AstronomicActivePeriod - astronomical timer based on geographical position
	// - active period can be controlled based on sunrise and sunset
	AstronomicActivePeriod *HelperBaseTimerAstronomic `json:"astronomicActivePeriod,omitempty"`
	FixedActivePeriod      *struct {
		// EndDate - end of active period
		// - unix timestamp
		// - only day, month and year are relevant
		EndDate *int `json:"endDate,omitempty"`

		// EndTimePerDay - minutes since beginning of day (00:00)
		// - if startTimePerDay & endTimePerDay are set to the same value, activePeriod will be enabled all day
		// - for wrapping into a new day set endTimePerDay < startTimePerDay
		EndTimePerDay *int `json:"endTimePerDay,omitempty"`

		// StartDate - start of active period
		// - unix timestamp
		// - only day, month and year are relevant
		StartDate *int `json:"startDate,omitempty"`

		// StartTimePerDay - minutes since beginning of day (00:00)
		// - if startTimePerDay & endTimePerDay are set to the same value, activePeriod will be enabled all day
		// - for wrapping into a new day set startTimePerDay > endTimePerDay
		StartTimePerDay *int `json:"startTimePerDay,omitempty"`
	} `json:"fixedActivePeriod,omitempty"`

	// Mode - select activePeriod mode
	// - `permanent`: button/sensor will always be active
	// - `fixed`: button/sensor will only be active during the configured time period
	// - `astronomic`: button/sensor will only be active realtive to the configured astronomical time periods
	// - when choosing `fixed` mode, the `fixedActivePeriod` needs to have a valid configuration
	// - when choosing `astronomic` mode, the `astronomicActivePeriod` needs to have a valid configuration
	Mode *HelperActivePeriodAlertButtonMode `json:"mode,omitempty"`
}

// HelperActivePeriodAlertButtonMode - select activePeriod mode
// - `permanent`: button/sensor will always be active
// - `fixed`: button/sensor will only be active during the configured time period
// - `astronomic`: button/sensor will only be active realtive to the configured astronomical time periods
// - when choosing `fixed` mode, the `fixedActivePeriod` needs to have a valid configuration
// - when choosing `astronomic` mode, the `astronomicActivePeriod` needs to have a valid configuration
type HelperActivePeriodAlertButtonMode string

// HelperAstronomicLocation Helper Object for the astronomic timer location
type HelperAstronomicLocation struct {
	// Latitude latitude used for calculating sunrise/-fall
	Latitude *float32 `json:"latitude,omitempty"`

	// Longitude longitude used for calculating sunrise/-fall
	Longitude *float32 `json:"longitude,omitempty"`
}

// HelperAstronomicSunRiseFallData Helper Object for the Sunrise and Sunset configuration
type HelperAstronomicSunRiseFallData struct {
	// Enabled - enable the sun event mode
	// - disabling will delete the sun event data
	Enabled bool `json:"enabled"`

	// TurnOff turn the unit off in regards to the sun event
	TurnOff *HelperAstronomicSunRiseFallTurnOff `json:"turnOff,omitempty"`

	// TurnOn turn the unit off in regards to the sun event
	TurnOn *HelperAstronomicSunRiseFallTurnOn `json:"turnOn,omitempty"`
}

// HelperAstronomicSunRiseFallDataWithActions Helper Object for the Sunrise and Sunset configuration
type HelperAstronomicSunRiseFallDataWithActions struct {
	TurnOn *HelperAstronomicSunRiseFallTurnOnWithActions `json:"turnOn,omitempty"`
}

// HelperAstronomicSunRiseFallDurationTime - time in minutes
// - required, if mode is set to duration
// - time after which unit is turned off again
type HelperAstronomicSunRiseFallDurationTime = int

// HelperAstronomicSunRiseFallFixedTime - time in minutes
// - required, if mode is set to fixed
// - relative to the beginning of the day
type HelperAstronomicSunRiseFallFixedTime = int

// HelperAstronomicSunRiseFallOffsetTime - offset time in minutes
// - required, if mode is set to offset
// - configuring negative numbers applies an offset relative to before the sun event
// - configuring positive numbers applies an offset relative to after the sun event
type HelperAstronomicSunRiseFallOffsetTime = int

// HelperAstronomicSunRiseFallTurnOff turn the unit off in regards to the sun event
type HelperAstronomicSunRiseFallTurnOff struct {
	DurationTime *HelperAstronomicSunRiseFallDurationTime `json:"durationTime,omitempty"`
	FixedTime    *HelperAstronomicSunRiseFallFixedTime    `json:"fixedTime,omitempty"`

	// Mode whether the unit should be switched at a fixed time, relative to the sun event, after a specified time or with the next sun event (either sunset/sunrise)
	Mode       HelperAstronomicSunRiseFallTurnOffMode `json:"mode"`
	OffsetTime *HelperAstronomicSunRiseFallOffsetTime `json:"offsetTime,omitempty"`
}

// HelperAstronomicSunRiseFallTurnOffMode whether the unit should be switched at a fixed time, relative to the sun event, after a specified time or with the next sun event (either sunset/sunrise)
type HelperAstronomicSunRiseFallTurnOffMode string

// HelperAstronomicSunRiseFallTurnOn defines model for helper_astronomic_sunRiseFall_turnOn.
type HelperAstronomicSunRiseFallTurnOn struct {
	FixedTime *HelperAstronomicSunRiseFallFixedTime `json:"fixedTime,omitempty"`

	// Mode whether the unit should be switched at a fixed time or relative to the sun event
	Mode       *HelperAstronomicSunRiseFallTurnOnMode `json:"mode,omitempty"`
	OffsetTime *HelperAstronomicSunRiseFallOffsetTime `json:"offsetTime,omitempty"`
}

// HelperAstronomicSunRiseFallTurnOnMode whether the unit should be switched at a fixed time or relative to the sun event
type HelperAstronomicSunRiseFallTurnOnMode string

// HelperAstronomicSunRiseFallTurnOnWithActions defines model for helper_astronomic_sunRiseFall_turnOn_withActions.
type HelperAstronomicSunRiseFallTurnOnWithActions struct {
	// ColorTemperature (TBD FEATURE)
	ColorTemperature *ActionColorTemperature               `json:"colorTemperature,omitempty"`
	FixedTime        *HelperAstronomicSunRiseFallFixedTime `json:"fixedTime,omitempty"`

	// HsColor (TBD FEATURE)
	HsColor *ActionHsColor `json:"hsColor,omitempty"`

	// Level (TBD FEATURE)
	Level *ActionLevel `json:"level,omitempty"`

	// Mode whether the unit should be switched at a fixed time or relative to the sun event
	Mode       *HelperAstronomicSunRiseFallTurnOnWithActionsMode `json:"mode,omitempty"`
	OffsetTime *HelperAstronomicSunRiseFallOffsetTime            `json:"offsetTime,omitempty"`
}

// HelperAstronomicSunRiseFallTurnOnWithActionsMode whether the unit should be switched at a fixed time or relative to the sun event
type HelperAstronomicSunRiseFallTurnOnWithActionsMode string

// HelperAvailableTemplates list of template/scenario UIDs that can be triggered by the button/sensor
type HelperAvailableTemplates = []string

// HelperAvailableUnits - list of unit UIDs that can be switched by the button/sensor
// - for buttons this includes units with onOffInterfaces or blindInterfaces
// - for alert sensors this includes units with onOffInterfaces
type HelperAvailableUnits = []string

// HelperAvailableTemplateBlindLevelUids list of blind UIDs of level units to be controlled by a template
// | property        |  available options  |
// | ---             | --- |
// | interfaces      | `levelControlInterface`<br>`timer` |
// | applyTypes      | `level`<br>`relayAutomatic` |
type HelperAvailableTemplateBlindLevelUids = []string

// HelperAvailableTemplateColorUnitUids list of UIDs of color units to be controlled by a template
// | property        |  available options  |
// | ---             | --- |
// | interfaces      | `colorControlInterface` |
// | applyTypes      | `color` |
type HelperAvailableTemplateColorUnitUids = []string

// HelperAvailableTemplateLampLevelUids list of lamp UIDs of level units to be controlled by a template
// | property        |  available options  |
// | ---             | --- |
// | interfaces      | `levelControlInterface`<br>`timer` |
// | applyTypes      | `level`<br>`sunSimulation` |
type HelperAvailableTemplateLampLevelUids = []string

// HelperAvailableTemplateOnOffUids list of UIDs of onOff units to be controlled by a template
// | property        |  available options  |
// | ---             | --- |
// | interfaces      | `onOffInterface`<br>`timer` |
// | applyTypes      | `relayManual`<br>`relayAutomatic` |
type HelperAvailableTemplateOnOffUids = []string

// HelperAvailableTemplateTelephoneAnsweringMachineUids list of telephone answering machine UIDs to be controlled by a template
// | property        |  available options  |
// | ---             | --- |
// | interfaces      | `telephoneAnsweringMachineInterface` |
// | applyTypes      | `tamControl` |
type HelperAvailableTemplateTelephoneAnsweringMachineUids = []string

// HelperAvailableTemplateTemplateUids list of UIDs of templates to be controlled by a scenario
// | property        |  available options  |
// | ---             | --- |
// | interfaces      | `scenario` |
// | applyTypes      | `subTemplates` |
type HelperAvailableTemplateTemplateUids = []string

// HelperAvailableTemplateThermostatUids list of UIDs of thermostat units to be controlled by a template
// | property        |  available options  |
// | ---             | --- |
// | interfaces      | `thermostatInterface`<br>`timer` |
// | applyTypes      | `thermostatOnOff`<br>`thermostatTemperature`<br>`thermostatHoliday`<br>`thermostatTimeTable`<br>`timerControl` |
type HelperAvailableTemplateThermostatUids = []string

// HelperAvailableTemplateTriggerUids list of UIDs of triggers to be controlled by a template
// | property        |  available options  |
// | ---             | --- |
// | interfaces      | `triggerInterface` |
// | applyTypes      | `relayManual` |
type HelperAvailableTemplateTriggerUids = []string

// HelperAvmPresets curated hsColors and colorTemperatures
type HelperAvmPresets struct {
	// ColorTemperaturePaletteList color temperature default values
	ColorTemperaturePaletteList *[]int                `json:"colorTemperaturePaletteList,omitempty"`
	HsColorPalette              *HelperHsColorPalette `json:"hsColorPalette,omitempty"`
}

// HelperBaseTimer Timer object for automatic action of units, consists of a time object and a corresponding action
type HelperBaseTimer struct {
	// Astronomic - astronomical timer based on geographical position
	// - unit can be controlled based on sunrise and sunset
	Astronomic *HelperBaseTimerAstronomicWithActions `json:"astronomic,omitempty"`

	// Countdown - automatically turn the unit off or on after a configured time
	// - turnOff countdown is triggered by turning the unit on
	// - turnOn countdown is triggered by turning the unit off
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Countdown *HelperBaseTimerCountdown `json:"countdown,omitempty"`

	// Daily - when setting an action in a daily timer, a subsequent action always needs to differ (e.g. different action or value) to the previous one
	// - daylight saving time (winter- & summertime) is handled automatically by the backend and should not be handled by the client
	Daily *HelperBaseTimerDaily `json:"daily,omitempty"`

	// Once - turn the unit on or off at a specific time once
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Once *HelperBaseTimerOnce `json:"once,omitempty"`

	// Random - random toggling of unit in the provided active period (startDate to endDate)
	// - further restrict the time of day with startTimePerDay and endTimePerDay
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Random *HelperBaseTimerRandom `json:"random,omitempty"`

	// Rhythmic - rhythmically turn the unit on and off
	// - time to stay turned on and off are configurably seperately
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Rhythmic *HelperBaseTimerRhythmic `json:"rhythmic,omitempty"`

	// Weekly - when setting an action in a weekly timer, a subsequent action always needs to differ (e.g. different action or value) to the previous one
	// - daylight saving time (winter- & summertime) is handled automatically by the backend and should not be handled by the client
	Weekly *HelperBaseTimerWeekly `json:"weekly,omitempty"`
}

// HelperBaseTimerAstronomic Astronomic time object for automations.
type HelperBaseTimerAstronomic struct {
	// Location geographical location used for calculating sun position
	Location *HelperAstronomicLocation `json:"location,omitempty"`

	// Sunrise - configure sunrise options
	// - if setting turnOn.mode to 'offset', turnOff.mode can not be set to 'offset' too
	// - if setting turnOn.mode to 'fixed', turnOff.mode can only be set to 'offset'
	Sunrise *HelperAstronomicSunRiseFallData `json:"sunrise,omitempty"`

	// Sunset - configure sunset options
	// - if setting turnOn.mode to 'offset', turnOff.mode can not be set to 'offset' too
	// - if setting turnOn.mode to 'fixed', turnOff.mode can only be set to 'offset'
	Sunset *HelperAstronomicSunRiseFallData `json:"sunset,omitempty"`
}

// HelperBaseTimerAstronomicWithActions Astronomic time object for automations.
type HelperBaseTimerAstronomicWithActions = HelperBaseTimerAstronomic

// HelperBaseTimerCalendar defines model for helper_base_timer_calendar.
type HelperBaseTimerCalendar struct {
	// ColorTemperature (TBD FEATURE)
	ColorTemperature *ActionColorTemperature `json:"colorTemperature,omitempty"`

	// HsColor (TBD FEATURE)
	HsColor *ActionHsColor `json:"hsColor,omitempty"`

	// Level (TBD FEATURE)
	Level *ActionLevel `json:"level,omitempty"`

	// Name name of the google calendar
	Name *string `json:"name,omitempty"`
}

// HelperBaseTimerCountdown defines model for helper_base_timer_countdown.
type HelperBaseTimerCountdown struct {
	// ColorTemperature (TBD FEATURE)
	ColorTemperature *ActionColorTemperature `json:"colorTemperature,omitempty"`

	// HsColor (TBD FEATURE)
	HsColor *ActionHsColor `json:"hsColor,omitempty"`

	// Level (TBD FEATURE)
	Level *ActionLevel `json:"level,omitempty"`

	// Mode - select whether to turn on/off the unit after configured time
	Mode *HelperBaseTimerCountdownMode `json:"mode,omitempty"`

	// Time countdown time in minutes
	Time *int `json:"time,omitempty"`
}

// HelperBaseTimerCountdownMode - select whether to turn on/off the unit after configured time
type HelperBaseTimerCountdownMode string

// HelperBaseTimerDaily Array of daily time objects for automations
type HelperBaseTimerDaily struct {
	// TurnOff - turn a unit off at a specific time of the day
	// - this also applies to blinds (close)
	TurnOff *HelperBaseTimerDailyObj `json:"turnOff,omitempty"`

	// TurnOn - turn a unit on at a specific time of the day
	// - this also applies to blinds (open)
	// - (TBD) optionally you can set level and/or color
	TurnOn *struct {
		// ColorTemperature (TBD FEATURE)
		ColorTemperature *ActionColorTemperature `json:"colorTemperature,omitempty"`

		// HsColor (TBD FEATURE)
		HsColor *ActionHsColor `json:"hsColor,omitempty"`

		// Level (TBD FEATURE)
		Level *ActionLevel `json:"level,omitempty"`

		// Time - minutes since beginning of day
		// - duplicates of time are not allowed
		Time int `json:"time"`
	} `json:"turnOn,omitempty"`
}

// HelperBaseTimerDailyObj defines model for helper_base_timer_daily_obj.
type HelperBaseTimerDailyObj struct {
	// Time - minutes since beginning of day
	// - duplicates of time are not allowed
	Time int `json:"time"`
}

// HelperBaseTimerGroupTemperatureWeekly Calendar time object for groupTemperatureWeekly.
type HelperBaseTimerGroupTemperatureWeekly struct {
	// AvailableSensors List of UIDs of possible units that can be configured as a temperature sensor
	AvailableSensors *[]string                   `json:"availableSensors,omitempty"`
	GroupWeekly      *HelperBaseTimerGroupWeekly `json:"groupWeekly,omitempty"`

	// HeatingModeEnabled - groupTemperatureWeekly allows for two different modes
	// - if the heatingMode is enabled the group will turn on, if the temperature falls beneath the configured thresholdTemperature
	// - if the heatingMode is disabled (~coolingMode) the group will turn on, if the temperature rises above the configured temperature (only the upperThresholdTemperaute is valid)
	HeatingModeEnabled *bool `json:"heatingModeEnabled,omitempty"`

	// LowerThresholdTemperature - this is equivalent to the reduced temperature of a thermostat
	// - the actual configured lowerThresholdTemperature is only relevant if heatingModeEnabled is true
	// - (it still needs to be set in the groupWeekly array though)
	LowerThresholdTemperature *HelperTemperatureThreshold `json:"lowerThresholdTemperature,omitempty"`

	// SensorUid UID of active temperature sensor unit. This always needs to be set for the groupTemperatureWeekly timer to work properly
	SensorUid *string `json:"sensorUid,omitempty"`

	// UpperThresholdTemperature - if heatingModeEnabled is true, this is equivalent to the comfort temperature of a thermostat; the group will turn on if the temperature is below the upperThreshold (use with electric heating)
	// - if heatingModeEnabled is false (coolingMode), the group will turn on if the temperature is above the upperThreshold (use with air conditioning)
	UpperThresholdTemperature *HelperTemperatureThreshold `json:"upperThresholdTemperature,omitempty"`
}

// HelperBaseTimerGroupTemperatureWeeklyObj group temperature Weekly time object for automations.
type HelperBaseTimerGroupTemperatureWeeklyObj struct {
	GroupTemperature *ActionGroupTemperature `json:"groupTemperature,omitempty"`

	// Time - minutes since beginning of week (day change from sunday to monday 00:00 o'clock)
	// - duplicates of time are not allowed
	Time int `json:"time"`
}

// HelperBaseTimerGroupWeekly Array of group temperature weekly time objects for automations
type HelperBaseTimerGroupWeekly = []HelperBaseTimerGroupTemperatureWeeklyObj

// HelperBaseTimerOnce defines model for helper_base_timer_once.
type HelperBaseTimerOnce struct {
	// ColorTemperature (TBD FEATURE)
	ColorTemperature *ActionColorTemperature `json:"colorTemperature,omitempty"`

	// HsColor (TBD FEATURE)
	HsColor *ActionHsColor `json:"hsColor,omitempty"`

	// Level (TBD FEATURE)
	Level *ActionLevel `json:"level,omitempty"`

	// Mode select whether to turn the unit on (true) or off (false)
	Mode           *HelperBaseTimerOnceMode `json:"mode,omitempty"`
	SwitchDuration *HelperSwitchDuration    `json:"switchDuration,omitempty"`

	// Timestamp - time at which the unit should be turned on/off
	// - unix timestamp
	// - overflowing of unix timestamp is not handled
	Timestamp *int `json:"timestamp"`
}

// HelperBaseTimerOnceMode select whether to turn the unit on (true) or off (false)
type HelperBaseTimerOnceMode string

// HelperBaseTimerRandom defines model for helper_base_timer_random.
type HelperBaseTimerRandom struct {
	// ColorTemperature (TBD FEATURE)
	ColorTemperature *ActionColorTemperature `json:"colorTemperature,omitempty"`

	// EndDate - end of active period
	// - unix timestamp
	// - only day, month and year are relevant
	EndDate *int `json:"endDate,omitempty"`

	// EndTimePerDay - minutes since beginning of day (00:00)
	// - if startTimePerDay & endTimePerDay are set to the same value, activePeriod will be enabled all day
	// - for wrapping into a new day set endTimePerDay < startTimePerDay
	EndTimePerDay *int `json:"endTimePerDay,omitempty"`

	// HsColor (TBD FEATURE)
	HsColor *ActionHsColor `json:"hsColor,omitempty"`

	// Level (TBD FEATURE)
	Level *ActionLevel `json:"level,omitempty"`

	// StartDate - start of active period
	// - unix timestamp
	// - only day, month and year are relevant
	StartDate *int `json:"startDate,omitempty"`

	// StartTimePerDay - minutes since beginning of day (00:00)
	// - if startTimePerDay & endTimePerDay are set to the same value, activePeriod will be enabled all day
	// - for wrapping into a new day set startTimePerDay > endTimePerDay
	StartTimePerDay *int `json:"startTimePerDay,omitempty"`
}

// HelperBaseTimerRhythmic defines model for helper_base_timer_rhythmic.
type HelperBaseTimerRhythmic struct {
	// ColorTemperature (TBD FEATURE)
	ColorTemperature *ActionColorTemperature `json:"colorTemperature,omitempty"`

	// HsColor (TBD FEATURE)
	HsColor *ActionHsColor `json:"hsColor,omitempty"`

	// Level (TBD FEATURE)
	Level *ActionLevel `json:"level,omitempty"`

	// OffTime time in minutes unit will stay turned off
	OffTime int `json:"offTime"`

	// OnTime time in minutes unit will stay turned on
	OnTime int `json:"onTime"`
}

// HelperBaseTimerWeekly Array of weekly time objects for automations
type HelperBaseTimerWeekly = []HelperBaseTimerWeeklyObj

// HelperBaseTimerWeeklyObj defines model for helper_base_timer_weekly_obj.
type HelperBaseTimerWeeklyObj struct {
	Blind *HelperBlindAction `json:"blind,omitempty"`

	// ColorTemperature (TBD FEATURE)
	ColorTemperature *ActionColorTemperature `json:"colorTemperature,omitempty"`

	// HsColor (TBD FEATURE)
	HsColor *ActionHsColor `json:"hsColor,omitempty"`

	// Level (TBD FEATURE)
	Level             *ActionLevel             `json:"level,omitempty"`
	OnOff             *ActionOnOff             `json:"onOff,omitempty"`
	Temperature       *ActionTemperature       `json:"temperature,omitempty"`
	TemperaturePreset *ActionTemperaturePreset `json:"temperaturePreset,omitempty"`

	// Time - minutes since beginning of week (day change from sunday to monday 00:00 o'clock)
	// - for thermostats this need to be a multiple of 15 minutes
	// - duplicates of time are not allowed
	Time *int `json:"time,omitempty"`
}

// HelperBlindAction Action for getting/putting a blind unit
type HelperBlindAction string

// HelperControlMode defines model for helper_controlMode.
type HelperControlMode string

// HelperCurrentSensingEnabled - enables current sensing for supported blinds
// - if enabled, the blind will automatically stop when detecting an obstacle
type HelperCurrentSensingEnabled = bool

// HelperDestinationMode - whether to switch a unit or trigger a template/scenario
// - when choosing `units` or `templates` mode, the `destinationUids` array needs to be filled with at least one unit/template uid
type HelperDestinationMode string

// HelperDestinationUids - list of UIDs of units to be switched or templates to be triggered, in case of button press / sensor event
// - this array is only allowed to be filled with exclusively units or templates, not both
// - when putting this array, at least 1 items UID needs to be provided
type HelperDestinationUids = []string

// HelperEndPositions - configure end positions and motor direction for supported blinds
// - when configuring end positions use the blindAction to move the blind up/down step-wise (around a few 100ms per step)
type HelperEndPositions struct {
	// LowerEndPositionEnabled - whether the lower end position is configured
	// - when setting this value, the current blind position will be set as the lower boundary (closed state)
	// - once set, can only be reset by setting 'triggerReset'
	LowerEndPositionEnabled *bool `json:"lowerEndPositionEnabled,omitempty"`

	// MotorReversedActive - false: default direction
	// - true: reverse direction
	// - can only be set while configuring the end positions
	MotorReversedActive *bool `json:"motorReversedActive,omitempty"`

	// TriggerReset reset both end positions and motor direction
	TriggerReset *bool `json:"triggerReset,omitempty"`

	// UpperEndPositionEnabled - whether the upper end position is configured
	// - when setting this value, the current blind position will be set as the upper boundary (opened state)
	// - once set, can only be reset by setting 'triggerReset'
	UpperEndPositionEnabled *bool `json:"upperEndPositionEnabled,omitempty"`
}

// HelperEnergyKeyFigures global energy key figures (/kWh & co2)
type HelperEnergyKeyFigures struct {
	// Co2emmissions CO2-emmissions [g] - g/kWh
	Co2emmissions *float32 `json:"co2emmissions,omitempty"`

	// ElectricityRate price [] - electricity rate in /kWh, resolution: 0.01 cents
	ElectricityRate *float32 `json:"electricityRate,omitempty"`
}

// HelperFlyScreenProtectionEnabled - enables the fly screen protection for supported blinds
// - if enabled, the blind will try to detect an obstacle and only slowly move down
// - if an obstacle is detected the blind will move up into its upper end position
// - if the blind is running stiffly, disable this option
type HelperFlyScreenProtectionEnabled = bool

// HelperFreezeProtectionEnabled - enables freeze protection for supported blinds
// - if enabled, once the blind reaches its upper end position, it will move down a bit into the reverse direction
// - this prevents freezing to the shutter box
type HelperFreezeProtectionEnabled = bool

// HelperFrequencyBound frequency bound for noiseControl in Hz
type HelperFrequencyBound = float32

// HelperHolidayPeriodRelativeTimestamp - minutes since beginning of year
// - timestamp is only valid, if set to the hour (hence multipleOf 60)
// - leap year (29th February) is always included
// - endTime is used for setting the day, the period will be active until the end of the day
// - 0       -> 1st  January (day change from 31st December to 1st January 00:00 o'clock)
// - 526980  -> 31st December 23:00 o'clock
type HelperHolidayPeriodRelativeTimestamp = int

// HelperHolidayPeriods - schedule for holiday periods (thermostat is set to configured temperature)
// - if the periods array contains date ranges, the holiday mode will activate automatically
// - startTime is allowed to be bigger than endTime -> this allows setting holidayPeriods that extend into a new year
type HelperHolidayPeriods struct {
	// Periods - holidayPeriods are not allowed to overlap with each other or the summerPeriod, if it is enabled
	// - modification and deletion is only possible by setting the whole periods-array
	Periods *[]HelperPeriodHolidayRange `json:"periods,omitempty"`

	// Temperature Thermostat temperature for holiday periods
	Temperature *HelperTemperature `json:"temperature,omitempty"`
}

// HelperHsColor - object grouping the free hue saturation configuration for color capable lights
// - colors can also be set via the "activeHsColorPreset" object
// - when a preset is selected the hue and saturation which are provided here should solely be used as the entry point for a free color choice
// - when setting the color on a unit with an onOffInterface, the onOff will not be modified automatically
type HelperHsColor struct {
	Hue        int `json:"hue"`
	Saturation int `json:"saturation"`
}

// HelperHsColorPalette - curated hsColor palette for color-capable lamps
// - includes suggested hue & saturation values for display in a user-interface
type HelperHsColorPalette = []HelperHsColorPaletteItem

// HelperHsColorPaletteItem defines model for helper_hsColorPalette_item.
type HelperHsColorPaletteItem struct {
	// HueFromPalette suggested hue value for display of the preset in a user-interface
	HueFromPalette *int `json:"hueFromPalette,omitempty"`

	// NameId ID for name of hsColorPreset
	NameId *int `json:"nameId,omitempty"`

	// PresetId ID for hsColorPreset
	PresetId *int `json:"presetId,omitempty"`

	// SaturationFromPalette suggested saturation value for display of the preset in a user-interface
	SaturationFromPalette *int `json:"saturationFromPalette,omitempty"`
}

// HelperLamellarEnabled - enables lamellar mode for supported blinds
// - if enabled, a second unit will be available
type HelperLamellarEnabled = bool

// HelperLamellarSlatRuntime - max time for tilting of lamellar slats
// - default: 1.5 sec
// - only available, if lamellar is enabled
type HelperLamellarSlatRuntime = float32

// HelperNextChange Next thermostat temperature change
type HelperNextChange struct {
	ChangeTime        *HelperTimestamp         `json:"changeTime,omitempty"`
	TemperatureChange *HelperTemperatureChange `json:"temperatureChange,omitempty"`
}

// HelperNoiseControl - only available for FRITZ!Smart Energy plugsockets
// - control unit by noise (e.g. by clapping hands or custom signal)
type HelperNoiseControl struct {
	// ControlMode - event in case of detected noise
	// - when setting 'controlMode' to 'toggle', 'switchDuration.mode' will automatically be set to 'permanent'
	ControlMode *HelperControlMode `json:"controlMode,omitempty"`

	// CustomSignal - configure custom signal options
	// - required if customSignal mode is selected
	CustomSignal *struct {
		// HigherFrequencyBound higher frequency bound (may not be equal to or lower than lowerFrequencyBound)
		HigherFrequencyBound *HelperFrequencyBound `json:"higherFrequencyBound,omitempty"`

		// LowerFrequencyBound lower frequency bound (may not be equal to or higher than higherFrequencyBound)
		LowerFrequencyBound *HelperFrequencyBound `json:"lowerFrequencyBound,omitempty"`

		// SignalDuration required duration of signal for detection in milliseconds
		SignalDuration *int `json:"signalDuration,omitempty"`

		// SwitchingMode select mode to switch unit depending on whether a signal or silence is detected
		SwitchingMode *HelperNoiseControlCustomSignalSwitchingMode `json:"switchingMode,omitempty"`
	} `json:"customSignal,omitempty"`
	FixedActivePeriod *struct {
		// Enabled - enable/disable the active period
		// - if disabled, the feature will always be on
		Enabled *bool `json:"enabled,omitempty"`

		// EndDate - end of active period
		// - unix timestamp
		// - only day, month and year are relevant
		EndDate *int `json:"endDate,omitempty"`

		// EndTimePerDay - minutes since beginning of day (00:00)
		// - if startTimePerDay & endTimePerDay are set to the same value, activePeriod will be enabled all day
		// - for wrapping into a new day set endTimePerDay < startTimePerDay
		EndTimePerDay *int `json:"endTimePerDay,omitempty"`

		// StartDate - start of active period
		// - unix timestamp
		// - only day, month and year are relevant
		StartDate *int `json:"startDate,omitempty"`

		// StartTimePerDay - minutes since beginning of day (00:00)
		// - if startTimePerDay & endTimePerDay are set to the same value, activePeriod will be enabled all day
		// - for wrapping into a new day set startTimePerDay > endTimePerDay
		StartTimePerDay *int `json:"startTimePerDay,omitempty"`
	} `json:"fixedActivePeriod,omitempty"`

	// Intensity volume intensity (0 - lowest | 9 - highest)
	Intensity *int `json:"intensity,omitempty"`

	// NoiseMode - select noise mode
	// - clap mode detects 2 fast subsequent claps or knocks
	// - customSignal allows for configuring frequencies and duration of the to be detected signal
	NoiseMode HelperNoiseControlNoiseMode `json:"noiseMode"`

	// SwitchDuration - choose whether switching of unit should be permanent or toggle back after configured time
	// - 'toggleBack' mode only available if `controlMode` is set to either 'on' or 'off'
	SwitchDuration *HelperSwitchDuration `json:"switchDuration,omitempty"`
}

// HelperNoiseControlCustomSignalSwitchingMode select mode to switch unit depending on whether a signal or silence is detected
type HelperNoiseControlCustomSignalSwitchingMode string

// HelperNoiseControlNoiseMode - select noise mode
// - clap mode detects 2 fast subsequent claps or knocks
// - customSignal allows for configuring frequencies and duration of the to be detected signal
type HelperNoiseControlNoiseMode string

// HelperOnOffMasterUnitUid - unique identifier of group-master unit
// - only units with an onOffInterface are allowed
// - other members of the group will follow the master
type HelperOnOffMasterUnitUid = string

// HelperOverviewDevice defines model for helper_overview_device.
type HelperOverviewDevice struct {
	// UID unique identifier corresponding to ain of device
	UID string `json:"UID"`

	// Ain unique hardware identifier of device
	Ain string `json:"ain"`

	// BatteryState - 'known': the device sends infos about its batteryValue
	// - 'unknown': the device doesn't have a battery, or hasn't send its batteryValue yet (e.g. after reboot etc)
	BatteryState HelperOverviewDeviceBatteryState `json:"batteryState"`

	// BatteryValue Battery in 0..100 percent. Only available for battery-powered devices.
	BatteryValue *int `json:"batteryValue,omitempty"`

	// FirmwareVersion firmware version of device, may be empty
	FirmwareVersion string `json:"firmwareVersion"`

	// HardwareModelId product hardware model id
	HardwareModelId *string `json:"hardwareModelId,omitempty"`

	// Icons device can have multiple icons (for example for multiple units), can be empty
	Icons []int `json:"icons"`

	// IsBatteryLow - true: battery low warning from device
	// - false: battery ok (only available for FRITZ! thermostats and FRITZ! buttons)"
	IsBatteryLow *bool `json:"isBatteryLow,omitempty"`

	// IsBatteryPowered whether the device has batteries
	IsBatteryPowered *bool `json:"isBatteryPowered,omitempty"`

	// IsConnected - false: no connection / connection lose
	// - true: connection established
	// - when the device, and therefore its units, are not connected you may get the last known infos or default values; which might not be valid
	IsConnected bool `json:"isConnected"`

	// IsDeviceDeletable Whether the deletion of the device is supported. This is mostly relevant in mesh-setups, as it is not allowed to delete remotely subscribed devices from a client.
	IsDeviceDeletable *bool `json:"isDeviceDeletable,omitempty"`

	// IsDeviceSubscribedLocally - true: device is subscribed locally
	// - false: device is subscribed to other F!Box/Gateway in Mesh
	IsDeviceSubscribedLocally bool `json:"isDeviceSubscribedLocally"`

	// IsExternallyPowered whether the device has an external power source
	IsExternallyPowered *bool `json:"isExternallyPowered,omitempty"`

	// IsUpdateAvailable true: update available; false: Device Firmware is up-to-date
	IsUpdateAvailable *bool `json:"isUpdateAvailable,omitempty"`

	// IsZigbeeDevice true if device uses zigbee-protocol to communicate
	IsZigbeeDevice bool `json:"isZigbeeDevice"`

	// LastConnectionTime - since when is the device in connection state (`isConnected`)
	// - only valid, if host has valid time
	LastConnectionTime *HelperTimestamp `json:"lastConnectionTime,omitempty"`

	// Manufacturer manufacturer of device, may be empty
	Manufacturer string `json:"manufacturer"`

	// Name user defined name of physical device, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name string `json:"name"`

	// ProductCategory describes the category, and therefore main feature, of the device
	ProductCategory HelperOverviewDeviceProductCategory `json:"productCategory"`

	// ProductName product name set by manufacturer
	ProductName string          `json:"productName"`
	PushMail    *HelperPushMail `json:"pushMail,omitempty"`

	// RadioBaseSerial Serial (based on MAC-Address) of F!Box/Gateway on which the device is locally subscribed, can be other F!Box/Gateway in Mesh
	RadioBaseSerial *string `json:"radioBaseSerial,omitempty"`

	// UnitUids UIDs of units (children) belonging to physical device
	UnitUids []string `json:"unitUids"`
}

// HelperOverviewDeviceBatteryState - 'known': the device sends infos about its batteryValue
// - 'unknown': the device doesn't have a battery, or hasn't send its batteryValue yet (e.g. after reboot etc)
type HelperOverviewDeviceBatteryState string

// HelperOverviewDeviceProductCategory describes the category, and therefore main feature, of the device
type HelperOverviewDeviceProductCategory string

// HelperOverviewGlobals smart home global infos
type HelperOverviewGlobals struct {
	AvmPresets struct {
		// ColorTemperaturePaletteList color temperature default values
		ColorTemperaturePaletteList *[]int                `json:"colorTemperaturePaletteList,omitempty"`
		HsColorPalette              *HelperHsColorPalette `json:"hsColorPalette,omitempty"`
	} `json:"avmPresets"`

	// EnergyKeyFigures global energy related values (electricity rate & CO2-emmissions)
	EnergyKeyFigures *HelperEnergyKeyFigures `json:"energyKeyFigures,omitempty"`

	// Location geographical location used for calculating sun position
	Location HelperAstronomicLocation `json:"location"`
}

// HelperOverviewUnit defines model for helper_overview_unit.
type HelperOverviewUnit struct {
	// UID unique identifier corresponding to ain of unit
	UID string `json:"UID"`

	// Ain unique hardware identifier of unit
	Ain string `json:"ain"`

	// DeviceUid UID of parent Device; if not present: parent is group
	DeviceUid *string `json:"deviceUid,omitempty"`

	// GroupUid - UID of group, if unit is member in a group
	// - if not present the unit has a group as a parent
	// - if present, but not set, the unit is not in a group
	GroupUid *string `json:"groupUid,omitempty"`

	// Icons icon-IDs from Iconlist (TBD), can be empty
	Icons      []int            `json:"icons"`
	Interfaces IFUnitInterfaces `json:"interfaces"`

	// IsConnected - false: no connection / connection lost
	// - true: connection established
	// - if the device (and therefore its units) are not connected you may get the last known infos or default values. These may not be valid.
	// - for groupUnits (`isGroupUnit` == true) `isConnected` will be true, if at least one memberUnit of the Group is connected
	IsConnected *bool `json:"isConnected,omitempty"`

	// IsGroupUnit - false: parent is device
	// - true: parent is group
	IsGroupUnit bool `json:"isGroupUnit"`

	// Name user defined name of funcitonal Unit, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed (may be automatically set through the device name if only 1 unit exists)
	Name UnitNameOverview `json:"name"`

	// ParentUid UID of parent device or group
	ParentUid string       `json:"parentUid"`
	UnitType  TypeUnitType `json:"unitType"`
}

// HelperPeriodHolidayRange defines model for helper_period_holidayRange.
type HelperPeriodHolidayRange struct {
	// DeleteAfterEndActive - TO BE DONE, NOT FUNCTIONAL
	// - if true, holidayPeriod will only be active once and deleted afterwards
	DeleteAfterEndActive *bool                                `json:"deleteAfterEndActive,omitempty"`
	EndTime              HelperHolidayPeriodRelativeTimestamp `json:"endTime"`
	StartTime            HelperHolidayPeriodRelativeTimestamp `json:"startTime"`
}

// HelperPowerOnBehaviour - configure state of onOffInterface.active after a restart of the device (e.g. after an update or power cut)
// - feature may not be available for certain units
// - also allows for configuring of level and colorControl after restart for suitable lamps
type HelperPowerOnBehaviour struct {
	// Color Color action
	Color *struct {
		ColorTemperature *ActionColorTemperature `json:"colorTemperature,omitempty"`

		// HsColorPreset allows for setting a hsColor from avmPresets.hsColorPalette for powerOn
		HsColorPreset *HelperHsColorPaletteItem `json:"hsColorPreset,omitempty"`
	} `json:"color,omitempty"`
	Level *ActionLevel `json:"level,omitempty"`

	// Modes - which state the device should be after restart
	// - when selecting "lastState" or "off", level and color configurations will be deleted
	// - when selecting one of the lamp-exclusive modes, 'level', 'colorTemperature' or 'hsColor', you must also select "on"
	// - the ignored setting will be set to the last valid state, e.g. setting 'on' for a lamp, level and color will be as before the powerOn
	Modes []HelperPowerOnBehaviourModes `json:"modes"`
}

// HelperPowerOnBehaviourModes defines model for HelperPowerOnBehaviour.Modes.
type HelperPowerOnBehaviourModes string

// HelperPushMail - Push-service for the device and corresponding units
// - only works for local F!Box/Gateway, not in smart home Mesh
type HelperPushMail struct {
	// Enabled - enable push-service for the device
	// - connectivity changes of the device (disconnected / connected)
	// - low battery warnings (only available on some devices)
	// - device error states
	Enabled *bool `json:"enabled,omitempty"`

	// Recipient - E-mail adress of push-mail recipient
	// - needs to be set when enabling device or units pushMail
	Recipient *string `json:"recipient,omitempty"`

	// Units - list of unit UIDs belonging to the device, for which the push-service is enabled
	// - if list is not provided, push-mail is not available for units
	// - for a unit to be able to send a push-mail, the device push-mail needs to be enabled
	Units *[]HelperPushMailUnit `json:"units,omitempty"`
}

// HelperPushMailUnit defines model for helper_pushMail_unit.
type HelperPushMailUnit struct {
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	UID *string `json:"UID,omitempty"`

	// EventDrivenEnabled enable push-mail triggered by unit-specific events that are based on the device productCategory:
	// | productCategory | possible events   |
	// |-----------------|-------------------|
	// | blind           | not available     |
	// | control         | button presses    |
	// | lamp            | toggling onOff    |
	// | other           | not available     |
	// | sensor          | alerts            |
	// | socket          | toggling onOff    |
	// | thermostat      | not available     |
	EventDrivenEnabled *bool `json:"eventDrivenEnabled,omitempty"`

	// IntervalDriven - only available for FRITZ! plug sockets and power meters
	// - if enabled, a push-mail will be send regularly
	IntervalDriven *HelperPushMailUnitIntervalDriven `json:"intervalDriven,omitempty"`

	// PowerStatisticsPeriod - FRITZ! plug sockets and power meters allow for sending additional info about statistics
	// - period range of energy statistics
	PowerStatisticsPeriod *HelperPushMailUnitPowerStatisticsPeriod `json:"powerStatisticsPeriod,omitempty"`

	// UnitUid UID of unit (belonging to device)
	UnitUid string `json:"unitUid"`
}

// HelperPushMailUnitIntervalDriven - only available for FRITZ! plug sockets and power meters
// - if enabled, a push-mail will be send regularly
type HelperPushMailUnitIntervalDriven string

// HelperPushMailUnitPowerStatisticsPeriod - FRITZ! plug sockets and power meters allow for sending additional info about statistics
// - period range of energy statistics
type HelperPushMailUnitPowerStatisticsPeriod string

// HelperScenario - groups scenario info
// - scenarios are used for grouping templates and applying them all at once
type HelperScenario struct {
	// Icons list of icon-IDs, can be empty
	Icons *[]int `json:"icons,omitempty"`

	// TemplateUids UIDs of assigned templates (if empty -> none assigned)
	TemplateUids *[]string `json:"templateUids,omitempty"`
}

// HelperScreenWidgets - screens allow for a collection of different widgets
// - depending on the positioning of the widgets, up to 4 are allowed per screen
type HelperScreenWidgets = []struct {
	// DestinationUids - list of UIDs of units/templates/triggers to be controlled by widget
	// - depending on the widgetMode this array is required to have at least one UID
	DestinationUids *[]string `json:"destinationUids,omitempty"`

	// MainWifiBands - band of main wifi to be controlled by widget
	// - required if widgetMode is set to 'mainWifi'
	MainWifiBands *[]HelperScreenWidgetsMainWifiBands `json:"mainWifiBands,omitempty"`

	// Name - user defined name to be displayed on the screen
	// - maximum length depends on the screen-size of the widget
	// - the `center`, `bottomCenter` and `topCenter` allow up to 15 characters
	// - all other widgetModes allow up to 7 characters
	Name string `json:"name"`

	// Position - where the feature is positioned on the screen
	// - widgetModes are bound to a certain position-type
	// | position                                               | widget size
	// | -------------------------------------------------------|--------------
	// | `center`                                               | `full`
	// | `bottomCenter`, `topCenter`                            | `half`
	// | `topRight`, `bottomRight`,<br>`bottomLeft`, `topLeft`  | `quarter`
	Position HelperScreenWidgetsPosition `json:"position"`

	// TelephoneAnsweringMachineUid - UID of telephone answering machine to be controlled by widget
	// - required if widgetMode is set to 'tamControl'
	TelephoneAnsweringMachineUid *HelperScreenWidgetsTelephoneAnsweringMachineUid `json:"telephoneAnsweringMachineUid,omitempty"`

	// ToggleBackTime - only available for widgetMode `on`, `off` and `onOff`
	// - whether to toggleBack to old state after configured time
	// - time in seconds
	ToggleBackTime *int `json:"toggleBackTime,omitempty"`

	// WidgetMode - widgets available on screen
	// - each widgetMode has a static size, which can not be changed
	// | widget mode                   | description                                                                     | widget size
	// | ------------------------------|---------------------------------------------------------------------------------|------------
	// | `on`                          | turn unit on                                                                    | `quarter`
	// | `off`                         | turn unit off                                                                   | `quarter`
	// | `toggle`                      | toggles unit on/off                                                             | `quarter`
	// | `template`                    | applies a template                                                              | `quarter`
	// | `thermostatTemperature`       | controls setpointTemperature of thermostats                                     | `half`
	// | `onOff`                       | controls on/off for plugsockets, level of lamps, lamp-groups or mixed groups    | `half`
	// | `blindLevel`                  | control level of blinds                                                         | `half`
	// | `tamControl`                  | control on/off of telephone answering machine                                   | `half`
	// | `hsColorPalette`              | toggle through hsColorPalette for supported lamps                               | `half`
	// | `colorTemperaturePalette`     | toggle through colorTemperaturePalette for supported lamps                      | `half`
	// | `trigger`                     | control on/off of triggers                                                      | `half`
	// | `guestWifi`                   | control on/off of guestWifi, includes QR-Code, no destination                   | `full`
	// | `thermostatFull`              | control setpointTemperature, boost and windowOpenMode of supported thermostats  | `full`
	// | `mainWifi`                    | control on/off of guestWifi, includes QR-Code                                   | `full`
	WidgetMode HelperWidgetMode `json:"widgetMode"`

	// WidgetSize widget size on screen
	WidgetSize HelperWidgetSize `json:"widgetSize"`
}

// HelperScreenWidgetsMainWifiBands defines model for HelperScreenWidgets.MainWifiBands.
type HelperScreenWidgetsMainWifiBands string

// HelperScreenWidgetsPosition - where the feature is positioned on the screen
// - widgetModes are bound to a certain position-type
// | position                                               | widget size
// | -------------------------------------------------------|--------------
// | `center`                                               | `full`
// | `bottomCenter`, `topCenter`                            | `half`
// | `topRight`, `bottomRight`,<br>`bottomLeft`, `topLeft`  | `quarter`
type HelperScreenWidgetsPosition string

// HelperScreenWidgetsTelephoneAnsweringMachineUid - UID of telephone answering machine to be controlled by widget
// - required if widgetMode is set to 'tamControl'
type HelperScreenWidgetsTelephoneAnsweringMachineUid string

// HelperSpecialModeThermostat groups special modes of thermostat (boost & windowOpenMode)
type HelperSpecialModeThermostat struct {
	// Enabled Special mode is active. Only valid if Host has a valid time.
	Enabled *bool `json:"enabled,omitempty"`

	// EndTime Unix timestamp for end of special mode. Required when enabling special mode. *null* means time is unknown, -1 means no (end-)time is set.
	EndTime *int `json:"endTime"`
}

// HelperStandbyAutoTurnOff - only available for FRITZ!Smart Energy plugsockets
// - automatically turn off unit, if standby is detected (e.g. undercutting powerThreshold for configured duration)
// - warning: this object may not be modifiable after a reboot of the F!Box/Gateway, if the Plugsocket was not connected yet
type HelperStandbyAutoTurnOff struct {
	// Duration time in seconds for which the powerThreshold needs to be continiously undercut, for a standby to be detected
	Duration *int `json:"duration,omitempty"`

	// Enabled - turn on/off the standby detection
	// - when setting enabled to true, powerThreshold and duration are both required
	Enabled bool `json:"enabled"`

	// PowerThreshold threshold of power that needs to be undercut in milliWatts [mW]
	PowerThreshold *int `json:"powerThreshold,omitempty"`
}

// HelperStatisticsObject defines model for helper_statistics_object.
type HelperStatisticsObject struct {
	// Interval - interval between values in seconds
	// - **Warning**: for short-term data the interval is only an approximation and should not be understood as a fixed point in time relative to the time of the request
	// - the actual sample time point is highly dependent on the type of device, type of unit and its radio interval
	Interval *int `json:"interval,omitempty"`

	// Period | period                            | Description
	// | ----------------------------------|----------------------------------------------------
	// | `hour`                            | - short-term data of the last hour <br> - will contain values relative to the time of the request
	// | `day`                             | - short-term data of the last 24 hours <br> - will contain values relative to the time of the request
	// | `week`                            | - long-term data of the last 7 days <br> - will contain 4 entries per day (00:00, 06:00, 12:00 & 18:00 o'clock) <br> - newest entry is the summed up value until the time of request
	// | `month`                           | - long-term data of the last 31 days <br> - will contain 1 entry per day (starting at midnight) <br> - newest entry is the summed up value until the time of request
	// | `twoYears`                        | - long-term data of the last 24 months <br> - will contain 1 entry per month (starting at the 1st of every month) <br> - newest entry is the summed up value until the time of request
	// | `unknown`                         | - unknown state, internal error
	Period *HelperStatisticsPeriod `json:"period,omitempty"`

	// StatisticsState | statisticsState                   | Description
	// | ----------------------------------|----------------------------------------------------
	// | `valid`                           | valid data
	// | `outdated`                        | statistic data is outdated and will not be returned
	// | `notConnected`                    | communiation with unit is disturbed, no valid data available
	// | `unknown`                         | unknown state, internal error
	StatisticsState HelperStatisticsObjectStatisticsState `json:"statisticsState"`
}

// HelperStatisticsObjectStatisticsState | statisticsState                   | Description
// | ----------------------------------|----------------------------------------------------
// | `valid`                           | valid data
// | `outdated`                        | statistic data is outdated and will not be returned
// | `notConnected`                    | communiation with unit is disturbed, no valid data available
// | `unknown`                         | unknown state, internal error
type HelperStatisticsObjectStatisticsState string

// HelperStatisticsPeriod | period                            | Description
// | ----------------------------------|----------------------------------------------------
// | `hour`                            | - short-term data of the last hour <br> - will contain values relative to the time of the request
// | `day`                             | - short-term data of the last 24 hours <br> - will contain values relative to the time of the request
// | `week`                            | - long-term data of the last 7 days <br> - will contain 4 entries per day (00:00, 06:00, 12:00 & 18:00 o'clock) <br> - newest entry is the summed up value until the time of request
// | `month`                           | - long-term data of the last 31 days <br> - will contain 1 entry per day (starting at midnight) <br> - newest entry is the summed up value until the time of request
// | `twoYears`                        | - long-term data of the last 24 months <br> - will contain 1 entry per month (starting at the 1st of every month) <br> - newest entry is the summed up value until the time of request
// | `unknown`                         | - unknown state, internal error
type HelperStatisticsPeriod string

// HelperStatisticsUnit - object grouping unit statistics
// - **Warning**: requesting the statistics by sending a GET-Request for certain types of units (avmPlugSockets) will trigger a radio request to fetch the newest statistics. <br> If you decide to request alot of units at once, this could, and at some point will, lead to disturbances to the radio communication of the radioBase.
type HelperStatisticsUnit struct {
	// Energies - short- & long-term data for energy
	// - array will contain periods `day`, `week`, `month` & `twoYears`
	// - expected devices: `FRTIZ!Smart Energy 200`, `FRITZ!Smart Energy 210`, `FRITZ!Smart Energy 250`
	Energies *[]struct {
		// Interval - interval between values in seconds
		// - **Warning**: for short-term data the interval is only an approximation and should not be understood as a fixed point in time relative to the time of the request
		// - the actual sample time point is highly dependent on the type of device, type of unit and its radio interval
		Interval *int `json:"interval,omitempty"`

		// Period | period                            | Description
		// | ----------------------------------|----------------------------------------------------
		// | `hour`                            | - short-term data of the last hour <br> - will contain values relative to the time of the request
		// | `day`                             | - short-term data of the last 24 hours <br> - will contain values relative to the time of the request
		// | `week`                            | - long-term data of the last 7 days <br> - will contain 4 entries per day (00:00, 06:00, 12:00 & 18:00 o'clock) <br> - newest entry is the summed up value until the time of request
		// | `month`                           | - long-term data of the last 31 days <br> - will contain 1 entry per day (starting at midnight) <br> - newest entry is the summed up value until the time of request
		// | `twoYears`                        | - long-term data of the last 24 months <br> - will contain 1 entry per month (starting at the 1st of every month) <br> - newest entry is the summed up value until the time of request
		// | `unknown`                         | - unknown state, internal error
		Period *HelperStatisticsPeriod `json:"period,omitempty"`

		// StatisticsState | statisticsState                   | Description
		// | ----------------------------------|----------------------------------------------------
		// | `valid`                           | valid data
		// | `outdated`                        | statistic data is outdated and will not be returned
		// | `notConnected`                    | communiation with unit is disturbed, no valid data available
		// | `unknown`                         | unknown state, internal error
		StatisticsState HelperStatisticsUnitEnergiesStatisticsState `json:"statisticsState"`

		// Values - energy in WattHours
		// - index 0 holds the newest value
		Values *[]int `json:"values,omitempty"`
	} `json:"energies,omitempty"`

	// Humidities - short-term data for relative humidity
	// - array will contain period `day`
	// - expected devices: `FRITZ!Smart Control 440`
	Humidities *[]struct {
		// Interval - interval between values in seconds
		// - **Warning**: for short-term data the interval is only an approximation and should not be understood as a fixed point in time relative to the time of the request
		// - the actual sample time point is highly dependent on the type of device, type of unit and its radio interval
		Interval *int `json:"interval,omitempty"`

		// Period | period                            | Description
		// | ----------------------------------|----------------------------------------------------
		// | `hour`                            | - short-term data of the last hour <br> - will contain values relative to the time of the request
		// | `day`                             | - short-term data of the last 24 hours <br> - will contain values relative to the time of the request
		// | `week`                            | - long-term data of the last 7 days <br> - will contain 4 entries per day (00:00, 06:00, 12:00 & 18:00 o'clock) <br> - newest entry is the summed up value until the time of request
		// | `month`                           | - long-term data of the last 31 days <br> - will contain 1 entry per day (starting at midnight) <br> - newest entry is the summed up value until the time of request
		// | `twoYears`                        | - long-term data of the last 24 months <br> - will contain 1 entry per month (starting at the 1st of every month) <br> - newest entry is the summed up value until the time of request
		// | `unknown`                         | - unknown state, internal error
		Period *HelperStatisticsPeriod `json:"period,omitempty"`

		// StatisticsState | statisticsState                   | Description
		// | ----------------------------------|----------------------------------------------------
		// | `valid`                           | valid data
		// | `outdated`                        | statistic data is outdated and will not be returned
		// | `notConnected`                    | communiation with unit is disturbed, no valid data available
		// | `unknown`                         | unknown state, internal error
		StatisticsState HelperStatisticsUnitHumiditiesStatisticsState `json:"statisticsState"`

		// Values - relative humidity in %
		// - index 0 holds the newest value
		Values *[]int `json:"values,omitempty"`
	} `json:"humidities,omitempty"`

	// Powers - short-term data for power
	// - array will contain period `hour`
	// - expected devices: `FRTIZ!Smart Energy 200`, `FRITZ!Smart Energy 210`, `FRITZ!Smart Energy 250`
	Powers *[]struct {
		// Interval - interval between values in seconds
		// - **Warning**: for short-term data the interval is only an approximation and should not be understood as a fixed point in time relative to the time of the request
		// - the actual sample time point is highly dependent on the type of device, type of unit and its radio interval
		Interval *int `json:"interval,omitempty"`

		// Period | period                            | Description
		// | ----------------------------------|----------------------------------------------------
		// | `hour`                            | - short-term data of the last hour <br> - will contain values relative to the time of the request
		// | `day`                             | - short-term data of the last 24 hours <br> - will contain values relative to the time of the request
		// | `week`                            | - long-term data of the last 7 days <br> - will contain 4 entries per day (00:00, 06:00, 12:00 & 18:00 o'clock) <br> - newest entry is the summed up value until the time of request
		// | `month`                           | - long-term data of the last 31 days <br> - will contain 1 entry per day (starting at midnight) <br> - newest entry is the summed up value until the time of request
		// | `twoYears`                        | - long-term data of the last 24 months <br> - will contain 1 entry per month (starting at the 1st of every month) <br> - newest entry is the summed up value until the time of request
		// | `unknown`                         | - unknown state, internal error
		Period *HelperStatisticsPeriod `json:"period,omitempty"`

		// StatisticsState | statisticsState                   | Description
		// | ----------------------------------|----------------------------------------------------
		// | `valid`                           | valid data
		// | `outdated`                        | statistic data is outdated and will not be returned
		// | `notConnected`                    | communiation with unit is disturbed, no valid data available
		// | `unknown`                         | unknown state, internal error
		StatisticsState HelperStatisticsUnitPowersStatisticsState `json:"statisticsState"`

		// Values - power in milliWatts
		// - index 0 holds the newest value
		Values *[]int `json:"values,omitempty"`
	} `json:"powers,omitempty"`

	// Temperatures - short-term data for temperature
	// - array will contain period `day`
	// - expected devices: `FRTIZ!Smart Energy 200`, `FRITZ!Smart Energy 210`, `FRITZ!Smart Thermo 301`, `FRITZ!Smart Thermo 302`, `FRITZ!Smart Control 440`
	Temperatures *[]struct {
		// Interval - interval between values in seconds
		// - **Warning**: for short-term data the interval is only an approximation and should not be understood as a fixed point in time relative to the time of the request
		// - the actual sample time point is highly dependent on the type of device, type of unit and its radio interval
		Interval *int `json:"interval,omitempty"`

		// Period | period                            | Description
		// | ----------------------------------|----------------------------------------------------
		// | `hour`                            | - short-term data of the last hour <br> - will contain values relative to the time of the request
		// | `day`                             | - short-term data of the last 24 hours <br> - will contain values relative to the time of the request
		// | `week`                            | - long-term data of the last 7 days <br> - will contain 4 entries per day (00:00, 06:00, 12:00 & 18:00 o'clock) <br> - newest entry is the summed up value until the time of request
		// | `month`                           | - long-term data of the last 31 days <br> - will contain 1 entry per day (starting at midnight) <br> - newest entry is the summed up value until the time of request
		// | `twoYears`                        | - long-term data of the last 24 months <br> - will contain 1 entry per month (starting at the 1st of every month) <br> - newest entry is the summed up value until the time of request
		// | `unknown`                         | - unknown state, internal error
		Period *HelperStatisticsPeriod `json:"period,omitempty"`

		// StatisticsState | statisticsState                   | Description
		// | ----------------------------------|----------------------------------------------------
		// | `valid`                           | valid data
		// | `outdated`                        | statistic data is outdated and will not be returned
		// | `notConnected`                    | communiation with unit is disturbed, no valid data available
		// | `unknown`                         | unknown state, internal error
		StatisticsState HelperStatisticsUnitTemperaturesStatisticsState `json:"statisticsState"`

		// Values - temperature in C
		// - index 0 holds the newest value
		Values *[]float32 `json:"values,omitempty"`
	} `json:"temperatures,omitempty"`

	// Voltages - short-term data for voltage
	// - array will contain period `hour`
	// - expected devices: `FRTIZ!Smart Energy 200`, `FRITZ!Smart Energy 210`, `FRITZ!Smart Energy 250`
	Voltages *[]struct {
		// Interval - interval between values in seconds
		// - **Warning**: for short-term data the interval is only an approximation and should not be understood as a fixed point in time relative to the time of the request
		// - the actual sample time point is highly dependent on the type of device, type of unit and its radio interval
		Interval *int `json:"interval,omitempty"`

		// Period | period                            | Description
		// | ----------------------------------|----------------------------------------------------
		// | `hour`                            | - short-term data of the last hour <br> - will contain values relative to the time of the request
		// | `day`                             | - short-term data of the last 24 hours <br> - will contain values relative to the time of the request
		// | `week`                            | - long-term data of the last 7 days <br> - will contain 4 entries per day (00:00, 06:00, 12:00 & 18:00 o'clock) <br> - newest entry is the summed up value until the time of request
		// | `month`                           | - long-term data of the last 31 days <br> - will contain 1 entry per day (starting at midnight) <br> - newest entry is the summed up value until the time of request
		// | `twoYears`                        | - long-term data of the last 24 months <br> - will contain 1 entry per month (starting at the 1st of every month) <br> - newest entry is the summed up value until the time of request
		// | `unknown`                         | - unknown state, internal error
		Period *HelperStatisticsPeriod `json:"period,omitempty"`

		// StatisticsState | statisticsState                   | Description
		// | ----------------------------------|----------------------------------------------------
		// | `valid`                           | valid data
		// | `outdated`                        | statistic data is outdated and will not be returned
		// | `notConnected`                    | communiation with unit is disturbed, no valid data available
		// | `unknown`                         | unknown state, internal error
		StatisticsState HelperStatisticsUnitVoltagesStatisticsState `json:"statisticsState"`

		// Values - voltage in milliVolts
		// - index 0 holds the newest value
		Values *[]float32 `json:"values,omitempty"`
	} `json:"voltages,omitempty"`
}

// HelperStatisticsUnitEnergiesStatisticsState | statisticsState                   | Description
// | ----------------------------------|----------------------------------------------------
// | `valid`                           | valid data
// | `outdated`                        | statistic data is outdated and will not be returned
// | `notConnected`                    | communiation with unit is disturbed, no valid data available
// | `unknown`                         | unknown state, internal error
type HelperStatisticsUnitEnergiesStatisticsState string

// HelperStatisticsUnitHumiditiesStatisticsState | statisticsState                   | Description
// | ----------------------------------|----------------------------------------------------
// | `valid`                           | valid data
// | `outdated`                        | statistic data is outdated and will not be returned
// | `notConnected`                    | communiation with unit is disturbed, no valid data available
// | `unknown`                         | unknown state, internal error
type HelperStatisticsUnitHumiditiesStatisticsState string

// HelperStatisticsUnitPowersStatisticsState | statisticsState                   | Description
// | ----------------------------------|----------------------------------------------------
// | `valid`                           | valid data
// | `outdated`                        | statistic data is outdated and will not be returned
// | `notConnected`                    | communiation with unit is disturbed, no valid data available
// | `unknown`                         | unknown state, internal error
type HelperStatisticsUnitPowersStatisticsState string

// HelperStatisticsUnitTemperaturesStatisticsState | statisticsState                   | Description
// | ----------------------------------|----------------------------------------------------
// | `valid`                           | valid data
// | `outdated`                        | statistic data is outdated and will not be returned
// | `notConnected`                    | communiation with unit is disturbed, no valid data available
// | `unknown`                         | unknown state, internal error
type HelperStatisticsUnitTemperaturesStatisticsState string

// HelperStatisticsUnitVoltagesStatisticsState | statisticsState                   | Description
// | ----------------------------------|----------------------------------------------------
// | `valid`                           | valid data
// | `outdated`                        | statistic data is outdated and will not be returned
// | `notConnected`                    | communiation with unit is disturbed, no valid data available
// | `unknown`                         | unknown state, internal error
type HelperStatisticsUnitVoltagesStatisticsState string

// HelperSummerPeriod - schedule and enabling of summer period (thermostat is in freeze protection mode)
// - if enabled, the summer period will be repeated every year
// - startTime is allowed to be bigger than endTime -> this allows setting a summerPeriod that extends into a new year
// - summerPeriod is not allowed to overlap with any of the configured holidayPeriods, if they are enabled
type HelperSummerPeriod struct {
	// Enabled - enable the summerPeriod
	// - disabling the summerPeriod will delete startTime and endTime
	// - when enabling startTime and endTime are mandatory
	Enabled   bool                                 `json:"enabled"`
	EndTime   *HelperSummerPeriodRelativeTimestamp `json:"endTime,omitempty"`
	StartTime *HelperSummerPeriodRelativeTimestamp `json:"startTime,omitempty"`
}

// HelperSummerPeriodRelativeTimestamp - minutes since beginning of year
// - timestamp is only valid if set to the day (hence multipleOf 1440)
// - leap year (29th February) is always included
// - endTime is used for setting the day, the period will be active until the end of the day
// - 0       -> 1st  January (day change from 31st December to 1st January 00:00 o'clock)
// - 525600  -> 31st December 23:00 o'clock
type HelperSummerPeriodRelativeTimestamp = int

// HelperSwitchDuration choose whether switching of unit should be permanent or toggle back after configured time
type HelperSwitchDuration struct {
	// Mode when choosing toggleBack mode, toggleBackTime is required
	Mode HelperSwitchDurationMode `json:"mode"`

	// ToggleBackTime time in minutes
	ToggleBackTime *int `json:"toggleBackTime,omitempty"`
}

// HelperSwitchDurationMode when choosing toggleBack mode, toggleBackTime is required
type HelperSwitchDurationMode string

// HelperSwitchDurationWithSensor choose whether switching of unit should be permanent, toggle back after configured time or determined by the sensor
type HelperSwitchDurationWithSensor struct {
	// Mode when choosing toggleBack mode, toggleBackTime is required
	Mode HelperSwitchDurationWithSensorMode `json:"mode"`

	// ToggleBackTime time in minutes
	ToggleBackTime *int `json:"toggleBackTime,omitempty"`
}

// HelperSwitchDurationWithSensorMode when choosing toggleBack mode, toggleBackTime is required
type HelperSwitchDurationWithSensorMode string

// HelperTemperature Helper object for getting/setting temperature on a thermostat
type HelperTemperature struct {
	// Celsius Only valid if 'mode' is set to temperature
	Celsius *float32              `json:"celsius,omitempty"`
	Mode    HelperTemperatureMode `json:"mode"`
}

// HelperTemperatureMode defines model for HelperTemperature.Mode.
type HelperTemperatureMode string

// HelperTemperatureChange Helper object for getting/setting temperature on a thermostat
type HelperTemperatureChange = HelperTemperature

// HelperTemperatureRangeLock Setpoint Temperature Range Lock
type HelperTemperatureRangeLock struct {
	// Maximum Maximum temperature
	Maximum *HelperTemperature `json:"maximum,omitempty"`

	// Minimum Minimum temperature
	Minimum *HelperTemperature `json:"minimum,omitempty"`
}

// HelperTemperatureThreshold defines model for helper_temperatureThreshold.
type HelperTemperatureThreshold = float32

// HelperTemplate - groups template info
// - templates are mostly used for saving and applying states of units
// - when creating a new template either the interfaces-object or timer-object is required
type HelperTemplate struct {
	// MemberUnitUids - UIDs of assigned member Units or Triggers
	// - if the list is empty -> no members assigned
	// - trigger templates *always* need at least one assigned trigger
	MemberUnitUids *[]string `json:"memberUnitUids,omitempty"`
}

// HelperTemplateIsAutoCreated Info whether the template was automatically created for a preset-scenario. Auto-Created displays should not be displayed.
type HelperTemplateIsAutoCreated = bool

// HelperTemplateMemberType type of template members
// | memberType                          | Description
// | ------------------------------------| ----------------------------------------------------
// | `onOff`                             | plugsockets and lamps
// | `blind`                             | blinds
// | `thermostat`                        | thermostats
// | `trigger`                           | triggers (trigger templates always need at least one<br>triggerUid assigned )
// | `none`                              | all applyTypes, which do not have members
// | `unknown`                           | error state (this might occur shortly after a reboot)
type HelperTemplateMemberType string

// HelperTemplateTimer defines model for helper_template_timer.
type HelperTemplateTimer struct {
	// Astronomic - astronomical timer based on geographical position
	// - unit can be controlled based on sunrise and sunset
	Astronomic *HelperBaseTimerAstronomicWithActions `json:"astronomic,omitempty"`

	// Countdown - automatically turn the unit off or on after a configured time
	// - turnOff countdown is triggered by turning the unit on
	// - turnOn countdown is triggered by turning the unit off
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Countdown *HelperBaseTimerCountdown `json:"countdown,omitempty"`

	// Daily - when setting an action in a daily timer, a subsequent action always needs to differ (e.g. different action or value) to the previous one
	// - daylight saving time (winter- & summertime) is handled automatically by the backend and should not be handled by the client
	Daily *HelperBaseTimerDaily `json:"daily,omitempty"`

	// Once - turn the unit on or off at a specific time once
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Once *HelperBaseTimerOnce `json:"once,omitempty"`

	// Random - random toggling of unit in the provided active period (startDate to endDate)
	// - further restrict the time of day with startTimePerDay and endTimePerDay
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Random *HelperBaseTimerRandom `json:"random,omitempty"`

	// Rhythmic - rhythmically turn the unit on and off
	// - time to stay turned on and off are configurably seperately
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Rhythmic *HelperBaseTimerRhythmic `json:"rhythmic,omitempty"`

	// SunSimulationMode - activate the sun simulation mode for lamps
	// - when a lamp is turned on via a timer, the lamp slowly increases/decreases its color and or level over the course of 15 minutes, if `both`, `sunrise` or `sunset` is chosen
	// - for starting via the timer the current level of the lamp will be used as a starting point
	// - additionally you can start the sunrise/sunset once, when applying the template
	// - for starting the sunrise/sunset once, the lamp will revert to 0/100 % and it's respective color
	SunSimulationMode *HelperTemplateTimerSunSimulationMode `json:"sunSimulationMode,omitempty"`

	// TimerMode - for thermostats only *disabled* and *weekly* are allowed
	// - for thermostats deleting the timer will allow for full manual control
	// - templates unfortunately do not allow keeping the configuration of the last used timer
	// - this means, when activating a timerMode, the corresponding configuration is always mandatory
	TimerMode *HelperTemplateTimerTimerMode `json:"timerMode,omitempty"`

	// Weekly - when setting an action in a weekly timer, a subsequent action always needs to differ (e.g. different action or value) to the previous one
	// - daylight saving time (winter- & summertime) is handled automatically by the backend and should not be handled by the client
	Weekly *HelperBaseTimerWeekly `json:"weekly,omitempty"`
}

// HelperTemplateTimerSunSimulationMode - activate the sun simulation mode for lamps
// - when a lamp is turned on via a timer, the lamp slowly increases/decreases its color and or level over the course of 15 minutes, if `both`, `sunrise` or `sunset` is chosen
// - for starting via the timer the current level of the lamp will be used as a starting point
// - additionally you can start the sunrise/sunset once, when applying the template
// - for starting the sunrise/sunset once, the lamp will revert to 0/100 % and it's respective color
type HelperTemplateTimerSunSimulationMode string

// HelperTemplateTimerTimerMode - for thermostats only *disabled* and *weekly* are allowed
// - for thermostats deleting the timer will allow for full manual control
// - templates unfortunately do not allow keeping the configuration of the last used timer
// - this means, when activating a timerMode, the corresponding configuration is always mandatory
type HelperTemplateTimerTimerMode string

// HelperTemplateWithAutoCreatedAndMemberType defines model for helper_template_with_autoCreated_and_memberType.
type HelperTemplateWithAutoCreatedAndMemberType struct {
	IsAutoCreated *HelperTemplateIsAutoCreated `json:"isAutoCreated,omitempty"`
	MemberType    *HelperTemplateMemberType    `json:"memberType,omitempty"`

	// MemberUnitUids - UIDs of assigned member Units or Triggers
	// - if the list is empty -> no members assigned
	// - trigger templates *always* need at least one assigned trigger
	MemberUnitUids *[]string `json:"memberUnitUids,omitempty"`
}

// HelperTimerActionsList defines model for helper_timer_actions_list.
type HelperTimerActionsList struct {
	// ColorTemperature (TBD FEATURE)
	ColorTemperature *ActionColorTemperature `json:"colorTemperature,omitempty"`

	// HsColor (TBD FEATURE)
	HsColor *ActionHsColor `json:"hsColor,omitempty"`

	// Level (TBD FEATURE)
	Level *ActionLevel `json:"level,omitempty"`
}

// HelperTimestamp helper for unix timestamps, *null* means time is unknown (e.g. because FRITZ!Box has no valid time)
type HelperTimestamp = int

// HelperUnitTimer defines model for helper_unit_timer.
type HelperUnitTimer struct {
	// Astronomic - astronomical timer based on geographical position
	// - unit can be controlled based on sunrise and sunset
	Astronomic *HelperBaseTimerAstronomicWithActions `json:"astronomic,omitempty"`

	// Calendar - allows the use of a google calendar for automations
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Calendar *HelperBaseTimerCalendar `json:"calendar,omitempty"`

	// Countdown - automatically turn the unit off or on after a configured time
	// - turnOff countdown is triggered by turning the unit on
	// - turnOn countdown is triggered by turning the unit off
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Countdown *HelperBaseTimerCountdown `json:"countdown,omitempty"`

	// Daily - when setting an action in a daily timer, a subsequent action always needs to differ (e.g. different action or value) to the previous one
	// - daylight saving time (winter- & summertime) is handled automatically by the backend and should not be handled by the client
	Daily *HelperBaseTimerDaily `json:"daily,omitempty"`

	// GroupTemperatureWeekly - only availabe for groupUnits which have a memberUnit from the plugSocket-category
	// - allows for combining an external temperature sensor with a group of switches to control either electric heating or air conditioning via a plug socket
	GroupTemperatureWeekly *HelperBaseTimerGroupTemperatureWeekly `json:"groupTemperatureWeekly,omitempty"`

	// Once - turn the unit on or off at a specific time once
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Once *HelperBaseTimerOnce `json:"once,omitempty"`

	// Random - random toggling of unit in the provided active period (startDate to endDate)
	// - further restrict the time of day with startTimePerDay and endTimePerDay
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Random *HelperBaseTimerRandom `json:"random,omitempty"`

	// Rhythmic - rhythmically turn the unit on and off
	// - time to stay turned on and off are configurably seperately
	// - (TBD) optionally you can set the level and/or color when the unit turns on
	Rhythmic *HelperBaseTimerRhythmic `json:"rhythmic,omitempty"`

	// SunSimulationMode - activate the sun simulation mode for lamps
	// - when a lamp is turned on via a timer, the lamp slowly increases/decreases its color and or level over the course of 15 minutes
	// - the current level of the lamp will be used as a starting point
	SunSimulationMode *HelperUnitTimerSunSimulationMode `json:"sunSimulationMode,omitempty"`

	// TimerMode - for thermostats only *disabled* and *weekly* are allowed
	// - for thermostats disabling the timer will allow for full manual control
	TimerMode *HelperUnitTimerTimerMode `json:"timerMode,omitempty"`

	// Weekly - when setting an action in a weekly timer, a subsequent action always needs to differ (e.g. different action or value) to the previous one
	// - daylight saving time (winter- & summertime) is handled automatically by the backend and should not be handled by the client
	Weekly *HelperBaseTimerWeekly `json:"weekly,omitempty"`
}

// HelperUnitTimerSunSimulationMode - activate the sun simulation mode for lamps
// - when a lamp is turned on via a timer, the lamp slowly increases/decreases its color and or level over the course of 15 minutes
// - the current level of the lamp will be used as a starting point
type HelperUnitTimerSunSimulationMode string

// HelperUnitTimerTimerMode - for thermostats only *disabled* and *weekly* are allowed
// - for thermostats disabling the timer will allow for full manual control
type HelperUnitTimerTimerMode string

// HelperWidgetMode - widgets available on screen
// - each widgetMode has a static size, which can not be changed
// | widget mode                   | description                                                                     | widget size
// | ------------------------------|---------------------------------------------------------------------------------|------------
// | `on`                          | turn unit on                                                                    | `quarter`
// | `off`                         | turn unit off                                                                   | `quarter`
// | `toggle`                      | toggles unit on/off                                                             | `quarter`
// | `template`                    | applies a template                                                              | `quarter`
// | `thermostatTemperature`       | controls setpointTemperature of thermostats                                     | `half`
// | `onOff`                       | controls on/off for plugsockets, level of lamps, lamp-groups or mixed groups    | `half`
// | `blindLevel`                  | control level of blinds                                                         | `half`
// | `tamControl`                  | control on/off of telephone answering machine                                   | `half`
// | `hsColorPalette`              | toggle through hsColorPalette for supported lamps                               | `half`
// | `colorTemperaturePalette`     | toggle through colorTemperaturePalette for supported lamps                      | `half`
// | `trigger`                     | control on/off of triggers                                                      | `half`
// | `guestWifi`                   | control on/off of guestWifi, includes QR-Code, no destination                   | `full`
// | `thermostatFull`              | control setpointTemperature, boost and windowOpenMode of supported thermostats  | `full`
// | `mainWifi`                    | control on/off of guestWifi, includes QR-Code                                   | `full`
type HelperWidgetMode string

// HelperWidgetSize widget size on screen
type HelperWidgetSize string

// MultimeterBase functional interface for devices with power-measuring capability, may return value of only one member
type MultimeterBase struct {
	// Current current [mA], resolution: 1 mA
	Current *int `json:"current,omitempty"`

	// Energy - energy [Wh], resolution: 1 Wh
	// - total energy since start of record
	Energy *int `json:"energy,omitempty"`

	// Power power [milliWatts], resolution: 10 mW
	Power *int              `json:"power,omitempty"`
	State StateGenericState `json:"state"`

	// Voltage voltage [mV], resolution: 1 mV
	Voltage *int `json:"voltage,omitempty"`
}

// OnOffBase defines model for onOff_base.
type OnOffBase struct {
	// Active The unit is turned on if true. For FRITZ!Smart Energy plugsockets onOff will only be returned, if the outletState is valid.
	Active      *bool             `json:"active,omitempty"`
	OutletState *StateOutletState `json:"outletState,omitempty"`
	State       StateGenericState `json:"state"`
}

// SmartmeterBase functional interface for devices with smartmeter capability
type SmartmeterBase struct {
	SmartmeterState *StateSmartmeterState `json:"smartmeterState,omitempty"`
	State           StateGenericState     `json:"state"`
}

// StartSubscriptionResponse response for startSubscription
type StartSubscriptionResponse struct {
	// SubscriptionUid UID of started subscription
	SubscriptionUid string `json:"subscriptionUid"`
}

// StateBlindState - blind specific state
// - not available for groupUnits
// - potentially some blinds may not have the option to configure the endpositions via software -> `unknown`
type StateBlindState string

// StateGenericState general info about the state of a device
type StateGenericState string

// StateOutletState FRITZ!Smart Energy plugsocket specific state, not available for other device than Fritz!Smart Energy plugsockets.
type StateOutletState string

// StateSmartmeterState Smartmeter (FSE250) specific state
// | smartmeterState                   | Description
// | ----------------------------------|----------------------------------------------------
// | `reducedResolution`               | electricity meter supplies data with a reduced resolution
// | `noValidData`                     | electricity meter doesn't supply valid data
// | `noData`                          | electricity meter doesn't supply data at all
// | `temporaryNoData`                 | electricity meter supplied data in the past, but not anymore (most probably FSE250 was disconnected from meter)
// | `newMeterDetected`                | new electricity meter detected
// | `scatteredLight`                  | connection to electricity meter is disturbed, FSE250 may not be mounted correctly
type StateSmartmeterState = []string

// StateThermostatState (FRITZ!) thermostat specific state
// | thermostatState                   | Description
// | ----------------------------------|----------------------------------------------------
// | `noError`                         | no error
// | `noAdapt`                         | adaption not possible, is the device mounted correctly?
// | `valveShort`                      | valve stroke too short or batteries weak(manually open and close valve manually or change batteries)
// | `valveMotion`                     | valve cant move, valve tappet free?
// | `valveInstallRun`                 | installation mode is being prepared
// | `valveInstall`                    | thermostat is in installation mode and can be mounted onto the radiator valve
// | `valveAdapt`                      | thermostat is adapting to valve
type StateThermostatState string

// TemperatureBase defines model for temperature_base.
type TemperatureBase struct {
	// Celsius - temperature [C] of device
	// - if a temperature offset is configured (either here on in the thermostatInterface) you may want to display the temperature including the offset for ease of use
	Celsius *float32          `json:"celsius,omitempty"`
	State   StateGenericState `json:"state"`
}

// TemplateBase defines model for template_base.
type TemplateBase struct {
	// UID unique identifier corresponding to UID of template
	UID *string `json:"UID,omitempty"`

	// Ain unique identifier of template
	Ain       *string            `json:"ain,omitempty"`
	ApplyType *TypeApplyTypeList `json:"applyType,omitempty"`

	// Name user defined name of template, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name     *string         `json:"name,omitempty"`
	Scenario *HelperScenario `json:"scenario,omitempty"`
	Template *HelperTemplate `json:"template,omitempty"`
}

// TemplateConfiguration defines model for template_configuration.
type TemplateConfiguration struct {
	// UID unique identifier corresponding to UID of template
	UID *string `json:"UID,omitempty"`

	// Ain unique identifier of template
	Ain       *string            `json:"ain,omitempty"`
	ApplyType *TypeApplyTypeList `json:"applyType,omitempty"`

	// AvailableDestinations contains lists of unit uids that are allowed to be added to the template
	AvailableDestinations *struct {
		BlindLevelUnitUids            *HelperAvailableTemplateBlindLevelUids                `json:"blindLevelUnitUids,omitempty"`
		ColorUnitUids                 *HelperAvailableTemplateColorUnitUids                 `json:"colorUnitUids,omitempty"`
		LampLevelUnitUids             *HelperAvailableTemplateLampLevelUids                 `json:"lampLevelUnitUids,omitempty"`
		OnOffUnitUids                 *HelperAvailableTemplateOnOffUids                     `json:"onOffUnitUids,omitempty"`
		TelephoneAnsweringMachineUids *HelperAvailableTemplateTelephoneAnsweringMachineUids `json:"telephoneAnsweringMachineUids,omitempty"`
		TemplateUids                  *HelperAvailableTemplateTemplateUids                  `json:"templateUids,omitempty"`
		ThermostatUnitUids            *HelperAvailableTemplateThermostatUids                `json:"thermostatUnitUids,omitempty"`
		TriggerUids                   *HelperAvailableTemplateTriggerUids                   `json:"triggerUids,omitempty"`
	} `json:"availableDestinations,omitempty"`

	// DelayTime - delay time in seconds
	// - if set, applying a template will not execute it immediately, but after configured time
	DelayTime *int `json:"delayTime,omitempty"`

	// Name user defined name of template, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed
	Name     *string         `json:"name,omitempty"`
	Scenario *HelperScenario `json:"scenario,omitempty"`
	Template *HelperTemplate `json:"template,omitempty"`
}

// ThermostatBase defines model for thermostat_base.
type ThermostatBase struct {
	// IsAdaptiveRunning Adaptive heating period is active (up to an hour before the comfort temperature timer-configuration). Not available for Comet DECT and FRITZ!DECT 300.
	IsAdaptiveRunning *bool `json:"isAdaptiveRunning,omitempty"`

	// IsHolidayActive Holiday period is active (e.g. thermostat is in freeze protection mode)
	IsHolidayActive *bool `json:"isHolidayActive,omitempty"`

	// IsSummertimeActive Summertime is active (e.g. thermostat is in freeze protection mode)
	IsSummertimeActive *bool             `json:"isSummertimeActive,omitempty"`
	NextChange         *HelperNextChange `json:"nextChange,omitempty"`

	// SetPointTemperature Current setpoint temperature of thermostat
	SetPointTemperature *HelperTemperature    `json:"setPointTemperature,omitempty"`
	State               StateGenericState     `json:"state"`
	ThermostatState     *StateThermostatState `json:"thermostatState,omitempty"`
}

// TypeAlertTypeDefinitions type of alert
type TypeAlertTypeDefinitions string

// TypeApplyTypeDefinitions definitions of the different template apply types
// | applyType                           | number      | Description
// | ------------------------------------| ------------|----------------------------------------------------
// | `thermostatOnOff`                   | 1           | apply summerPeriod configuration to (FRITZ!) thermostat
// | `thermostatTemperature`             | 2           | apply absolute/relative temperature configuration to (FRITZ!) thermostat
// | `thermostatHoliday`                 | 3           | apply holiday configuration to (FRITZ!) thermostat
// | `thermostatTimetable`               | 4           | apply timer configuration to (FRITZ!) thermostat
// | `relayManual`                       | 5           | turn on/off (incl. switchDuration) or toggle onOff unit or trigger
// | `relayAutomatic`                    | 6           | apply timer configuration to onOff unit
// | `level`                             | 7           | apply absolute/relative level to unit (lamp or blind)
// | `color`                             | 8           | apply color to unit (colorTemperature or hsColor lamp)
// | `dialHelper`                        | 9           | calls telephone number
// | `sunSimulation`                     | 10          | apply sunSimulation configuration to lamp
// | `subTemplates`                      | 11          | (scenario) apply child-templates
// | `mainWifi`                          | 12          | turn on/off main wifi (no toggle)
// | `guestWifi`                         | 13          | turn on/off guest wifi (no toggle)
// | `tamControl`                        | 14          | turn on/off telephone answering machine (no toggle)
// | `httpRequest`                       | 15          | send out http-request
// | `timerControl`                      | 16          | apply boost/windowOpen/disable to (FRITZ!) thermostat
// | `switchMaster`                      | 17          | configures onOffMaster-unit of an exisiting onOff-group
// | `customNotification`                | 18          | send out push-mail or app-notification
type TypeApplyTypeDefinitions string

// TypeApplyTypeList applyType list
type TypeApplyTypeList = []TypeApplyTypeList_Item

// TypeApplyTypeList_Item defines model for type_applyTypeList.Item.
type TypeApplyTypeList_Item struct {
	union json.RawMessage
}

// TypeScenarioType types of (pre-defined) scenarios, not present for generic (user created) scenarios
type TypeScenarioType string

// TypeUnitType - definitions of the unit type, not all may be available
// - the unitType indicates which interfaces the unit will have
// - the relation to interfaces is not strict, there could be additional interfaces depending on the implemenation of the device
// | unitType                                    | Description                                                                       | expected interfaces
// | --------------------------------------------|-------------------------------------------------------------------                |------------------------
// | `generic`                                   | generic unit type                                                                 | unknown
// | `avmWidgetButton`                           | unit type for FRITZ! widget buttons (FSC440)                                      | widget, temperature, humidity
// | `avmButton`                                 | unit type for FRITZ! buttons (FSC400)                                             | button
// | `avmPlugSocket`                             | unit type for FRITZ! plug sockets (FSE200/FSE210)                                 | multimeter, onOff, temperature
// | `avmThermostat`                             | unit type for FRITZ! thermostats (Comet/FD300/FST301/FST302)                      | temperature, thermostat
// | `avmMeter`                                  | unit type for FRITZ! smart meters (FSE250 - first unit - supply meter)            | multimeter
// | `avmMeterFeedIn`                            | unit type for FRITZ! smart meters (FSE250 - second unit - feed-in meter)          | multimeter
// | `blindGroup`                                | unit type for group consisting of blinds                                          | blind, levelControl
// | `switchableGroup`                           | unit type for group consisting of lamps and switches                              | onOff (if lamp in group: colorControl, levelControl)
// | `thermostatGroup`                           | unit type for group consisting of thermostats                                     | thermostat
// | `otherGroup`                                | unit type for group consisting of other devices or unknown members                | unknown
// | `simpleOnOffSwitchable`                     | allows a unit to receive and interpret on/off requests<br>this unit will be acting upon some physical *switch* | onOff
// | `simpleLevelControllable`                   | allows a unit to receive and interpret requests for adjustment of some quantity   | levelControl
// | `simpleLevelControllableSwitchable`         | allows a unit to receive and interpret both on/off and level control requests     | onOff, levelControl
// | `acOutlet`                                  | allows a unit to receive and interpret on/off requests<br>this unit will be acting upon some physical AC switch | onOff
// | `acOutletSimplePowerMetering`               | allows a unit to receive and interpret on/off requests<br>this unit will be acting upon some physical AC switch<br>this unit is also able to do and provide simple measurements over electric quantities | onOff
// | `simpleLight`                               | allows a unit to receive and interpret on/off requests<br>this unit will be acting upon some physical Light switch | onOff
// | `dimmableLight`                             | allows a unit to receive and interpret both on/off and level control requests<br>this unit will be acting upon some dimmable light switch | onOff, levelControl
// | `simpleDoorLock`                            | allows a unit to receive and interpret on (lock)/off (unlock) requests<br>this unit will be acting upon some physical Door Lock switch | onOff
// | `simpleDoorBell`                            | allows a unit to send an alert whenever a door bell button is pushed              | alert
// | `simpleTemperatureSensor`                   | allows a unit to provide temperature readings                                     | temperature
// | `simpleHumiditySensor`                      | allows a unit to provide humidity readings                                        | humdity
// | `simpleButton`                              | allows a unit to identify several types of button presses and send notifications when they occur | button
// | `colorBulb`                                 | use for light bulbs that support color changes                                    | onOff, colorControl
// | `dimmableColorBulb`                         | use for light bulbs that support color and light intensity changes.               | onOff, levelControl, colorControl
// | `blind`                                     | use for window blinds                                                             | blind, levelControl
// | `lamellar`                                  | use for window lamellars                                                          | blind, levelControl
// | `simpleDetector`                            | use for a generic detector that senses and sends an alert                         | alert
// | `doorOpenCloseDetector`                     | use for an open/close door detector that senses and sends an alert                | alert
// | `windowOpenCloseDetector`                   | use for an open/close window detector that senses and sends an alert              | alert
// | `motionDetector`                            | use for a motion detector that senses and sends an alert                          | alert
// | `smokeDetector`                             | use for a smoke detector that senses and sends an alert                           | alert
// | `gasDetector`                               | use for a carbon monoxide detector that senses and sends an alert                 | alert
// | `floodDetector`                             | use for a flood detector that senses and sends an alert                           | alert
// | `glassBreakDetector`                        | use for a glass break detector that senses and sends an alert                     | alert
// | `vibrationDetector`                         | use for a vibration detector that senses and sends an alert                       | alert
// | `siren`                                     | allows a unit to receive and interpret on/off requests<br>this unit will be acting upon some physical siren that will sound an alert | onOff
// | `genericApplicationLogic`                   | application logic unit                                                            | unknown
type TypeUnitType string

// UnitBase defines model for unit_base.
type UnitBase struct {
	// UID unique identifier corresponding to ain of unit
	UID *string `json:"UID,omitempty"`

	// Ain unique hardware identifier of unit
	Ain *string `json:"ain,omitempty"`

	// DeviceUid UID of parent Device; if not present: parent is group
	DeviceUid *string `json:"deviceUid,omitempty"`

	// GroupUid - UID of group, if unit is member in a group
	// - if not present the unit has a group as a parent
	// - if present, but not set, the unit is not in a group
	GroupUid *string `json:"groupUid,omitempty"`

	// Icons icon-IDs from Iconlist (TBD), can be empty
	Icons *[]int `json:"icons,omitempty"`

	// IsConnected - false: no connection / connection lost
	// - true: connection established
	// - if the device (and therefore its units) are not connected you may get the last known infos or default values. These may not be valid.
	// - for groupUnits (`isGroupUnit` == true) `isConnected` will be true, if at least one memberUnit of the Group is connected
	IsConnected *bool `json:"isConnected,omitempty"`

	// IsGroupUnit - false: parent is device
	// - true: parent is group
	IsGroupUnit *bool `json:"isGroupUnit,omitempty"`

	// ParentUid UID of parent device or group
	ParentUid *string       `json:"parentUid,omitempty"`
	UnitType  *TypeUnitType `json:"unitType,omitempty"`
}

// UnitNameConfiguration user defined name of funcitonal Unit, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed (may be automatically set through the device name if only 1 unit exists)
type UnitNameConfiguration = string

// UnitNameOverview user defined name of funcitonal Unit, up to 39 2-Byte UTF-8 characters or up to 79 bytes allowed (may be automatically set through the device name if only 1 unit exists)
type UnitNameOverview = string

// Errors defines model for errors.
type Errors = ErrorResponse

// PostConfigurationGroupByNameParams defines parameters for PostConfigurationGroupByName.
type PostConfigurationGroupByNameParams struct {
	// Name name of group that should be created
	Name string `form:"name" json:"name"`
}

// PostConfigurationTemplateByNameParams defines parameters for PostConfigurationTemplateByName.
type PostConfigurationTemplateByNameParams struct {
	// Name name of template that should be created
	Name string `form:"name" json:"name"`
}

// PutConfigurationDeviceByUIDJSONRequestBody defines body for PutConfigurationDeviceByUID for application/json ContentType.
type PutConfigurationDeviceByUIDJSONRequestBody = EndpointConfigurationPutDevice

// PostConfigurationGroupByNameJSONRequestBody defines body for PostConfigurationGroupByName for application/json ContentType.
type PostConfigurationGroupByNameJSONRequestBody = EndpointConfigurationPostGroup

// PutConfigurationGroupByUIDJSONRequestBody defines body for PutConfigurationGroupByUID for application/json ContentType.
type PutConfigurationGroupByUIDJSONRequestBody = EndpointConfigurationPutGroup

// PostConfigurationTemplateByNameJSONRequestBody defines body for PostConfigurationTemplateByName for application/json ContentType.
type PostConfigurationTemplateByNameJSONRequestBody = EndpointConfigurationPostTemplate

// PutConfigurationTemplateByUIDJSONRequestBody defines body for PutConfigurationTemplateByUID for application/json ContentType.
type PutConfigurationTemplateByUIDJSONRequestBody = EndpointConfigurationPutTemplate

// PutConfigurationUnitByUIDJSONRequestBody defines body for PutConfigurationUnitByUID for application/json ContentType.
type PutConfigurationUnitByUIDJSONRequestBody = EndpointConfigurationPutUnit

// PostInstallCodeBySerialJSONRequestBody defines body for PostInstallCodeBySerial for application/json ContentType.
type PostInstallCodeBySerialJSONRequestBody = EndpointInstallCode

// PostResetCodeBySerialJSONRequestBody defines body for PostResetCodeBySerial for application/json ContentType.
type PostResetCodeBySerialJSONRequestBody = EndpointResetCode

// PostStartSubscriptionBySerialJSONRequestBody defines body for PostStartSubscriptionBySerial for application/json ContentType.
type PostStartSubscriptionBySerialJSONRequestBody = EndpointStartSubscription

// PostOverviewTemplateByUIDJSONRequestBody defines body for PostOverviewTemplateByUID for application/json ContentType.
type PostOverviewTemplateByUIDJSONRequestBody = EndpointOverviewPostTemplate

// PutOverviewTriggerByUIDJSONRequestBody defines body for PutOverviewTriggerByUID for application/json ContentType.
type PutOverviewTriggerByUIDJSONRequestBody = EndpointOverviewTrigger

// PutOverviewUnitByUIDJSONRequestBody defines body for PutOverviewUnitByUID for application/json ContentType.
type PutOverviewUnitByUIDJSONRequestBody = EndpointOverviewPutUnit

// AsTypeAlertTypeDefinitions returns the union data inside the IFAlertConfigBase_Alerts_Item as a TypeAlertTypeDefinitions
func (t IFAlertConfigBase_Alerts_Item) AsTypeAlertTypeDefinitions() (TypeAlertTypeDefinitions, error) {
	var body TypeAlertTypeDefinitions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypeAlertTypeDefinitions overwrites any union data inside the IFAlertConfigBase_Alerts_Item as the provided TypeAlertTypeDefinitions
func (t *IFAlertConfigBase_Alerts_Item) FromTypeAlertTypeDefinitions(v TypeAlertTypeDefinitions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypeAlertTypeDefinitions performs a merge with any union data inside the IFAlertConfigBase_Alerts_Item, using the provided TypeAlertTypeDefinitions
func (t *IFAlertConfigBase_Alerts_Item) MergeTypeAlertTypeDefinitions(v TypeAlertTypeDefinitions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IFAlertConfigBase_Alerts_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IFAlertConfigBase_Alerts_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTypeAlertTypeDefinitions returns the union data inside the IFAlertConfigUnits_Alerts_Item as a TypeAlertTypeDefinitions
func (t IFAlertConfigUnits_Alerts_Item) AsTypeAlertTypeDefinitions() (TypeAlertTypeDefinitions, error) {
	var body TypeAlertTypeDefinitions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypeAlertTypeDefinitions overwrites any union data inside the IFAlertConfigUnits_Alerts_Item as the provided TypeAlertTypeDefinitions
func (t *IFAlertConfigUnits_Alerts_Item) FromTypeAlertTypeDefinitions(v TypeAlertTypeDefinitions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypeAlertTypeDefinitions performs a merge with any union data inside the IFAlertConfigUnits_Alerts_Item, using the provided TypeAlertTypeDefinitions
func (t *IFAlertConfigUnits_Alerts_Item) MergeTypeAlertTypeDefinitions(v TypeAlertTypeDefinitions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IFAlertConfigUnits_Alerts_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IFAlertConfigUnits_Alerts_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTypeAlertTypeDefinitions returns the union data inside the IFAlertOverview_Alerts_Item as a TypeAlertTypeDefinitions
func (t IFAlertOverview_Alerts_Item) AsTypeAlertTypeDefinitions() (TypeAlertTypeDefinitions, error) {
	var body TypeAlertTypeDefinitions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypeAlertTypeDefinitions overwrites any union data inside the IFAlertOverview_Alerts_Item as the provided TypeAlertTypeDefinitions
func (t *IFAlertOverview_Alerts_Item) FromTypeAlertTypeDefinitions(v TypeAlertTypeDefinitions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypeAlertTypeDefinitions performs a merge with any union data inside the IFAlertOverview_Alerts_Item, using the provided TypeAlertTypeDefinitions
func (t *IFAlertOverview_Alerts_Item) MergeTypeAlertTypeDefinitions(v TypeAlertTypeDefinitions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IFAlertOverview_Alerts_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IFAlertOverview_Alerts_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTypeAlertTypeDefinitions returns the union data inside the AlertBase_Alerts_Item as a TypeAlertTypeDefinitions
func (t AlertBase_Alerts_Item) AsTypeAlertTypeDefinitions() (TypeAlertTypeDefinitions, error) {
	var body TypeAlertTypeDefinitions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypeAlertTypeDefinitions overwrites any union data inside the AlertBase_Alerts_Item as the provided TypeAlertTypeDefinitions
func (t *AlertBase_Alerts_Item) FromTypeAlertTypeDefinitions(v TypeAlertTypeDefinitions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypeAlertTypeDefinitions performs a merge with any union data inside the AlertBase_Alerts_Item, using the provided TypeAlertTypeDefinitions
func (t *AlertBase_Alerts_Item) MergeTypeAlertTypeDefinitions(v TypeAlertTypeDefinitions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AlertBase_Alerts_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AlertBase_Alerts_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTypeApplyTypeDefinitions returns the union data inside the TypeApplyTypeList_Item as a TypeApplyTypeDefinitions
func (t TypeApplyTypeList_Item) AsTypeApplyTypeDefinitions() (TypeApplyTypeDefinitions, error) {
	var body TypeApplyTypeDefinitions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTypeApplyTypeDefinitions overwrites any union data inside the TypeApplyTypeList_Item as the provided TypeApplyTypeDefinitions
func (t *TypeApplyTypeList_Item) FromTypeApplyTypeDefinitions(v TypeApplyTypeDefinitions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTypeApplyTypeDefinitions performs a merge with any union data inside the TypeApplyTypeList_Item, using the provided TypeApplyTypeDefinitions
func (t *TypeApplyTypeList_Item) MergeTypeApplyTypeDefinitions(v TypeApplyTypeDefinitions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TypeApplyTypeList_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TypeApplyTypeList_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteConfigurationDeviceByUID request
	DeleteConfigurationDeviceByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationDeviceByUID request
	GetConfigurationDeviceByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutConfigurationDeviceByUIDWithBody request with any body
	PutConfigurationDeviceByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutConfigurationDeviceByUID(ctx context.Context, uid string, body PutConfigurationDeviceByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostConfigurationGroupByNameWithBody request with any body
	PostConfigurationGroupByNameWithBody(ctx context.Context, params *PostConfigurationGroupByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostConfigurationGroupByName(ctx context.Context, params *PostConfigurationGroupByNameParams, body PostConfigurationGroupByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConfigurationGroupByUID request
	DeleteConfigurationGroupByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationGroupByUID request
	GetConfigurationGroupByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutConfigurationGroupByUIDWithBody request with any body
	PutConfigurationGroupByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutConfigurationGroupByUID(ctx context.Context, uid string, body PutConfigurationGroupByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationTemplateCapabilities request
	GetConfigurationTemplateCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostConfigurationTemplateByNameWithBody request with any body
	PostConfigurationTemplateByNameWithBody(ctx context.Context, params *PostConfigurationTemplateByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostConfigurationTemplateByName(ctx context.Context, params *PostConfigurationTemplateByNameParams, body PostConfigurationTemplateByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConfigurationTemplateByUID request
	DeleteConfigurationTemplateByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationTemplateByUID request
	GetConfigurationTemplateByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutConfigurationTemplateByUIDWithBody request with any body
	PutConfigurationTemplateByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutConfigurationTemplateByUID(ctx context.Context, uid string, body PutConfigurationTemplateByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationUnitByUID request
	GetConfigurationUnitByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutConfigurationUnitByUIDWithBody request with any body
	PutConfigurationUnitByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutConfigurationUnitByUID(ctx context.Context, uid string, body PutConfigurationUnitByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInstallCodeBySerialWithBody request with any body
	PostInstallCodeBySerialWithBody(ctx context.Context, serial string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInstallCodeBySerial(ctx context.Context, serial string, body PostInstallCodeBySerialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRadioBasesList request
	GetRadioBasesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRadioBaseBySerial request
	GetRadioBaseBySerial(ctx context.Context, serial string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostResetCodeBySerialWithBody request with any body
	PostResetCodeBySerialWithBody(ctx context.Context, serial string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostResetCodeBySerial(ctx context.Context, serial string, body PostResetCodeBySerialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStartSubscriptionBySerialWithBody request with any body
	PostStartSubscriptionBySerialWithBody(ctx context.Context, serial string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStartSubscriptionBySerial(ctx context.Context, serial string, body PostStartSubscriptionBySerialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStopSubscriptionBySerial request
	PostStopSubscriptionBySerial(ctx context.Context, serial string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionStateByUid request
	GetSubscriptionStateByUid(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOverview request
	GetOverview(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOverviewDevicesList request
	GetOverviewDevicesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOverviewDeviceByUID request
	GetOverviewDeviceByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOverviewGlobals request
	GetOverviewGlobals(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOverviewGroupsList request
	GetOverviewGroupsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOverviewGroupByUID request
	GetOverviewGroupByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOverviewTemplatesList request
	GetOverviewTemplatesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOverviewTemplateByUID request
	GetOverviewTemplateByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOverviewTemplateByUIDWithBody request with any body
	PostOverviewTemplateByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOverviewTemplateByUID(ctx context.Context, uid string, body PostOverviewTemplateByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOverviewTriggersList request
	GetOverviewTriggersList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOverviewTriggerByUID request
	GetOverviewTriggerByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutOverviewTriggerByUIDWithBody request with any body
	PutOverviewTriggerByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutOverviewTriggerByUID(ctx context.Context, uid string, body PutOverviewTriggerByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOverviewUnitsList request
	GetOverviewUnitsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOverviewUnitByUID request
	GetOverviewUnitByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutOverviewUnitByUIDWithBody request with any body
	PutOverviewUnitByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutOverviewUnitByUID(ctx context.Context, uid string, body PutOverviewUnitByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteConfigurationDeviceByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConfigurationDeviceByUIDRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationDeviceByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationDeviceByUIDRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutConfigurationDeviceByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutConfigurationDeviceByUIDRequestWithBody(c.Server, uid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutConfigurationDeviceByUID(ctx context.Context, uid string, body PutConfigurationDeviceByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutConfigurationDeviceByUIDRequest(c.Server, uid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostConfigurationGroupByNameWithBody(ctx context.Context, params *PostConfigurationGroupByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostConfigurationGroupByNameRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostConfigurationGroupByName(ctx context.Context, params *PostConfigurationGroupByNameParams, body PostConfigurationGroupByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostConfigurationGroupByNameRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConfigurationGroupByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConfigurationGroupByUIDRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationGroupByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationGroupByUIDRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutConfigurationGroupByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutConfigurationGroupByUIDRequestWithBody(c.Server, uid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutConfigurationGroupByUID(ctx context.Context, uid string, body PutConfigurationGroupByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutConfigurationGroupByUIDRequest(c.Server, uid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationTemplateCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationTemplateCapabilitiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostConfigurationTemplateByNameWithBody(ctx context.Context, params *PostConfigurationTemplateByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostConfigurationTemplateByNameRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostConfigurationTemplateByName(ctx context.Context, params *PostConfigurationTemplateByNameParams, body PostConfigurationTemplateByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostConfigurationTemplateByNameRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConfigurationTemplateByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConfigurationTemplateByUIDRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationTemplateByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationTemplateByUIDRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutConfigurationTemplateByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutConfigurationTemplateByUIDRequestWithBody(c.Server, uid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutConfigurationTemplateByUID(ctx context.Context, uid string, body PutConfigurationTemplateByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutConfigurationTemplateByUIDRequest(c.Server, uid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationUnitByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationUnitByUIDRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutConfigurationUnitByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutConfigurationUnitByUIDRequestWithBody(c.Server, uid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutConfigurationUnitByUID(ctx context.Context, uid string, body PutConfigurationUnitByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutConfigurationUnitByUIDRequest(c.Server, uid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInstallCodeBySerialWithBody(ctx context.Context, serial string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInstallCodeBySerialRequestWithBody(c.Server, serial, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInstallCodeBySerial(ctx context.Context, serial string, body PostInstallCodeBySerialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInstallCodeBySerialRequest(c.Server, serial, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRadioBasesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRadioBasesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRadioBaseBySerial(ctx context.Context, serial string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRadioBaseBySerialRequest(c.Server, serial)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostResetCodeBySerialWithBody(ctx context.Context, serial string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostResetCodeBySerialRequestWithBody(c.Server, serial, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostResetCodeBySerial(ctx context.Context, serial string, body PostResetCodeBySerialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostResetCodeBySerialRequest(c.Server, serial, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStartSubscriptionBySerialWithBody(ctx context.Context, serial string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStartSubscriptionBySerialRequestWithBody(c.Server, serial, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStartSubscriptionBySerial(ctx context.Context, serial string, body PostStartSubscriptionBySerialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStartSubscriptionBySerialRequest(c.Server, serial, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStopSubscriptionBySerial(ctx context.Context, serial string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStopSubscriptionBySerialRequest(c.Server, serial)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionStateByUid(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionStateByUidRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOverview(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOverviewRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOverviewDevicesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOverviewDevicesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOverviewDeviceByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOverviewDeviceByUIDRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOverviewGlobals(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOverviewGlobalsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOverviewGroupsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOverviewGroupsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOverviewGroupByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOverviewGroupByUIDRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOverviewTemplatesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOverviewTemplatesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOverviewTemplateByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOverviewTemplateByUIDRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOverviewTemplateByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOverviewTemplateByUIDRequestWithBody(c.Server, uid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOverviewTemplateByUID(ctx context.Context, uid string, body PostOverviewTemplateByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOverviewTemplateByUIDRequest(c.Server, uid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOverviewTriggersList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOverviewTriggersListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOverviewTriggerByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOverviewTriggerByUIDRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutOverviewTriggerByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutOverviewTriggerByUIDRequestWithBody(c.Server, uid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutOverviewTriggerByUID(ctx context.Context, uid string, body PutOverviewTriggerByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutOverviewTriggerByUIDRequest(c.Server, uid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOverviewUnitsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOverviewUnitsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOverviewUnitByUID(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOverviewUnitByUIDRequest(c.Server, uid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutOverviewUnitByUIDWithBody(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutOverviewUnitByUIDRequestWithBody(c.Server, uid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutOverviewUnitByUID(ctx context.Context, uid string, body PutOverviewUnitByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutOverviewUnitByUIDRequest(c.Server, uid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteConfigurationDeviceByUIDRequest generates requests for DeleteConfigurationDeviceByUID
func NewDeleteConfigurationDeviceByUIDRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationDeviceByUIDRequest generates requests for GetConfigurationDeviceByUID
func NewGetConfigurationDeviceByUIDRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutConfigurationDeviceByUIDRequest calls the generic PutConfigurationDeviceByUID builder with application/json body
func NewPutConfigurationDeviceByUIDRequest(server string, uid string, body PutConfigurationDeviceByUIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutConfigurationDeviceByUIDRequestWithBody(server, uid, "application/json", bodyReader)
}

// NewPutConfigurationDeviceByUIDRequestWithBody generates requests for PutConfigurationDeviceByUID with any type of body
func NewPutConfigurationDeviceByUIDRequestWithBody(server string, uid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostConfigurationGroupByNameRequest calls the generic PostConfigurationGroupByName builder with application/json body
func NewPostConfigurationGroupByNameRequest(server string, params *PostConfigurationGroupByNameParams, body PostConfigurationGroupByNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostConfigurationGroupByNameRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostConfigurationGroupByNameRequestWithBody generates requests for PostConfigurationGroupByName with any type of body
func NewPostConfigurationGroupByNameRequestWithBody(server string, params *PostConfigurationGroupByNameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteConfigurationGroupByUIDRequest generates requests for DeleteConfigurationGroupByUID
func NewDeleteConfigurationGroupByUIDRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationGroupByUIDRequest generates requests for GetConfigurationGroupByUID
func NewGetConfigurationGroupByUIDRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutConfigurationGroupByUIDRequest calls the generic PutConfigurationGroupByUID builder with application/json body
func NewPutConfigurationGroupByUIDRequest(server string, uid string, body PutConfigurationGroupByUIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutConfigurationGroupByUIDRequestWithBody(server, uid, "application/json", bodyReader)
}

// NewPutConfigurationGroupByUIDRequestWithBody generates requests for PutConfigurationGroupByUID with any type of body
func NewPutConfigurationGroupByUIDRequestWithBody(server string, uid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConfigurationTemplateCapabilitiesRequest generates requests for GetConfigurationTemplateCapabilities
func NewGetConfigurationTemplateCapabilitiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/templateCapabilities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostConfigurationTemplateByNameRequest calls the generic PostConfigurationTemplateByName builder with application/json body
func NewPostConfigurationTemplateByNameRequest(server string, params *PostConfigurationTemplateByNameParams, body PostConfigurationTemplateByNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostConfigurationTemplateByNameRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostConfigurationTemplateByNameRequestWithBody generates requests for PostConfigurationTemplateByName with any type of body
func NewPostConfigurationTemplateByNameRequestWithBody(server string, params *PostConfigurationTemplateByNameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteConfigurationTemplateByUIDRequest generates requests for DeleteConfigurationTemplateByUID
func NewDeleteConfigurationTemplateByUIDRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationTemplateByUIDRequest generates requests for GetConfigurationTemplateByUID
func NewGetConfigurationTemplateByUIDRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutConfigurationTemplateByUIDRequest calls the generic PutConfigurationTemplateByUID builder with application/json body
func NewPutConfigurationTemplateByUIDRequest(server string, uid string, body PutConfigurationTemplateByUIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutConfigurationTemplateByUIDRequestWithBody(server, uid, "application/json", bodyReader)
}

// NewPutConfigurationTemplateByUIDRequestWithBody generates requests for PutConfigurationTemplateByUID with any type of body
func NewPutConfigurationTemplateByUIDRequestWithBody(server string, uid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConfigurationUnitByUIDRequest generates requests for GetConfigurationUnitByUID
func NewGetConfigurationUnitByUIDRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/units/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutConfigurationUnitByUIDRequest calls the generic PutConfigurationUnitByUID builder with application/json body
func NewPutConfigurationUnitByUIDRequest(server string, uid string, body PutConfigurationUnitByUIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutConfigurationUnitByUIDRequestWithBody(server, uid, "application/json", bodyReader)
}

// NewPutConfigurationUnitByUIDRequestWithBody generates requests for PutConfigurationUnitByUID with any type of body
func NewPutConfigurationUnitByUIDRequestWithBody(server string, uid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/configuration/units/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostInstallCodeBySerialRequest calls the generic PostInstallCodeBySerial builder with application/json body
func NewPostInstallCodeBySerialRequest(server string, serial string, body PostInstallCodeBySerialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInstallCodeBySerialRequestWithBody(server, serial, "application/json", bodyReader)
}

// NewPostInstallCodeBySerialRequestWithBody generates requests for PostInstallCodeBySerial with any type of body
func NewPostInstallCodeBySerialRequestWithBody(server string, serial string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serial", runtime.ParamLocationPath, serial)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/connect/installCode/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRadioBasesListRequest generates requests for GetRadioBasesList
func NewGetRadioBasesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/connect/radioBases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRadioBaseBySerialRequest generates requests for GetRadioBaseBySerial
func NewGetRadioBaseBySerialRequest(server string, serial string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serial", runtime.ParamLocationPath, serial)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/connect/radioBases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostResetCodeBySerialRequest calls the generic PostResetCodeBySerial builder with application/json body
func NewPostResetCodeBySerialRequest(server string, serial string, body PostResetCodeBySerialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostResetCodeBySerialRequestWithBody(server, serial, "application/json", bodyReader)
}

// NewPostResetCodeBySerialRequestWithBody generates requests for PostResetCodeBySerial with any type of body
func NewPostResetCodeBySerialRequestWithBody(server string, serial string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serial", runtime.ParamLocationPath, serial)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/connect/resetCode/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStartSubscriptionBySerialRequest calls the generic PostStartSubscriptionBySerial builder with application/json body
func NewPostStartSubscriptionBySerialRequest(server string, serial string, body PostStartSubscriptionBySerialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStartSubscriptionBySerialRequestWithBody(server, serial, "application/json", bodyReader)
}

// NewPostStartSubscriptionBySerialRequestWithBody generates requests for PostStartSubscriptionBySerial with any type of body
func NewPostStartSubscriptionBySerialRequestWithBody(server string, serial string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serial", runtime.ParamLocationPath, serial)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/connect/startSubscription/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStopSubscriptionBySerialRequest generates requests for PostStopSubscriptionBySerial
func NewPostStopSubscriptionBySerialRequest(server string, serial string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serial", runtime.ParamLocationPath, serial)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/connect/stopSubscription/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionStateByUidRequest generates requests for GetSubscriptionStateByUid
func NewGetSubscriptionStateByUidRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/connect/subscriptionState/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOverviewRequest generates requests for GetOverview
func NewGetOverviewRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOverviewDevicesListRequest generates requests for GetOverviewDevicesList
func NewGetOverviewDevicesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/devices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOverviewDeviceByUIDRequest generates requests for GetOverviewDeviceByUID
func NewGetOverviewDeviceByUIDRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/devices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOverviewGlobalsRequest generates requests for GetOverviewGlobals
func NewGetOverviewGlobalsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/globals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOverviewGroupsListRequest generates requests for GetOverviewGroupsList
func NewGetOverviewGroupsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOverviewGroupByUIDRequest generates requests for GetOverviewGroupByUID
func NewGetOverviewGroupByUIDRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOverviewTemplatesListRequest generates requests for GetOverviewTemplatesList
func NewGetOverviewTemplatesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOverviewTemplateByUIDRequest generates requests for GetOverviewTemplateByUID
func NewGetOverviewTemplateByUIDRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOverviewTemplateByUIDRequest calls the generic PostOverviewTemplateByUID builder with application/json body
func NewPostOverviewTemplateByUIDRequest(server string, uid string, body PostOverviewTemplateByUIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOverviewTemplateByUIDRequestWithBody(server, uid, "application/json", bodyReader)
}

// NewPostOverviewTemplateByUIDRequestWithBody generates requests for PostOverviewTemplateByUID with any type of body
func NewPostOverviewTemplateByUIDRequestWithBody(server string, uid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOverviewTriggersListRequest generates requests for GetOverviewTriggersList
func NewGetOverviewTriggersListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/triggers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOverviewTriggerByUIDRequest generates requests for GetOverviewTriggerByUID
func NewGetOverviewTriggerByUIDRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/triggers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutOverviewTriggerByUIDRequest calls the generic PutOverviewTriggerByUID builder with application/json body
func NewPutOverviewTriggerByUIDRequest(server string, uid string, body PutOverviewTriggerByUIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutOverviewTriggerByUIDRequestWithBody(server, uid, "application/json", bodyReader)
}

// NewPutOverviewTriggerByUIDRequestWithBody generates requests for PutOverviewTriggerByUID with any type of body
func NewPutOverviewTriggerByUIDRequestWithBody(server string, uid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/triggers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOverviewUnitsListRequest generates requests for GetOverviewUnitsList
func NewGetOverviewUnitsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/units")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOverviewUnitByUIDRequest generates requests for GetOverviewUnitByUID
func NewGetOverviewUnitByUIDRequest(server string, uid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/units/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutOverviewUnitByUIDRequest calls the generic PutOverviewUnitByUID builder with application/json body
func NewPutOverviewUnitByUIDRequest(server string, uid string, body PutOverviewUnitByUIDJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutOverviewUnitByUIDRequestWithBody(server, uid, "application/json", bodyReader)
}

// NewPutOverviewUnitByUIDRequestWithBody generates requests for PutOverviewUnitByUID with any type of body
func NewPutOverviewUnitByUIDRequestWithBody(server string, uid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "UID", runtime.ParamLocationPath, uid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/smarthome/overview/units/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteConfigurationDeviceByUIDWithResponse request
	DeleteConfigurationDeviceByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*DeleteConfigurationDeviceByUIDResponse, error)

	// GetConfigurationDeviceByUIDWithResponse request
	GetConfigurationDeviceByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetConfigurationDeviceByUIDResponse, error)

	// PutConfigurationDeviceByUIDWithBodyWithResponse request with any body
	PutConfigurationDeviceByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutConfigurationDeviceByUIDResponse, error)

	PutConfigurationDeviceByUIDWithResponse(ctx context.Context, uid string, body PutConfigurationDeviceByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutConfigurationDeviceByUIDResponse, error)

	// PostConfigurationGroupByNameWithBodyWithResponse request with any body
	PostConfigurationGroupByNameWithBodyWithResponse(ctx context.Context, params *PostConfigurationGroupByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostConfigurationGroupByNameResponse, error)

	PostConfigurationGroupByNameWithResponse(ctx context.Context, params *PostConfigurationGroupByNameParams, body PostConfigurationGroupByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostConfigurationGroupByNameResponse, error)

	// DeleteConfigurationGroupByUIDWithResponse request
	DeleteConfigurationGroupByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*DeleteConfigurationGroupByUIDResponse, error)

	// GetConfigurationGroupByUIDWithResponse request
	GetConfigurationGroupByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetConfigurationGroupByUIDResponse, error)

	// PutConfigurationGroupByUIDWithBodyWithResponse request with any body
	PutConfigurationGroupByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutConfigurationGroupByUIDResponse, error)

	PutConfigurationGroupByUIDWithResponse(ctx context.Context, uid string, body PutConfigurationGroupByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutConfigurationGroupByUIDResponse, error)

	// GetConfigurationTemplateCapabilitiesWithResponse request
	GetConfigurationTemplateCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationTemplateCapabilitiesResponse, error)

	// PostConfigurationTemplateByNameWithBodyWithResponse request with any body
	PostConfigurationTemplateByNameWithBodyWithResponse(ctx context.Context, params *PostConfigurationTemplateByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostConfigurationTemplateByNameResponse, error)

	PostConfigurationTemplateByNameWithResponse(ctx context.Context, params *PostConfigurationTemplateByNameParams, body PostConfigurationTemplateByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostConfigurationTemplateByNameResponse, error)

	// DeleteConfigurationTemplateByUIDWithResponse request
	DeleteConfigurationTemplateByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*DeleteConfigurationTemplateByUIDResponse, error)

	// GetConfigurationTemplateByUIDWithResponse request
	GetConfigurationTemplateByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetConfigurationTemplateByUIDResponse, error)

	// PutConfigurationTemplateByUIDWithBodyWithResponse request with any body
	PutConfigurationTemplateByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutConfigurationTemplateByUIDResponse, error)

	PutConfigurationTemplateByUIDWithResponse(ctx context.Context, uid string, body PutConfigurationTemplateByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutConfigurationTemplateByUIDResponse, error)

	// GetConfigurationUnitByUIDWithResponse request
	GetConfigurationUnitByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetConfigurationUnitByUIDResponse, error)

	// PutConfigurationUnitByUIDWithBodyWithResponse request with any body
	PutConfigurationUnitByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutConfigurationUnitByUIDResponse, error)

	PutConfigurationUnitByUIDWithResponse(ctx context.Context, uid string, body PutConfigurationUnitByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutConfigurationUnitByUIDResponse, error)

	// PostInstallCodeBySerialWithBodyWithResponse request with any body
	PostInstallCodeBySerialWithBodyWithResponse(ctx context.Context, serial string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInstallCodeBySerialResponse, error)

	PostInstallCodeBySerialWithResponse(ctx context.Context, serial string, body PostInstallCodeBySerialJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInstallCodeBySerialResponse, error)

	// GetRadioBasesListWithResponse request
	GetRadioBasesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRadioBasesListResponse, error)

	// GetRadioBaseBySerialWithResponse request
	GetRadioBaseBySerialWithResponse(ctx context.Context, serial string, reqEditors ...RequestEditorFn) (*GetRadioBaseBySerialResponse, error)

	// PostResetCodeBySerialWithBodyWithResponse request with any body
	PostResetCodeBySerialWithBodyWithResponse(ctx context.Context, serial string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostResetCodeBySerialResponse, error)

	PostResetCodeBySerialWithResponse(ctx context.Context, serial string, body PostResetCodeBySerialJSONRequestBody, reqEditors ...RequestEditorFn) (*PostResetCodeBySerialResponse, error)

	// PostStartSubscriptionBySerialWithBodyWithResponse request with any body
	PostStartSubscriptionBySerialWithBodyWithResponse(ctx context.Context, serial string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStartSubscriptionBySerialResponse, error)

	PostStartSubscriptionBySerialWithResponse(ctx context.Context, serial string, body PostStartSubscriptionBySerialJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStartSubscriptionBySerialResponse, error)

	// PostStopSubscriptionBySerialWithResponse request
	PostStopSubscriptionBySerialWithResponse(ctx context.Context, serial string, reqEditors ...RequestEditorFn) (*PostStopSubscriptionBySerialResponse, error)

	// GetSubscriptionStateByUidWithResponse request
	GetSubscriptionStateByUidWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetSubscriptionStateByUidResponse, error)

	// GetOverviewWithResponse request
	GetOverviewWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewResponse, error)

	// GetOverviewDevicesListWithResponse request
	GetOverviewDevicesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewDevicesListResponse, error)

	// GetOverviewDeviceByUIDWithResponse request
	GetOverviewDeviceByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetOverviewDeviceByUIDResponse, error)

	// GetOverviewGlobalsWithResponse request
	GetOverviewGlobalsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewGlobalsResponse, error)

	// GetOverviewGroupsListWithResponse request
	GetOverviewGroupsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewGroupsListResponse, error)

	// GetOverviewGroupByUIDWithResponse request
	GetOverviewGroupByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetOverviewGroupByUIDResponse, error)

	// GetOverviewTemplatesListWithResponse request
	GetOverviewTemplatesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewTemplatesListResponse, error)

	// GetOverviewTemplateByUIDWithResponse request
	GetOverviewTemplateByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetOverviewTemplateByUIDResponse, error)

	// PostOverviewTemplateByUIDWithBodyWithResponse request with any body
	PostOverviewTemplateByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOverviewTemplateByUIDResponse, error)

	PostOverviewTemplateByUIDWithResponse(ctx context.Context, uid string, body PostOverviewTemplateByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOverviewTemplateByUIDResponse, error)

	// GetOverviewTriggersListWithResponse request
	GetOverviewTriggersListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewTriggersListResponse, error)

	// GetOverviewTriggerByUIDWithResponse request
	GetOverviewTriggerByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetOverviewTriggerByUIDResponse, error)

	// PutOverviewTriggerByUIDWithBodyWithResponse request with any body
	PutOverviewTriggerByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutOverviewTriggerByUIDResponse, error)

	PutOverviewTriggerByUIDWithResponse(ctx context.Context, uid string, body PutOverviewTriggerByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutOverviewTriggerByUIDResponse, error)

	// GetOverviewUnitsListWithResponse request
	GetOverviewUnitsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewUnitsListResponse, error)

	// GetOverviewUnitByUIDWithResponse request
	GetOverviewUnitByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetOverviewUnitByUIDResponse, error)

	// PutOverviewUnitByUIDWithBodyWithResponse request with any body
	PutOverviewUnitByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutOverviewUnitByUIDResponse, error)

	PutOverviewUnitByUIDWithResponse(ctx context.Context, uid string, body PutOverviewUnitByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutOverviewUnitByUIDResponse, error)
}

type DeleteConfigurationDeviceByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r DeleteConfigurationDeviceByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConfigurationDeviceByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationDeviceByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointConfigurationDevice
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetConfigurationDeviceByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationDeviceByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutConfigurationDeviceByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r PutConfigurationDeviceByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutConfigurationDeviceByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostConfigurationGroupByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateGroupResponse
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r PostConfigurationGroupByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostConfigurationGroupByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConfigurationGroupByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r DeleteConfigurationGroupByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConfigurationGroupByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationGroupByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointConfigurationGroup
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetConfigurationGroupByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationGroupByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutConfigurationGroupByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r PutConfigurationGroupByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutConfigurationGroupByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationTemplateCapabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointConfigurationGetTemplateCapabilities
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetConfigurationTemplateCapabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationTemplateCapabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostConfigurationTemplateByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateTemplateResponse
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r PostConfigurationTemplateByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostConfigurationTemplateByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConfigurationTemplateByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r DeleteConfigurationTemplateByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConfigurationTemplateByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationTemplateByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointConfigurationGetTemplate
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetConfigurationTemplateByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationTemplateByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutConfigurationTemplateByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r PutConfigurationTemplateByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutConfigurationTemplateByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationUnitByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointConfigurationUnit
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetConfigurationUnitByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationUnitByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutConfigurationUnitByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r PutConfigurationUnitByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutConfigurationUnitByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInstallCodeBySerialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r PostInstallCodeBySerialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInstallCodeBySerialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRadioBasesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EndpointRadioBases
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetRadioBasesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRadioBasesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRadioBaseBySerialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointRadioBases
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetRadioBaseBySerialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRadioBaseBySerialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostResetCodeBySerialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r PostResetCodeBySerialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostResetCodeBySerialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStartSubscriptionBySerialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartSubscriptionResponse
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r PostStartSubscriptionBySerialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStartSubscriptionBySerialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStopSubscriptionBySerialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r PostStopSubscriptionBySerialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStopSubscriptionBySerialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionStateByUidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointSubscriptionState
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionStateByUidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionStateByUidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOverviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointOverview
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetOverviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOverviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOverviewDevicesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EndpointOverviewMultipleDevices
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetOverviewDevicesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOverviewDevicesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOverviewDeviceByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointOverviewSingleDevice
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetOverviewDeviceByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOverviewDeviceByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOverviewGlobalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HelperOverviewGlobals
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetOverviewGlobalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOverviewGlobalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOverviewGroupsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EndpointOverviewGroup
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetOverviewGroupsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOverviewGroupsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOverviewGroupByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointOverviewGroup
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetOverviewGroupByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOverviewGroupByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOverviewTemplatesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EndpointOverviewGetTemplate
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetOverviewTemplatesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOverviewTemplatesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOverviewTemplateByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointOverviewGetTemplate
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetOverviewTemplateByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOverviewTemplateByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOverviewTemplateByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostOverviewTemplateByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOverviewTemplateByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOverviewTriggersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EndpointOverviewTrigger
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetOverviewTriggersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOverviewTriggersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOverviewTriggerByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointOverviewTrigger
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetOverviewTriggerByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOverviewTriggerByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutOverviewTriggerByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r PutOverviewTriggerByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutOverviewTriggerByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOverviewUnitsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EndpointOverviewMultipleUnits
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetOverviewUnitsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOverviewUnitsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOverviewUnitByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointOverviewSingleUnit
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r GetOverviewUnitByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOverviewUnitByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutOverviewUnitByUIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r PutOverviewUnitByUIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutOverviewUnitByUIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteConfigurationDeviceByUIDWithResponse request returning *DeleteConfigurationDeviceByUIDResponse
func (c *ClientWithResponses) DeleteConfigurationDeviceByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*DeleteConfigurationDeviceByUIDResponse, error) {
	rsp, err := c.DeleteConfigurationDeviceByUID(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConfigurationDeviceByUIDResponse(rsp)
}

// GetConfigurationDeviceByUIDWithResponse request returning *GetConfigurationDeviceByUIDResponse
func (c *ClientWithResponses) GetConfigurationDeviceByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetConfigurationDeviceByUIDResponse, error) {
	rsp, err := c.GetConfigurationDeviceByUID(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationDeviceByUIDResponse(rsp)
}

// PutConfigurationDeviceByUIDWithBodyWithResponse request with arbitrary body returning *PutConfigurationDeviceByUIDResponse
func (c *ClientWithResponses) PutConfigurationDeviceByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutConfigurationDeviceByUIDResponse, error) {
	rsp, err := c.PutConfigurationDeviceByUIDWithBody(ctx, uid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutConfigurationDeviceByUIDResponse(rsp)
}

func (c *ClientWithResponses) PutConfigurationDeviceByUIDWithResponse(ctx context.Context, uid string, body PutConfigurationDeviceByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutConfigurationDeviceByUIDResponse, error) {
	rsp, err := c.PutConfigurationDeviceByUID(ctx, uid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutConfigurationDeviceByUIDResponse(rsp)
}

// PostConfigurationGroupByNameWithBodyWithResponse request with arbitrary body returning *PostConfigurationGroupByNameResponse
func (c *ClientWithResponses) PostConfigurationGroupByNameWithBodyWithResponse(ctx context.Context, params *PostConfigurationGroupByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostConfigurationGroupByNameResponse, error) {
	rsp, err := c.PostConfigurationGroupByNameWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostConfigurationGroupByNameResponse(rsp)
}

func (c *ClientWithResponses) PostConfigurationGroupByNameWithResponse(ctx context.Context, params *PostConfigurationGroupByNameParams, body PostConfigurationGroupByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostConfigurationGroupByNameResponse, error) {
	rsp, err := c.PostConfigurationGroupByName(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostConfigurationGroupByNameResponse(rsp)
}

// DeleteConfigurationGroupByUIDWithResponse request returning *DeleteConfigurationGroupByUIDResponse
func (c *ClientWithResponses) DeleteConfigurationGroupByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*DeleteConfigurationGroupByUIDResponse, error) {
	rsp, err := c.DeleteConfigurationGroupByUID(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConfigurationGroupByUIDResponse(rsp)
}

// GetConfigurationGroupByUIDWithResponse request returning *GetConfigurationGroupByUIDResponse
func (c *ClientWithResponses) GetConfigurationGroupByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetConfigurationGroupByUIDResponse, error) {
	rsp, err := c.GetConfigurationGroupByUID(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationGroupByUIDResponse(rsp)
}

// PutConfigurationGroupByUIDWithBodyWithResponse request with arbitrary body returning *PutConfigurationGroupByUIDResponse
func (c *ClientWithResponses) PutConfigurationGroupByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutConfigurationGroupByUIDResponse, error) {
	rsp, err := c.PutConfigurationGroupByUIDWithBody(ctx, uid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutConfigurationGroupByUIDResponse(rsp)
}

func (c *ClientWithResponses) PutConfigurationGroupByUIDWithResponse(ctx context.Context, uid string, body PutConfigurationGroupByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutConfigurationGroupByUIDResponse, error) {
	rsp, err := c.PutConfigurationGroupByUID(ctx, uid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutConfigurationGroupByUIDResponse(rsp)
}

// GetConfigurationTemplateCapabilitiesWithResponse request returning *GetConfigurationTemplateCapabilitiesResponse
func (c *ClientWithResponses) GetConfigurationTemplateCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationTemplateCapabilitiesResponse, error) {
	rsp, err := c.GetConfigurationTemplateCapabilities(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationTemplateCapabilitiesResponse(rsp)
}

// PostConfigurationTemplateByNameWithBodyWithResponse request with arbitrary body returning *PostConfigurationTemplateByNameResponse
func (c *ClientWithResponses) PostConfigurationTemplateByNameWithBodyWithResponse(ctx context.Context, params *PostConfigurationTemplateByNameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostConfigurationTemplateByNameResponse, error) {
	rsp, err := c.PostConfigurationTemplateByNameWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostConfigurationTemplateByNameResponse(rsp)
}

func (c *ClientWithResponses) PostConfigurationTemplateByNameWithResponse(ctx context.Context, params *PostConfigurationTemplateByNameParams, body PostConfigurationTemplateByNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostConfigurationTemplateByNameResponse, error) {
	rsp, err := c.PostConfigurationTemplateByName(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostConfigurationTemplateByNameResponse(rsp)
}

// DeleteConfigurationTemplateByUIDWithResponse request returning *DeleteConfigurationTemplateByUIDResponse
func (c *ClientWithResponses) DeleteConfigurationTemplateByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*DeleteConfigurationTemplateByUIDResponse, error) {
	rsp, err := c.DeleteConfigurationTemplateByUID(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConfigurationTemplateByUIDResponse(rsp)
}

// GetConfigurationTemplateByUIDWithResponse request returning *GetConfigurationTemplateByUIDResponse
func (c *ClientWithResponses) GetConfigurationTemplateByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetConfigurationTemplateByUIDResponse, error) {
	rsp, err := c.GetConfigurationTemplateByUID(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationTemplateByUIDResponse(rsp)
}

// PutConfigurationTemplateByUIDWithBodyWithResponse request with arbitrary body returning *PutConfigurationTemplateByUIDResponse
func (c *ClientWithResponses) PutConfigurationTemplateByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutConfigurationTemplateByUIDResponse, error) {
	rsp, err := c.PutConfigurationTemplateByUIDWithBody(ctx, uid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutConfigurationTemplateByUIDResponse(rsp)
}

func (c *ClientWithResponses) PutConfigurationTemplateByUIDWithResponse(ctx context.Context, uid string, body PutConfigurationTemplateByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutConfigurationTemplateByUIDResponse, error) {
	rsp, err := c.PutConfigurationTemplateByUID(ctx, uid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutConfigurationTemplateByUIDResponse(rsp)
}

// GetConfigurationUnitByUIDWithResponse request returning *GetConfigurationUnitByUIDResponse
func (c *ClientWithResponses) GetConfigurationUnitByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetConfigurationUnitByUIDResponse, error) {
	rsp, err := c.GetConfigurationUnitByUID(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationUnitByUIDResponse(rsp)
}

// PutConfigurationUnitByUIDWithBodyWithResponse request with arbitrary body returning *PutConfigurationUnitByUIDResponse
func (c *ClientWithResponses) PutConfigurationUnitByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutConfigurationUnitByUIDResponse, error) {
	rsp, err := c.PutConfigurationUnitByUIDWithBody(ctx, uid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutConfigurationUnitByUIDResponse(rsp)
}

func (c *ClientWithResponses) PutConfigurationUnitByUIDWithResponse(ctx context.Context, uid string, body PutConfigurationUnitByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutConfigurationUnitByUIDResponse, error) {
	rsp, err := c.PutConfigurationUnitByUID(ctx, uid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutConfigurationUnitByUIDResponse(rsp)
}

// PostInstallCodeBySerialWithBodyWithResponse request with arbitrary body returning *PostInstallCodeBySerialResponse
func (c *ClientWithResponses) PostInstallCodeBySerialWithBodyWithResponse(ctx context.Context, serial string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInstallCodeBySerialResponse, error) {
	rsp, err := c.PostInstallCodeBySerialWithBody(ctx, serial, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInstallCodeBySerialResponse(rsp)
}

func (c *ClientWithResponses) PostInstallCodeBySerialWithResponse(ctx context.Context, serial string, body PostInstallCodeBySerialJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInstallCodeBySerialResponse, error) {
	rsp, err := c.PostInstallCodeBySerial(ctx, serial, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInstallCodeBySerialResponse(rsp)
}

// GetRadioBasesListWithResponse request returning *GetRadioBasesListResponse
func (c *ClientWithResponses) GetRadioBasesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRadioBasesListResponse, error) {
	rsp, err := c.GetRadioBasesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRadioBasesListResponse(rsp)
}

// GetRadioBaseBySerialWithResponse request returning *GetRadioBaseBySerialResponse
func (c *ClientWithResponses) GetRadioBaseBySerialWithResponse(ctx context.Context, serial string, reqEditors ...RequestEditorFn) (*GetRadioBaseBySerialResponse, error) {
	rsp, err := c.GetRadioBaseBySerial(ctx, serial, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRadioBaseBySerialResponse(rsp)
}

// PostResetCodeBySerialWithBodyWithResponse request with arbitrary body returning *PostResetCodeBySerialResponse
func (c *ClientWithResponses) PostResetCodeBySerialWithBodyWithResponse(ctx context.Context, serial string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostResetCodeBySerialResponse, error) {
	rsp, err := c.PostResetCodeBySerialWithBody(ctx, serial, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostResetCodeBySerialResponse(rsp)
}

func (c *ClientWithResponses) PostResetCodeBySerialWithResponse(ctx context.Context, serial string, body PostResetCodeBySerialJSONRequestBody, reqEditors ...RequestEditorFn) (*PostResetCodeBySerialResponse, error) {
	rsp, err := c.PostResetCodeBySerial(ctx, serial, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostResetCodeBySerialResponse(rsp)
}

// PostStartSubscriptionBySerialWithBodyWithResponse request with arbitrary body returning *PostStartSubscriptionBySerialResponse
func (c *ClientWithResponses) PostStartSubscriptionBySerialWithBodyWithResponse(ctx context.Context, serial string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStartSubscriptionBySerialResponse, error) {
	rsp, err := c.PostStartSubscriptionBySerialWithBody(ctx, serial, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStartSubscriptionBySerialResponse(rsp)
}

func (c *ClientWithResponses) PostStartSubscriptionBySerialWithResponse(ctx context.Context, serial string, body PostStartSubscriptionBySerialJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStartSubscriptionBySerialResponse, error) {
	rsp, err := c.PostStartSubscriptionBySerial(ctx, serial, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStartSubscriptionBySerialResponse(rsp)
}

// PostStopSubscriptionBySerialWithResponse request returning *PostStopSubscriptionBySerialResponse
func (c *ClientWithResponses) PostStopSubscriptionBySerialWithResponse(ctx context.Context, serial string, reqEditors ...RequestEditorFn) (*PostStopSubscriptionBySerialResponse, error) {
	rsp, err := c.PostStopSubscriptionBySerial(ctx, serial, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStopSubscriptionBySerialResponse(rsp)
}

// GetSubscriptionStateByUidWithResponse request returning *GetSubscriptionStateByUidResponse
func (c *ClientWithResponses) GetSubscriptionStateByUidWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetSubscriptionStateByUidResponse, error) {
	rsp, err := c.GetSubscriptionStateByUid(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionStateByUidResponse(rsp)
}

// GetOverviewWithResponse request returning *GetOverviewResponse
func (c *ClientWithResponses) GetOverviewWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewResponse, error) {
	rsp, err := c.GetOverview(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOverviewResponse(rsp)
}

// GetOverviewDevicesListWithResponse request returning *GetOverviewDevicesListResponse
func (c *ClientWithResponses) GetOverviewDevicesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewDevicesListResponse, error) {
	rsp, err := c.GetOverviewDevicesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOverviewDevicesListResponse(rsp)
}

// GetOverviewDeviceByUIDWithResponse request returning *GetOverviewDeviceByUIDResponse
func (c *ClientWithResponses) GetOverviewDeviceByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetOverviewDeviceByUIDResponse, error) {
	rsp, err := c.GetOverviewDeviceByUID(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOverviewDeviceByUIDResponse(rsp)
}

// GetOverviewGlobalsWithResponse request returning *GetOverviewGlobalsResponse
func (c *ClientWithResponses) GetOverviewGlobalsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewGlobalsResponse, error) {
	rsp, err := c.GetOverviewGlobals(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOverviewGlobalsResponse(rsp)
}

// GetOverviewGroupsListWithResponse request returning *GetOverviewGroupsListResponse
func (c *ClientWithResponses) GetOverviewGroupsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewGroupsListResponse, error) {
	rsp, err := c.GetOverviewGroupsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOverviewGroupsListResponse(rsp)
}

// GetOverviewGroupByUIDWithResponse request returning *GetOverviewGroupByUIDResponse
func (c *ClientWithResponses) GetOverviewGroupByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetOverviewGroupByUIDResponse, error) {
	rsp, err := c.GetOverviewGroupByUID(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOverviewGroupByUIDResponse(rsp)
}

// GetOverviewTemplatesListWithResponse request returning *GetOverviewTemplatesListResponse
func (c *ClientWithResponses) GetOverviewTemplatesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewTemplatesListResponse, error) {
	rsp, err := c.GetOverviewTemplatesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOverviewTemplatesListResponse(rsp)
}

// GetOverviewTemplateByUIDWithResponse request returning *GetOverviewTemplateByUIDResponse
func (c *ClientWithResponses) GetOverviewTemplateByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetOverviewTemplateByUIDResponse, error) {
	rsp, err := c.GetOverviewTemplateByUID(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOverviewTemplateByUIDResponse(rsp)
}

// PostOverviewTemplateByUIDWithBodyWithResponse request with arbitrary body returning *PostOverviewTemplateByUIDResponse
func (c *ClientWithResponses) PostOverviewTemplateByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOverviewTemplateByUIDResponse, error) {
	rsp, err := c.PostOverviewTemplateByUIDWithBody(ctx, uid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOverviewTemplateByUIDResponse(rsp)
}

func (c *ClientWithResponses) PostOverviewTemplateByUIDWithResponse(ctx context.Context, uid string, body PostOverviewTemplateByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOverviewTemplateByUIDResponse, error) {
	rsp, err := c.PostOverviewTemplateByUID(ctx, uid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOverviewTemplateByUIDResponse(rsp)
}

// GetOverviewTriggersListWithResponse request returning *GetOverviewTriggersListResponse
func (c *ClientWithResponses) GetOverviewTriggersListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewTriggersListResponse, error) {
	rsp, err := c.GetOverviewTriggersList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOverviewTriggersListResponse(rsp)
}

// GetOverviewTriggerByUIDWithResponse request returning *GetOverviewTriggerByUIDResponse
func (c *ClientWithResponses) GetOverviewTriggerByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetOverviewTriggerByUIDResponse, error) {
	rsp, err := c.GetOverviewTriggerByUID(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOverviewTriggerByUIDResponse(rsp)
}

// PutOverviewTriggerByUIDWithBodyWithResponse request with arbitrary body returning *PutOverviewTriggerByUIDResponse
func (c *ClientWithResponses) PutOverviewTriggerByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutOverviewTriggerByUIDResponse, error) {
	rsp, err := c.PutOverviewTriggerByUIDWithBody(ctx, uid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutOverviewTriggerByUIDResponse(rsp)
}

func (c *ClientWithResponses) PutOverviewTriggerByUIDWithResponse(ctx context.Context, uid string, body PutOverviewTriggerByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutOverviewTriggerByUIDResponse, error) {
	rsp, err := c.PutOverviewTriggerByUID(ctx, uid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutOverviewTriggerByUIDResponse(rsp)
}

// GetOverviewUnitsListWithResponse request returning *GetOverviewUnitsListResponse
func (c *ClientWithResponses) GetOverviewUnitsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOverviewUnitsListResponse, error) {
	rsp, err := c.GetOverviewUnitsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOverviewUnitsListResponse(rsp)
}

// GetOverviewUnitByUIDWithResponse request returning *GetOverviewUnitByUIDResponse
func (c *ClientWithResponses) GetOverviewUnitByUIDWithResponse(ctx context.Context, uid string, reqEditors ...RequestEditorFn) (*GetOverviewUnitByUIDResponse, error) {
	rsp, err := c.GetOverviewUnitByUID(ctx, uid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOverviewUnitByUIDResponse(rsp)
}

// PutOverviewUnitByUIDWithBodyWithResponse request with arbitrary body returning *PutOverviewUnitByUIDResponse
func (c *ClientWithResponses) PutOverviewUnitByUIDWithBodyWithResponse(ctx context.Context, uid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutOverviewUnitByUIDResponse, error) {
	rsp, err := c.PutOverviewUnitByUIDWithBody(ctx, uid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutOverviewUnitByUIDResponse(rsp)
}

func (c *ClientWithResponses) PutOverviewUnitByUIDWithResponse(ctx context.Context, uid string, body PutOverviewUnitByUIDJSONRequestBody, reqEditors ...RequestEditorFn) (*PutOverviewUnitByUIDResponse, error) {
	rsp, err := c.PutOverviewUnitByUID(ctx, uid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutOverviewUnitByUIDResponse(rsp)
}

// ParseDeleteConfigurationDeviceByUIDResponse parses an HTTP response from a DeleteConfigurationDeviceByUIDWithResponse call
func ParseDeleteConfigurationDeviceByUIDResponse(rsp *http.Response) (*DeleteConfigurationDeviceByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConfigurationDeviceByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigurationDeviceByUIDResponse parses an HTTP response from a GetConfigurationDeviceByUIDWithResponse call
func ParseGetConfigurationDeviceByUIDResponse(rsp *http.Response) (*GetConfigurationDeviceByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationDeviceByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointConfigurationDevice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutConfigurationDeviceByUIDResponse parses an HTTP response from a PutConfigurationDeviceByUIDWithResponse call
func ParsePutConfigurationDeviceByUIDResponse(rsp *http.Response) (*PutConfigurationDeviceByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutConfigurationDeviceByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostConfigurationGroupByNameResponse parses an HTTP response from a PostConfigurationGroupByNameWithResponse call
func ParsePostConfigurationGroupByNameResponse(rsp *http.Response) (*PostConfigurationGroupByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostConfigurationGroupByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteConfigurationGroupByUIDResponse parses an HTTP response from a DeleteConfigurationGroupByUIDWithResponse call
func ParseDeleteConfigurationGroupByUIDResponse(rsp *http.Response) (*DeleteConfigurationGroupByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConfigurationGroupByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigurationGroupByUIDResponse parses an HTTP response from a GetConfigurationGroupByUIDWithResponse call
func ParseGetConfigurationGroupByUIDResponse(rsp *http.Response) (*GetConfigurationGroupByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationGroupByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointConfigurationGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutConfigurationGroupByUIDResponse parses an HTTP response from a PutConfigurationGroupByUIDWithResponse call
func ParsePutConfigurationGroupByUIDResponse(rsp *http.Response) (*PutConfigurationGroupByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutConfigurationGroupByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigurationTemplateCapabilitiesResponse parses an HTTP response from a GetConfigurationTemplateCapabilitiesWithResponse call
func ParseGetConfigurationTemplateCapabilitiesResponse(rsp *http.Response) (*GetConfigurationTemplateCapabilitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationTemplateCapabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointConfigurationGetTemplateCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostConfigurationTemplateByNameResponse parses an HTTP response from a PostConfigurationTemplateByNameWithResponse call
func ParsePostConfigurationTemplateByNameResponse(rsp *http.Response) (*PostConfigurationTemplateByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostConfigurationTemplateByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteConfigurationTemplateByUIDResponse parses an HTTP response from a DeleteConfigurationTemplateByUIDWithResponse call
func ParseDeleteConfigurationTemplateByUIDResponse(rsp *http.Response) (*DeleteConfigurationTemplateByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConfigurationTemplateByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigurationTemplateByUIDResponse parses an HTTP response from a GetConfigurationTemplateByUIDWithResponse call
func ParseGetConfigurationTemplateByUIDResponse(rsp *http.Response) (*GetConfigurationTemplateByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationTemplateByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointConfigurationGetTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutConfigurationTemplateByUIDResponse parses an HTTP response from a PutConfigurationTemplateByUIDWithResponse call
func ParsePutConfigurationTemplateByUIDResponse(rsp *http.Response) (*PutConfigurationTemplateByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutConfigurationTemplateByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigurationUnitByUIDResponse parses an HTTP response from a GetConfigurationUnitByUIDWithResponse call
func ParseGetConfigurationUnitByUIDResponse(rsp *http.Response) (*GetConfigurationUnitByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationUnitByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointConfigurationUnit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutConfigurationUnitByUIDResponse parses an HTTP response from a PutConfigurationUnitByUIDWithResponse call
func ParsePutConfigurationUnitByUIDResponse(rsp *http.Response) (*PutConfigurationUnitByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutConfigurationUnitByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostInstallCodeBySerialResponse parses an HTTP response from a PostInstallCodeBySerialWithResponse call
func ParsePostInstallCodeBySerialResponse(rsp *http.Response) (*PostInstallCodeBySerialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInstallCodeBySerialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRadioBasesListResponse parses an HTTP response from a GetRadioBasesListWithResponse call
func ParseGetRadioBasesListResponse(rsp *http.Response) (*GetRadioBasesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRadioBasesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EndpointRadioBases
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRadioBaseBySerialResponse parses an HTTP response from a GetRadioBaseBySerialWithResponse call
func ParseGetRadioBaseBySerialResponse(rsp *http.Response) (*GetRadioBaseBySerialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRadioBaseBySerialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointRadioBases
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostResetCodeBySerialResponse parses an HTTP response from a PostResetCodeBySerialWithResponse call
func ParsePostResetCodeBySerialResponse(rsp *http.Response) (*PostResetCodeBySerialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostResetCodeBySerialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostStartSubscriptionBySerialResponse parses an HTTP response from a PostStartSubscriptionBySerialWithResponse call
func ParsePostStartSubscriptionBySerialResponse(rsp *http.Response) (*PostStartSubscriptionBySerialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStartSubscriptionBySerialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartSubscriptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostStopSubscriptionBySerialResponse parses an HTTP response from a PostStopSubscriptionBySerialWithResponse call
func ParsePostStopSubscriptionBySerialResponse(rsp *http.Response) (*PostStopSubscriptionBySerialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStopSubscriptionBySerialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSubscriptionStateByUidResponse parses an HTTP response from a GetSubscriptionStateByUidWithResponse call
func ParseGetSubscriptionStateByUidResponse(rsp *http.Response) (*GetSubscriptionStateByUidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionStateByUidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointSubscriptionState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOverviewResponse parses an HTTP response from a GetOverviewWithResponse call
func ParseGetOverviewResponse(rsp *http.Response) (*GetOverviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOverviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointOverview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOverviewDevicesListResponse parses an HTTP response from a GetOverviewDevicesListWithResponse call
func ParseGetOverviewDevicesListResponse(rsp *http.Response) (*GetOverviewDevicesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOverviewDevicesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EndpointOverviewMultipleDevices
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOverviewDeviceByUIDResponse parses an HTTP response from a GetOverviewDeviceByUIDWithResponse call
func ParseGetOverviewDeviceByUIDResponse(rsp *http.Response) (*GetOverviewDeviceByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOverviewDeviceByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointOverviewSingleDevice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOverviewGlobalsResponse parses an HTTP response from a GetOverviewGlobalsWithResponse call
func ParseGetOverviewGlobalsResponse(rsp *http.Response) (*GetOverviewGlobalsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOverviewGlobalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HelperOverviewGlobals
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOverviewGroupsListResponse parses an HTTP response from a GetOverviewGroupsListWithResponse call
func ParseGetOverviewGroupsListResponse(rsp *http.Response) (*GetOverviewGroupsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOverviewGroupsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EndpointOverviewGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOverviewGroupByUIDResponse parses an HTTP response from a GetOverviewGroupByUIDWithResponse call
func ParseGetOverviewGroupByUIDResponse(rsp *http.Response) (*GetOverviewGroupByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOverviewGroupByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointOverviewGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOverviewTemplatesListResponse parses an HTTP response from a GetOverviewTemplatesListWithResponse call
func ParseGetOverviewTemplatesListResponse(rsp *http.Response) (*GetOverviewTemplatesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOverviewTemplatesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EndpointOverviewGetTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOverviewTemplateByUIDResponse parses an HTTP response from a GetOverviewTemplateByUIDWithResponse call
func ParseGetOverviewTemplateByUIDResponse(rsp *http.Response) (*GetOverviewTemplateByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOverviewTemplateByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointOverviewGetTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostOverviewTemplateByUIDResponse parses an HTTP response from a PostOverviewTemplateByUIDWithResponse call
func ParsePostOverviewTemplateByUIDResponse(rsp *http.Response) (*PostOverviewTemplateByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOverviewTemplateByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOverviewTriggersListResponse parses an HTTP response from a GetOverviewTriggersListWithResponse call
func ParseGetOverviewTriggersListResponse(rsp *http.Response) (*GetOverviewTriggersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOverviewTriggersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EndpointOverviewTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOverviewTriggerByUIDResponse parses an HTTP response from a GetOverviewTriggerByUIDWithResponse call
func ParseGetOverviewTriggerByUIDResponse(rsp *http.Response) (*GetOverviewTriggerByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOverviewTriggerByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointOverviewTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutOverviewTriggerByUIDResponse parses an HTTP response from a PutOverviewTriggerByUIDWithResponse call
func ParsePutOverviewTriggerByUIDResponse(rsp *http.Response) (*PutOverviewTriggerByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutOverviewTriggerByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOverviewUnitsListResponse parses an HTTP response from a GetOverviewUnitsListWithResponse call
func ParseGetOverviewUnitsListResponse(rsp *http.Response) (*GetOverviewUnitsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOverviewUnitsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EndpointOverviewMultipleUnits
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOverviewUnitByUIDResponse parses an HTTP response from a GetOverviewUnitByUIDWithResponse call
func ParseGetOverviewUnitByUIDResponse(rsp *http.Response) (*GetOverviewUnitByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOverviewUnitByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointOverviewSingleUnit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutOverviewUnitByUIDResponse parses an HTTP response from a PutOverviewUnitByUIDWithResponse call
func ParsePutOverviewUnitByUIDResponse(rsp *http.Response) (*PutOverviewUnitByUIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutOverviewUnitByUIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Delete device by UID
	// (DELETE /smarthome/configuration/devices/{UID})
	DeleteConfigurationDeviceByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Get device configuration by UID
	// (GET /smarthome/configuration/devices/{UID})
	GetConfigurationDeviceByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Configure and control device by UID
	// (PUT /smarthome/configuration/devices/{UID})
	PutConfigurationDeviceByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Create new group
	// (POST /smarthome/configuration/groups)
	PostConfigurationGroupByName(w http.ResponseWriter, r *http.Request, params PostConfigurationGroupByNameParams)
	// Delete group by UID
	// (DELETE /smarthome/configuration/groups/{UID})
	DeleteConfigurationGroupByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Get group configuration by UID
	// (GET /smarthome/configuration/groups/{UID})
	GetConfigurationGroupByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Configure and control group by UID
	// (PUT /smarthome/configuration/groups/{UID})
	PutConfigurationGroupByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Get possible template configuration capabilities
	// (GET /smarthome/configuration/templateCapabilities)
	GetConfigurationTemplateCapabilities(w http.ResponseWriter, r *http.Request)
	// Create new template
	// (POST /smarthome/configuration/templates)
	PostConfigurationTemplateByName(w http.ResponseWriter, r *http.Request, params PostConfigurationTemplateByNameParams)
	// Delete template by UID
	// (DELETE /smarthome/configuration/templates/{UID})
	DeleteConfigurationTemplateByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Get template configuration by UID
	// (GET /smarthome/configuration/templates/{UID})
	GetConfigurationTemplateByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Configure and control template by UID
	// (PUT /smarthome/configuration/templates/{UID})
	PutConfigurationTemplateByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Get unit configuration by UID
	// (GET /smarthome/configuration/units/{UID})
	GetConfigurationUnitByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Configure and control unit by UID
	// (PUT /smarthome/configuration/units/{UID})
	PutConfigurationUnitByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Set installCode on zigbee radioBase
	// (POST /smarthome/connect/installCode/{serial})
	PostInstallCodeBySerial(w http.ResponseWriter, r *http.Request, serial string)
	// Get list of radioBases
	// (GET /smarthome/connect/radioBases)
	GetRadioBasesList(w http.ResponseWriter, r *http.Request)
	// Get radioBase by Serial
	// (GET /smarthome/connect/radioBases/{serial})
	GetRadioBaseBySerial(w http.ResponseWriter, r *http.Request, serial string)
	// Set resetCode on zigbee radioBase
	// (POST /smarthome/connect/resetCode/{serial})
	PostResetCodeBySerial(w http.ResponseWriter, r *http.Request, serial string)
	// Start Subscription on radioBase by Serial
	// (POST /smarthome/connect/startSubscription/{serial})
	PostStartSubscriptionBySerial(w http.ResponseWriter, r *http.Request, serial string)
	// Stop Subscription on radioBase by Serial
	// (POST /smarthome/connect/stopSubscription/{serial})
	PostStopSubscriptionBySerial(w http.ResponseWriter, r *http.Request, serial string)
	// Get subscription state by UID
	// (GET /smarthome/connect/subscriptionState/{UID})
	GetSubscriptionStateByUid(w http.ResponseWriter, r *http.Request, uid string)
	// Get all overview infos and lists
	// (GET /smarthome/overview)
	GetOverview(w http.ResponseWriter, r *http.Request)
	// Get list of devices
	// (GET /smarthome/overview/devices)
	GetOverviewDevicesList(w http.ResponseWriter, r *http.Request)
	// Get device by UID
	// (GET /smarthome/overview/devices/{UID})
	GetOverviewDeviceByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Get smart home global values
	// (GET /smarthome/overview/globals)
	GetOverviewGlobals(w http.ResponseWriter, r *http.Request)
	// Get list of groups
	// (GET /smarthome/overview/groups)
	GetOverviewGroupsList(w http.ResponseWriter, r *http.Request)
	// Get group by UID
	// (GET /smarthome/overview/groups/{UID})
	GetOverviewGroupByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Get list of templates
	// (GET /smarthome/overview/templates)
	GetOverviewTemplatesList(w http.ResponseWriter, r *http.Request)
	// Get template by UID
	// (GET /smarthome/overview/templates/{UID})
	GetOverviewTemplateByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Applies a template by UID
	// (POST /smarthome/overview/templates/{UID})
	PostOverviewTemplateByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Get list of triggers
	// (GET /smarthome/overview/triggers)
	GetOverviewTriggersList(w http.ResponseWriter, r *http.Request)
	// Get trigger by UID
	// (GET /smarthome/overview/triggers/{UID})
	GetOverviewTriggerByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Activate or deactivate trigger by UID
	// (PUT /smarthome/overview/triggers/{UID})
	PutOverviewTriggerByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Get list of units
	// (GET /smarthome/overview/units)
	GetOverviewUnitsList(w http.ResponseWriter, r *http.Request)
	// Get unit by UID
	// (GET /smarthome/overview/units/{UID})
	GetOverviewUnitByUID(w http.ResponseWriter, r *http.Request, uid string)
	// Control interfaces for unit by UID
	// (PUT /smarthome/overview/units/{UID})
	PutOverviewUnitByUID(w http.ResponseWriter, r *http.Request, uid string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// DeleteConfigurationDeviceByUID operation middleware
func (siw *ServerInterfaceWrapper) DeleteConfigurationDeviceByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteConfigurationDeviceByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetConfigurationDeviceByUID operation middleware
func (siw *ServerInterfaceWrapper) GetConfigurationDeviceByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConfigurationDeviceByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutConfigurationDeviceByUID operation middleware
func (siw *ServerInterfaceWrapper) PutConfigurationDeviceByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutConfigurationDeviceByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostConfigurationGroupByName operation middleware
func (siw *ServerInterfaceWrapper) PostConfigurationGroupByName(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PostConfigurationGroupByNameParams

	// ------------- Required query parameter "name" -------------

	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostConfigurationGroupByName(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteConfigurationGroupByUID operation middleware
func (siw *ServerInterfaceWrapper) DeleteConfigurationGroupByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteConfigurationGroupByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetConfigurationGroupByUID operation middleware
func (siw *ServerInterfaceWrapper) GetConfigurationGroupByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConfigurationGroupByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutConfigurationGroupByUID operation middleware
func (siw *ServerInterfaceWrapper) PutConfigurationGroupByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutConfigurationGroupByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetConfigurationTemplateCapabilities operation middleware
func (siw *ServerInterfaceWrapper) GetConfigurationTemplateCapabilities(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConfigurationTemplateCapabilities(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostConfigurationTemplateByName operation middleware
func (siw *ServerInterfaceWrapper) PostConfigurationTemplateByName(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PostConfigurationTemplateByNameParams

	// ------------- Required query parameter "name" -------------

	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostConfigurationTemplateByName(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteConfigurationTemplateByUID operation middleware
func (siw *ServerInterfaceWrapper) DeleteConfigurationTemplateByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteConfigurationTemplateByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetConfigurationTemplateByUID operation middleware
func (siw *ServerInterfaceWrapper) GetConfigurationTemplateByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConfigurationTemplateByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutConfigurationTemplateByUID operation middleware
func (siw *ServerInterfaceWrapper) PutConfigurationTemplateByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutConfigurationTemplateByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetConfigurationUnitByUID operation middleware
func (siw *ServerInterfaceWrapper) GetConfigurationUnitByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConfigurationUnitByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutConfigurationUnitByUID operation middleware
func (siw *ServerInterfaceWrapper) PutConfigurationUnitByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutConfigurationUnitByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostInstallCodeBySerial operation middleware
func (siw *ServerInterfaceWrapper) PostInstallCodeBySerial(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "serial" -------------
	var serial string

	err = runtime.BindStyledParameterWithOptions("simple", "serial", r.PathValue("serial"), &serial, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "serial", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostInstallCodeBySerial(w, r, serial)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRadioBasesList operation middleware
func (siw *ServerInterfaceWrapper) GetRadioBasesList(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRadioBasesList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRadioBaseBySerial operation middleware
func (siw *ServerInterfaceWrapper) GetRadioBaseBySerial(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "serial" -------------
	var serial string

	err = runtime.BindStyledParameterWithOptions("simple", "serial", r.PathValue("serial"), &serial, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "serial", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRadioBaseBySerial(w, r, serial)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostResetCodeBySerial operation middleware
func (siw *ServerInterfaceWrapper) PostResetCodeBySerial(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "serial" -------------
	var serial string

	err = runtime.BindStyledParameterWithOptions("simple", "serial", r.PathValue("serial"), &serial, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "serial", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostResetCodeBySerial(w, r, serial)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostStartSubscriptionBySerial operation middleware
func (siw *ServerInterfaceWrapper) PostStartSubscriptionBySerial(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "serial" -------------
	var serial string

	err = runtime.BindStyledParameterWithOptions("simple", "serial", r.PathValue("serial"), &serial, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "serial", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostStartSubscriptionBySerial(w, r, serial)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostStopSubscriptionBySerial operation middleware
func (siw *ServerInterfaceWrapper) PostStopSubscriptionBySerial(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "serial" -------------
	var serial string

	err = runtime.BindStyledParameterWithOptions("simple", "serial", r.PathValue("serial"), &serial, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "serial", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostStopSubscriptionBySerial(w, r, serial)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSubscriptionStateByUid operation middleware
func (siw *ServerInterfaceWrapper) GetSubscriptionStateByUid(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSubscriptionStateByUid(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOverview operation middleware
func (siw *ServerInterfaceWrapper) GetOverview(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOverview(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOverviewDevicesList operation middleware
func (siw *ServerInterfaceWrapper) GetOverviewDevicesList(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOverviewDevicesList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOverviewDeviceByUID operation middleware
func (siw *ServerInterfaceWrapper) GetOverviewDeviceByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOverviewDeviceByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOverviewGlobals operation middleware
func (siw *ServerInterfaceWrapper) GetOverviewGlobals(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOverviewGlobals(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOverviewGroupsList operation middleware
func (siw *ServerInterfaceWrapper) GetOverviewGroupsList(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOverviewGroupsList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOverviewGroupByUID operation middleware
func (siw *ServerInterfaceWrapper) GetOverviewGroupByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOverviewGroupByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOverviewTemplatesList operation middleware
func (siw *ServerInterfaceWrapper) GetOverviewTemplatesList(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOverviewTemplatesList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOverviewTemplateByUID operation middleware
func (siw *ServerInterfaceWrapper) GetOverviewTemplateByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOverviewTemplateByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostOverviewTemplateByUID operation middleware
func (siw *ServerInterfaceWrapper) PostOverviewTemplateByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostOverviewTemplateByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOverviewTriggersList operation middleware
func (siw *ServerInterfaceWrapper) GetOverviewTriggersList(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOverviewTriggersList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOverviewTriggerByUID operation middleware
func (siw *ServerInterfaceWrapper) GetOverviewTriggerByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOverviewTriggerByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutOverviewTriggerByUID operation middleware
func (siw *ServerInterfaceWrapper) PutOverviewTriggerByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutOverviewTriggerByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOverviewUnitsList operation middleware
func (siw *ServerInterfaceWrapper) GetOverviewUnitsList(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOverviewUnitsList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOverviewUnitByUID operation middleware
func (siw *ServerInterfaceWrapper) GetOverviewUnitByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOverviewUnitByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutOverviewUnitByUID operation middleware
func (siw *ServerInterfaceWrapper) PutOverviewUnitByUID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "UID" -------------
	var uid string

	err = runtime.BindStyledParameterWithOptions("simple", "UID", r.PathValue("UID"), &uid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UID", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, AVM_SIDScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutOverviewUnitByUID(w, r, uid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("DELETE "+options.BaseURL+"/smarthome/configuration/devices/{UID}", wrapper.DeleteConfigurationDeviceByUID)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/configuration/devices/{UID}", wrapper.GetConfigurationDeviceByUID)
	m.HandleFunc("PUT "+options.BaseURL+"/smarthome/configuration/devices/{UID}", wrapper.PutConfigurationDeviceByUID)
	m.HandleFunc("POST "+options.BaseURL+"/smarthome/configuration/groups", wrapper.PostConfigurationGroupByName)
	m.HandleFunc("DELETE "+options.BaseURL+"/smarthome/configuration/groups/{UID}", wrapper.DeleteConfigurationGroupByUID)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/configuration/groups/{UID}", wrapper.GetConfigurationGroupByUID)
	m.HandleFunc("PUT "+options.BaseURL+"/smarthome/configuration/groups/{UID}", wrapper.PutConfigurationGroupByUID)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/configuration/templateCapabilities", wrapper.GetConfigurationTemplateCapabilities)
	m.HandleFunc("POST "+options.BaseURL+"/smarthome/configuration/templates", wrapper.PostConfigurationTemplateByName)
	m.HandleFunc("DELETE "+options.BaseURL+"/smarthome/configuration/templates/{UID}", wrapper.DeleteConfigurationTemplateByUID)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/configuration/templates/{UID}", wrapper.GetConfigurationTemplateByUID)
	m.HandleFunc("PUT "+options.BaseURL+"/smarthome/configuration/templates/{UID}", wrapper.PutConfigurationTemplateByUID)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/configuration/units/{UID}", wrapper.GetConfigurationUnitByUID)
	m.HandleFunc("PUT "+options.BaseURL+"/smarthome/configuration/units/{UID}", wrapper.PutConfigurationUnitByUID)
	m.HandleFunc("POST "+options.BaseURL+"/smarthome/connect/installCode/{serial}", wrapper.PostInstallCodeBySerial)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/connect/radioBases", wrapper.GetRadioBasesList)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/connect/radioBases/{serial}", wrapper.GetRadioBaseBySerial)
	m.HandleFunc("POST "+options.BaseURL+"/smarthome/connect/resetCode/{serial}", wrapper.PostResetCodeBySerial)
	m.HandleFunc("POST "+options.BaseURL+"/smarthome/connect/startSubscription/{serial}", wrapper.PostStartSubscriptionBySerial)
	m.HandleFunc("POST "+options.BaseURL+"/smarthome/connect/stopSubscription/{serial}", wrapper.PostStopSubscriptionBySerial)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/connect/subscriptionState/{UID}", wrapper.GetSubscriptionStateByUid)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/overview", wrapper.GetOverview)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/overview/devices", wrapper.GetOverviewDevicesList)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/overview/devices/{UID}", wrapper.GetOverviewDeviceByUID)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/overview/globals", wrapper.GetOverviewGlobals)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/overview/groups", wrapper.GetOverviewGroupsList)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/overview/groups/{UID}", wrapper.GetOverviewGroupByUID)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/overview/templates", wrapper.GetOverviewTemplatesList)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/overview/templates/{UID}", wrapper.GetOverviewTemplateByUID)
	m.HandleFunc("POST "+options.BaseURL+"/smarthome/overview/templates/{UID}", wrapper.PostOverviewTemplateByUID)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/overview/triggers", wrapper.GetOverviewTriggersList)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/overview/triggers/{UID}", wrapper.GetOverviewTriggerByUID)
	m.HandleFunc("PUT "+options.BaseURL+"/smarthome/overview/triggers/{UID}", wrapper.PutOverviewTriggerByUID)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/overview/units", wrapper.GetOverviewUnitsList)
	m.HandleFunc("GET "+options.BaseURL+"/smarthome/overview/units/{UID}", wrapper.GetOverviewUnitByUID)
	m.HandleFunc("PUT "+options.BaseURL+"/smarthome/overview/units/{UID}", wrapper.PutOverviewUnitByUID)

	return m
}

type ErrorsJSONResponse ErrorResponse

type DeleteConfigurationDeviceByUIDRequestObject struct {
	UID string `json:"UID"`
}

type DeleteConfigurationDeviceByUIDResponseObject interface {
	VisitDeleteConfigurationDeviceByUIDResponse(w http.ResponseWriter) error
}

type DeleteConfigurationDeviceByUID200Response struct {
}

func (response DeleteConfigurationDeviceByUID200Response) VisitDeleteConfigurationDeviceByUIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type DeleteConfigurationDeviceByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteConfigurationDeviceByUIDdefaultJSONResponse) VisitDeleteConfigurationDeviceByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetConfigurationDeviceByUIDRequestObject struct {
	UID string `json:"UID"`
}

type GetConfigurationDeviceByUIDResponseObject interface {
	VisitGetConfigurationDeviceByUIDResponse(w http.ResponseWriter) error
}

type GetConfigurationDeviceByUID200JSONResponse EndpointConfigurationDevice

func (response GetConfigurationDeviceByUID200JSONResponse) VisitGetConfigurationDeviceByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConfigurationDeviceByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetConfigurationDeviceByUIDdefaultJSONResponse) VisitGetConfigurationDeviceByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PutConfigurationDeviceByUIDRequestObject struct {
	UID  string `json:"UID"`
	Body *PutConfigurationDeviceByUIDJSONRequestBody
}

type PutConfigurationDeviceByUIDResponseObject interface {
	VisitPutConfigurationDeviceByUIDResponse(w http.ResponseWriter) error
}

type PutConfigurationDeviceByUID200Response struct {
}

func (response PutConfigurationDeviceByUID200Response) VisitPutConfigurationDeviceByUIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type PutConfigurationDeviceByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PutConfigurationDeviceByUIDdefaultJSONResponse) VisitPutConfigurationDeviceByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PostConfigurationGroupByNameRequestObject struct {
	Params PostConfigurationGroupByNameParams
	Body   *PostConfigurationGroupByNameJSONRequestBody
}

type PostConfigurationGroupByNameResponseObject interface {
	VisitPostConfigurationGroupByNameResponse(w http.ResponseWriter) error
}

type PostConfigurationGroupByName200JSONResponse CreateGroupResponse

func (response PostConfigurationGroupByName200JSONResponse) VisitPostConfigurationGroupByNameResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostConfigurationGroupByNamedefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PostConfigurationGroupByNamedefaultJSONResponse) VisitPostConfigurationGroupByNameResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteConfigurationGroupByUIDRequestObject struct {
	UID string `json:"UID"`
}

type DeleteConfigurationGroupByUIDResponseObject interface {
	VisitDeleteConfigurationGroupByUIDResponse(w http.ResponseWriter) error
}

type DeleteConfigurationGroupByUID200Response struct {
}

func (response DeleteConfigurationGroupByUID200Response) VisitDeleteConfigurationGroupByUIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type DeleteConfigurationGroupByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteConfigurationGroupByUIDdefaultJSONResponse) VisitDeleteConfigurationGroupByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetConfigurationGroupByUIDRequestObject struct {
	UID string `json:"UID"`
}

type GetConfigurationGroupByUIDResponseObject interface {
	VisitGetConfigurationGroupByUIDResponse(w http.ResponseWriter) error
}

type GetConfigurationGroupByUID200JSONResponse EndpointConfigurationGroup

func (response GetConfigurationGroupByUID200JSONResponse) VisitGetConfigurationGroupByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConfigurationGroupByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetConfigurationGroupByUIDdefaultJSONResponse) VisitGetConfigurationGroupByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PutConfigurationGroupByUIDRequestObject struct {
	UID  string `json:"UID"`
	Body *PutConfigurationGroupByUIDJSONRequestBody
}

type PutConfigurationGroupByUIDResponseObject interface {
	VisitPutConfigurationGroupByUIDResponse(w http.ResponseWriter) error
}

type PutConfigurationGroupByUID200Response struct {
}

func (response PutConfigurationGroupByUID200Response) VisitPutConfigurationGroupByUIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type PutConfigurationGroupByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PutConfigurationGroupByUIDdefaultJSONResponse) VisitPutConfigurationGroupByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetConfigurationTemplateCapabilitiesRequestObject struct {
}

type GetConfigurationTemplateCapabilitiesResponseObject interface {
	VisitGetConfigurationTemplateCapabilitiesResponse(w http.ResponseWriter) error
}

type GetConfigurationTemplateCapabilities200JSONResponse EndpointConfigurationGetTemplateCapabilities

func (response GetConfigurationTemplateCapabilities200JSONResponse) VisitGetConfigurationTemplateCapabilitiesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConfigurationTemplateCapabilitiesdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetConfigurationTemplateCapabilitiesdefaultJSONResponse) VisitGetConfigurationTemplateCapabilitiesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PostConfigurationTemplateByNameRequestObject struct {
	Params PostConfigurationTemplateByNameParams
	Body   *PostConfigurationTemplateByNameJSONRequestBody
}

type PostConfigurationTemplateByNameResponseObject interface {
	VisitPostConfigurationTemplateByNameResponse(w http.ResponseWriter) error
}

type PostConfigurationTemplateByName200JSONResponse CreateTemplateResponse

func (response PostConfigurationTemplateByName200JSONResponse) VisitPostConfigurationTemplateByNameResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostConfigurationTemplateByNamedefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PostConfigurationTemplateByNamedefaultJSONResponse) VisitPostConfigurationTemplateByNameResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteConfigurationTemplateByUIDRequestObject struct {
	UID string `json:"UID"`
}

type DeleteConfigurationTemplateByUIDResponseObject interface {
	VisitDeleteConfigurationTemplateByUIDResponse(w http.ResponseWriter) error
}

type DeleteConfigurationTemplateByUID200Response struct {
}

func (response DeleteConfigurationTemplateByUID200Response) VisitDeleteConfigurationTemplateByUIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type DeleteConfigurationTemplateByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteConfigurationTemplateByUIDdefaultJSONResponse) VisitDeleteConfigurationTemplateByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetConfigurationTemplateByUIDRequestObject struct {
	UID string `json:"UID"`
}

type GetConfigurationTemplateByUIDResponseObject interface {
	VisitGetConfigurationTemplateByUIDResponse(w http.ResponseWriter) error
}

type GetConfigurationTemplateByUID200JSONResponse EndpointConfigurationGetTemplate

func (response GetConfigurationTemplateByUID200JSONResponse) VisitGetConfigurationTemplateByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConfigurationTemplateByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetConfigurationTemplateByUIDdefaultJSONResponse) VisitGetConfigurationTemplateByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PutConfigurationTemplateByUIDRequestObject struct {
	UID  string `json:"UID"`
	Body *PutConfigurationTemplateByUIDJSONRequestBody
}

type PutConfigurationTemplateByUIDResponseObject interface {
	VisitPutConfigurationTemplateByUIDResponse(w http.ResponseWriter) error
}

type PutConfigurationTemplateByUID200Response struct {
}

func (response PutConfigurationTemplateByUID200Response) VisitPutConfigurationTemplateByUIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type PutConfigurationTemplateByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PutConfigurationTemplateByUIDdefaultJSONResponse) VisitPutConfigurationTemplateByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetConfigurationUnitByUIDRequestObject struct {
	UID string `json:"UID"`
}

type GetConfigurationUnitByUIDResponseObject interface {
	VisitGetConfigurationUnitByUIDResponse(w http.ResponseWriter) error
}

type GetConfigurationUnitByUID200JSONResponse EndpointConfigurationUnit

func (response GetConfigurationUnitByUID200JSONResponse) VisitGetConfigurationUnitByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConfigurationUnitByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetConfigurationUnitByUIDdefaultJSONResponse) VisitGetConfigurationUnitByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PutConfigurationUnitByUIDRequestObject struct {
	UID  string `json:"UID"`
	Body *PutConfigurationUnitByUIDJSONRequestBody
}

type PutConfigurationUnitByUIDResponseObject interface {
	VisitPutConfigurationUnitByUIDResponse(w http.ResponseWriter) error
}

type PutConfigurationUnitByUID200Response struct {
}

func (response PutConfigurationUnitByUID200Response) VisitPutConfigurationUnitByUIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type PutConfigurationUnitByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PutConfigurationUnitByUIDdefaultJSONResponse) VisitPutConfigurationUnitByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PostInstallCodeBySerialRequestObject struct {
	Serial string `json:"serial"`
	Body   *PostInstallCodeBySerialJSONRequestBody
}

type PostInstallCodeBySerialResponseObject interface {
	VisitPostInstallCodeBySerialResponse(w http.ResponseWriter) error
}

type PostInstallCodeBySerial200Response struct {
}

func (response PostInstallCodeBySerial200Response) VisitPostInstallCodeBySerialResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type PostInstallCodeBySerialdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PostInstallCodeBySerialdefaultJSONResponse) VisitPostInstallCodeBySerialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetRadioBasesListRequestObject struct {
}

type GetRadioBasesListResponseObject interface {
	VisitGetRadioBasesListResponse(w http.ResponseWriter) error
}

type GetRadioBasesList200JSONResponse []EndpointRadioBases

func (response GetRadioBasesList200JSONResponse) VisitGetRadioBasesListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetRadioBasesListdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetRadioBasesListdefaultJSONResponse) VisitGetRadioBasesListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetRadioBaseBySerialRequestObject struct {
	Serial string `json:"serial"`
}

type GetRadioBaseBySerialResponseObject interface {
	VisitGetRadioBaseBySerialResponse(w http.ResponseWriter) error
}

type GetRadioBaseBySerial200JSONResponse EndpointRadioBases

func (response GetRadioBaseBySerial200JSONResponse) VisitGetRadioBaseBySerialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetRadioBaseBySerialdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetRadioBaseBySerialdefaultJSONResponse) VisitGetRadioBaseBySerialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PostResetCodeBySerialRequestObject struct {
	Serial string `json:"serial"`
	Body   *PostResetCodeBySerialJSONRequestBody
}

type PostResetCodeBySerialResponseObject interface {
	VisitPostResetCodeBySerialResponse(w http.ResponseWriter) error
}

type PostResetCodeBySerial200Response struct {
}

func (response PostResetCodeBySerial200Response) VisitPostResetCodeBySerialResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type PostResetCodeBySerialdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PostResetCodeBySerialdefaultJSONResponse) VisitPostResetCodeBySerialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PostStartSubscriptionBySerialRequestObject struct {
	Serial string `json:"serial"`
	Body   *PostStartSubscriptionBySerialJSONRequestBody
}

type PostStartSubscriptionBySerialResponseObject interface {
	VisitPostStartSubscriptionBySerialResponse(w http.ResponseWriter) error
}

type PostStartSubscriptionBySerial200JSONResponse StartSubscriptionResponse

func (response PostStartSubscriptionBySerial200JSONResponse) VisitPostStartSubscriptionBySerialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostStartSubscriptionBySerialdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PostStartSubscriptionBySerialdefaultJSONResponse) VisitPostStartSubscriptionBySerialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PostStopSubscriptionBySerialRequestObject struct {
	Serial string `json:"serial"`
}

type PostStopSubscriptionBySerialResponseObject interface {
	VisitPostStopSubscriptionBySerialResponse(w http.ResponseWriter) error
}

type PostStopSubscriptionBySerial200Response struct {
}

func (response PostStopSubscriptionBySerial200Response) VisitPostStopSubscriptionBySerialResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type PostStopSubscriptionBySerialdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PostStopSubscriptionBySerialdefaultJSONResponse) VisitPostStopSubscriptionBySerialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetSubscriptionStateByUidRequestObject struct {
	UID string `json:"UID"`
}

type GetSubscriptionStateByUidResponseObject interface {
	VisitGetSubscriptionStateByUidResponse(w http.ResponseWriter) error
}

type GetSubscriptionStateByUid200JSONResponse EndpointSubscriptionState

func (response GetSubscriptionStateByUid200JSONResponse) VisitGetSubscriptionStateByUidResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetSubscriptionStateByUiddefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetSubscriptionStateByUiddefaultJSONResponse) VisitGetSubscriptionStateByUidResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetOverviewRequestObject struct {
}

type GetOverviewResponseObject interface {
	VisitGetOverviewResponse(w http.ResponseWriter) error
}

type GetOverview200JSONResponse EndpointOverview

func (response GetOverview200JSONResponse) VisitGetOverviewResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOverviewdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOverviewdefaultJSONResponse) VisitGetOverviewResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetOverviewDevicesListRequestObject struct {
}

type GetOverviewDevicesListResponseObject interface {
	VisitGetOverviewDevicesListResponse(w http.ResponseWriter) error
}

type GetOverviewDevicesList200JSONResponse []EndpointOverviewMultipleDevices

func (response GetOverviewDevicesList200JSONResponse) VisitGetOverviewDevicesListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOverviewDevicesListdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOverviewDevicesListdefaultJSONResponse) VisitGetOverviewDevicesListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetOverviewDeviceByUIDRequestObject struct {
	UID string `json:"UID"`
}

type GetOverviewDeviceByUIDResponseObject interface {
	VisitGetOverviewDeviceByUIDResponse(w http.ResponseWriter) error
}

type GetOverviewDeviceByUID200JSONResponse EndpointOverviewSingleDevice

func (response GetOverviewDeviceByUID200JSONResponse) VisitGetOverviewDeviceByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOverviewDeviceByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOverviewDeviceByUIDdefaultJSONResponse) VisitGetOverviewDeviceByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetOverviewGlobalsRequestObject struct {
}

type GetOverviewGlobalsResponseObject interface {
	VisitGetOverviewGlobalsResponse(w http.ResponseWriter) error
}

type GetOverviewGlobals200JSONResponse HelperOverviewGlobals

func (response GetOverviewGlobals200JSONResponse) VisitGetOverviewGlobalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOverviewGlobalsdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOverviewGlobalsdefaultJSONResponse) VisitGetOverviewGlobalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetOverviewGroupsListRequestObject struct {
}

type GetOverviewGroupsListResponseObject interface {
	VisitGetOverviewGroupsListResponse(w http.ResponseWriter) error
}

type GetOverviewGroupsList200JSONResponse []EndpointOverviewGroup

func (response GetOverviewGroupsList200JSONResponse) VisitGetOverviewGroupsListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOverviewGroupsListdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOverviewGroupsListdefaultJSONResponse) VisitGetOverviewGroupsListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetOverviewGroupByUIDRequestObject struct {
	UID string `json:"UID"`
}

type GetOverviewGroupByUIDResponseObject interface {
	VisitGetOverviewGroupByUIDResponse(w http.ResponseWriter) error
}

type GetOverviewGroupByUID200JSONResponse EndpointOverviewGroup

func (response GetOverviewGroupByUID200JSONResponse) VisitGetOverviewGroupByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOverviewGroupByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOverviewGroupByUIDdefaultJSONResponse) VisitGetOverviewGroupByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetOverviewTemplatesListRequestObject struct {
}

type GetOverviewTemplatesListResponseObject interface {
	VisitGetOverviewTemplatesListResponse(w http.ResponseWriter) error
}

type GetOverviewTemplatesList200JSONResponse []EndpointOverviewGetTemplate

func (response GetOverviewTemplatesList200JSONResponse) VisitGetOverviewTemplatesListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOverviewTemplatesListdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOverviewTemplatesListdefaultJSONResponse) VisitGetOverviewTemplatesListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetOverviewTemplateByUIDRequestObject struct {
	UID string `json:"UID"`
}

type GetOverviewTemplateByUIDResponseObject interface {
	VisitGetOverviewTemplateByUIDResponse(w http.ResponseWriter) error
}

type GetOverviewTemplateByUID200JSONResponse EndpointOverviewGetTemplate

func (response GetOverviewTemplateByUID200JSONResponse) VisitGetOverviewTemplateByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOverviewTemplateByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOverviewTemplateByUIDdefaultJSONResponse) VisitGetOverviewTemplateByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PostOverviewTemplateByUIDRequestObject struct {
	UID  string `json:"UID"`
	Body *PostOverviewTemplateByUIDJSONRequestBody
}

type PostOverviewTemplateByUIDResponseObject interface {
	VisitPostOverviewTemplateByUIDResponse(w http.ResponseWriter) error
}

type PostOverviewTemplateByUID200Response struct {
}

func (response PostOverviewTemplateByUID200Response) VisitPostOverviewTemplateByUIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type PostOverviewTemplateByUID405Response struct {
}

func (response PostOverviewTemplateByUID405Response) VisitPostOverviewTemplateByUIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetOverviewTriggersListRequestObject struct {
}

type GetOverviewTriggersListResponseObject interface {
	VisitGetOverviewTriggersListResponse(w http.ResponseWriter) error
}

type GetOverviewTriggersList200JSONResponse []EndpointOverviewTrigger

func (response GetOverviewTriggersList200JSONResponse) VisitGetOverviewTriggersListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOverviewTriggersListdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOverviewTriggersListdefaultJSONResponse) VisitGetOverviewTriggersListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetOverviewTriggerByUIDRequestObject struct {
	UID string `json:"UID"`
}

type GetOverviewTriggerByUIDResponseObject interface {
	VisitGetOverviewTriggerByUIDResponse(w http.ResponseWriter) error
}

type GetOverviewTriggerByUID200JSONResponse EndpointOverviewTrigger

func (response GetOverviewTriggerByUID200JSONResponse) VisitGetOverviewTriggerByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOverviewTriggerByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOverviewTriggerByUIDdefaultJSONResponse) VisitGetOverviewTriggerByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PutOverviewTriggerByUIDRequestObject struct {
	UID  string `json:"UID"`
	Body *PutOverviewTriggerByUIDJSONRequestBody
}

type PutOverviewTriggerByUIDResponseObject interface {
	VisitPutOverviewTriggerByUIDResponse(w http.ResponseWriter) error
}

type PutOverviewTriggerByUID200Response struct {
}

func (response PutOverviewTriggerByUID200Response) VisitPutOverviewTriggerByUIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type PutOverviewTriggerByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PutOverviewTriggerByUIDdefaultJSONResponse) VisitPutOverviewTriggerByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetOverviewUnitsListRequestObject struct {
}

type GetOverviewUnitsListResponseObject interface {
	VisitGetOverviewUnitsListResponse(w http.ResponseWriter) error
}

type GetOverviewUnitsList200JSONResponse []EndpointOverviewMultipleUnits

func (response GetOverviewUnitsList200JSONResponse) VisitGetOverviewUnitsListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOverviewUnitsListdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOverviewUnitsListdefaultJSONResponse) VisitGetOverviewUnitsListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetOverviewUnitByUIDRequestObject struct {
	UID string `json:"UID"`
}

type GetOverviewUnitByUIDResponseObject interface {
	VisitGetOverviewUnitByUIDResponse(w http.ResponseWriter) error
}

type GetOverviewUnitByUID200JSONResponse EndpointOverviewSingleUnit

func (response GetOverviewUnitByUID200JSONResponse) VisitGetOverviewUnitByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetOverviewUnitByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOverviewUnitByUIDdefaultJSONResponse) VisitGetOverviewUnitByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PutOverviewUnitByUIDRequestObject struct {
	UID  string `json:"UID"`
	Body *PutOverviewUnitByUIDJSONRequestBody
}

type PutOverviewUnitByUIDResponseObject interface {
	VisitPutOverviewUnitByUIDResponse(w http.ResponseWriter) error
}

type PutOverviewUnitByUID200Response struct {
}

func (response PutOverviewUnitByUID200Response) VisitPutOverviewUnitByUIDResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type PutOverviewUnitByUIDdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response PutOverviewUnitByUIDdefaultJSONResponse) VisitPutOverviewUnitByUIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Delete device by UID
	// (DELETE /smarthome/configuration/devices/{UID})
	DeleteConfigurationDeviceByUID(ctx context.Context, request DeleteConfigurationDeviceByUIDRequestObject) (DeleteConfigurationDeviceByUIDResponseObject, error)
	// Get device configuration by UID
	// (GET /smarthome/configuration/devices/{UID})
	GetConfigurationDeviceByUID(ctx context.Context, request GetConfigurationDeviceByUIDRequestObject) (GetConfigurationDeviceByUIDResponseObject, error)
	// Configure and control device by UID
	// (PUT /smarthome/configuration/devices/{UID})
	PutConfigurationDeviceByUID(ctx context.Context, request PutConfigurationDeviceByUIDRequestObject) (PutConfigurationDeviceByUIDResponseObject, error)
	// Create new group
	// (POST /smarthome/configuration/groups)
	PostConfigurationGroupByName(ctx context.Context, request PostConfigurationGroupByNameRequestObject) (PostConfigurationGroupByNameResponseObject, error)
	// Delete group by UID
	// (DELETE /smarthome/configuration/groups/{UID})
	DeleteConfigurationGroupByUID(ctx context.Context, request DeleteConfigurationGroupByUIDRequestObject) (DeleteConfigurationGroupByUIDResponseObject, error)
	// Get group configuration by UID
	// (GET /smarthome/configuration/groups/{UID})
	GetConfigurationGroupByUID(ctx context.Context, request GetConfigurationGroupByUIDRequestObject) (GetConfigurationGroupByUIDResponseObject, error)
	// Configure and control group by UID
	// (PUT /smarthome/configuration/groups/{UID})
	PutConfigurationGroupByUID(ctx context.Context, request PutConfigurationGroupByUIDRequestObject) (PutConfigurationGroupByUIDResponseObject, error)
	// Get possible template configuration capabilities
	// (GET /smarthome/configuration/templateCapabilities)
	GetConfigurationTemplateCapabilities(ctx context.Context, request GetConfigurationTemplateCapabilitiesRequestObject) (GetConfigurationTemplateCapabilitiesResponseObject, error)
	// Create new template
	// (POST /smarthome/configuration/templates)
	PostConfigurationTemplateByName(ctx context.Context, request PostConfigurationTemplateByNameRequestObject) (PostConfigurationTemplateByNameResponseObject, error)
	// Delete template by UID
	// (DELETE /smarthome/configuration/templates/{UID})
	DeleteConfigurationTemplateByUID(ctx context.Context, request DeleteConfigurationTemplateByUIDRequestObject) (DeleteConfigurationTemplateByUIDResponseObject, error)
	// Get template configuration by UID
	// (GET /smarthome/configuration/templates/{UID})
	GetConfigurationTemplateByUID(ctx context.Context, request GetConfigurationTemplateByUIDRequestObject) (GetConfigurationTemplateByUIDResponseObject, error)
	// Configure and control template by UID
	// (PUT /smarthome/configuration/templates/{UID})
	PutConfigurationTemplateByUID(ctx context.Context, request PutConfigurationTemplateByUIDRequestObject) (PutConfigurationTemplateByUIDResponseObject, error)
	// Get unit configuration by UID
	// (GET /smarthome/configuration/units/{UID})
	GetConfigurationUnitByUID(ctx context.Context, request GetConfigurationUnitByUIDRequestObject) (GetConfigurationUnitByUIDResponseObject, error)
	// Configure and control unit by UID
	// (PUT /smarthome/configuration/units/{UID})
	PutConfigurationUnitByUID(ctx context.Context, request PutConfigurationUnitByUIDRequestObject) (PutConfigurationUnitByUIDResponseObject, error)
	// Set installCode on zigbee radioBase
	// (POST /smarthome/connect/installCode/{serial})
	PostInstallCodeBySerial(ctx context.Context, request PostInstallCodeBySerialRequestObject) (PostInstallCodeBySerialResponseObject, error)
	// Get list of radioBases
	// (GET /smarthome/connect/radioBases)
	GetRadioBasesList(ctx context.Context, request GetRadioBasesListRequestObject) (GetRadioBasesListResponseObject, error)
	// Get radioBase by Serial
	// (GET /smarthome/connect/radioBases/{serial})
	GetRadioBaseBySerial(ctx context.Context, request GetRadioBaseBySerialRequestObject) (GetRadioBaseBySerialResponseObject, error)
	// Set resetCode on zigbee radioBase
	// (POST /smarthome/connect/resetCode/{serial})
	PostResetCodeBySerial(ctx context.Context, request PostResetCodeBySerialRequestObject) (PostResetCodeBySerialResponseObject, error)
	// Start Subscription on radioBase by Serial
	// (POST /smarthome/connect/startSubscription/{serial})
	PostStartSubscriptionBySerial(ctx context.Context, request PostStartSubscriptionBySerialRequestObject) (PostStartSubscriptionBySerialResponseObject, error)
	// Stop Subscription on radioBase by Serial
	// (POST /smarthome/connect/stopSubscription/{serial})
	PostStopSubscriptionBySerial(ctx context.Context, request PostStopSubscriptionBySerialRequestObject) (PostStopSubscriptionBySerialResponseObject, error)
	// Get subscription state by UID
	// (GET /smarthome/connect/subscriptionState/{UID})
	GetSubscriptionStateByUid(ctx context.Context, request GetSubscriptionStateByUidRequestObject) (GetSubscriptionStateByUidResponseObject, error)
	// Get all overview infos and lists
	// (GET /smarthome/overview)
	GetOverview(ctx context.Context, request GetOverviewRequestObject) (GetOverviewResponseObject, error)
	// Get list of devices
	// (GET /smarthome/overview/devices)
	GetOverviewDevicesList(ctx context.Context, request GetOverviewDevicesListRequestObject) (GetOverviewDevicesListResponseObject, error)
	// Get device by UID
	// (GET /smarthome/overview/devices/{UID})
	GetOverviewDeviceByUID(ctx context.Context, request GetOverviewDeviceByUIDRequestObject) (GetOverviewDeviceByUIDResponseObject, error)
	// Get smart home global values
	// (GET /smarthome/overview/globals)
	GetOverviewGlobals(ctx context.Context, request GetOverviewGlobalsRequestObject) (GetOverviewGlobalsResponseObject, error)
	// Get list of groups
	// (GET /smarthome/overview/groups)
	GetOverviewGroupsList(ctx context.Context, request GetOverviewGroupsListRequestObject) (GetOverviewGroupsListResponseObject, error)
	// Get group by UID
	// (GET /smarthome/overview/groups/{UID})
	GetOverviewGroupByUID(ctx context.Context, request GetOverviewGroupByUIDRequestObject) (GetOverviewGroupByUIDResponseObject, error)
	// Get list of templates
	// (GET /smarthome/overview/templates)
	GetOverviewTemplatesList(ctx context.Context, request GetOverviewTemplatesListRequestObject) (GetOverviewTemplatesListResponseObject, error)
	// Get template by UID
	// (GET /smarthome/overview/templates/{UID})
	GetOverviewTemplateByUID(ctx context.Context, request GetOverviewTemplateByUIDRequestObject) (GetOverviewTemplateByUIDResponseObject, error)
	// Applies a template by UID
	// (POST /smarthome/overview/templates/{UID})
	PostOverviewTemplateByUID(ctx context.Context, request PostOverviewTemplateByUIDRequestObject) (PostOverviewTemplateByUIDResponseObject, error)
	// Get list of triggers
	// (GET /smarthome/overview/triggers)
	GetOverviewTriggersList(ctx context.Context, request GetOverviewTriggersListRequestObject) (GetOverviewTriggersListResponseObject, error)
	// Get trigger by UID
	// (GET /smarthome/overview/triggers/{UID})
	GetOverviewTriggerByUID(ctx context.Context, request GetOverviewTriggerByUIDRequestObject) (GetOverviewTriggerByUIDResponseObject, error)
	// Activate or deactivate trigger by UID
	// (PUT /smarthome/overview/triggers/{UID})
	PutOverviewTriggerByUID(ctx context.Context, request PutOverviewTriggerByUIDRequestObject) (PutOverviewTriggerByUIDResponseObject, error)
	// Get list of units
	// (GET /smarthome/overview/units)
	GetOverviewUnitsList(ctx context.Context, request GetOverviewUnitsListRequestObject) (GetOverviewUnitsListResponseObject, error)
	// Get unit by UID
	// (GET /smarthome/overview/units/{UID})
	GetOverviewUnitByUID(ctx context.Context, request GetOverviewUnitByUIDRequestObject) (GetOverviewUnitByUIDResponseObject, error)
	// Control interfaces for unit by UID
	// (PUT /smarthome/overview/units/{UID})
	PutOverviewUnitByUID(ctx context.Context, request PutOverviewUnitByUIDRequestObject) (PutOverviewUnitByUIDResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// DeleteConfigurationDeviceByUID operation middleware
func (sh *strictHandler) DeleteConfigurationDeviceByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request DeleteConfigurationDeviceByUIDRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteConfigurationDeviceByUID(ctx, request.(DeleteConfigurationDeviceByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteConfigurationDeviceByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteConfigurationDeviceByUIDResponseObject); ok {
		if err := validResponse.VisitDeleteConfigurationDeviceByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetConfigurationDeviceByUID operation middleware
func (sh *strictHandler) GetConfigurationDeviceByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request GetConfigurationDeviceByUIDRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetConfigurationDeviceByUID(ctx, request.(GetConfigurationDeviceByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConfigurationDeviceByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetConfigurationDeviceByUIDResponseObject); ok {
		if err := validResponse.VisitGetConfigurationDeviceByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PutConfigurationDeviceByUID operation middleware
func (sh *strictHandler) PutConfigurationDeviceByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request PutConfigurationDeviceByUIDRequestObject

	request.UID = uid

	var body PutConfigurationDeviceByUIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PutConfigurationDeviceByUID(ctx, request.(PutConfigurationDeviceByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PutConfigurationDeviceByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PutConfigurationDeviceByUIDResponseObject); ok {
		if err := validResponse.VisitPutConfigurationDeviceByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostConfigurationGroupByName operation middleware
func (sh *strictHandler) PostConfigurationGroupByName(w http.ResponseWriter, r *http.Request, params PostConfigurationGroupByNameParams) {
	var request PostConfigurationGroupByNameRequestObject

	request.Params = params

	var body PostConfigurationGroupByNameJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostConfigurationGroupByName(ctx, request.(PostConfigurationGroupByNameRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostConfigurationGroupByName")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostConfigurationGroupByNameResponseObject); ok {
		if err := validResponse.VisitPostConfigurationGroupByNameResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteConfigurationGroupByUID operation middleware
func (sh *strictHandler) DeleteConfigurationGroupByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request DeleteConfigurationGroupByUIDRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteConfigurationGroupByUID(ctx, request.(DeleteConfigurationGroupByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteConfigurationGroupByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteConfigurationGroupByUIDResponseObject); ok {
		if err := validResponse.VisitDeleteConfigurationGroupByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetConfigurationGroupByUID operation middleware
func (sh *strictHandler) GetConfigurationGroupByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request GetConfigurationGroupByUIDRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetConfigurationGroupByUID(ctx, request.(GetConfigurationGroupByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConfigurationGroupByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetConfigurationGroupByUIDResponseObject); ok {
		if err := validResponse.VisitGetConfigurationGroupByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PutConfigurationGroupByUID operation middleware
func (sh *strictHandler) PutConfigurationGroupByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request PutConfigurationGroupByUIDRequestObject

	request.UID = uid

	var body PutConfigurationGroupByUIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PutConfigurationGroupByUID(ctx, request.(PutConfigurationGroupByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PutConfigurationGroupByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PutConfigurationGroupByUIDResponseObject); ok {
		if err := validResponse.VisitPutConfigurationGroupByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetConfigurationTemplateCapabilities operation middleware
func (sh *strictHandler) GetConfigurationTemplateCapabilities(w http.ResponseWriter, r *http.Request) {
	var request GetConfigurationTemplateCapabilitiesRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetConfigurationTemplateCapabilities(ctx, request.(GetConfigurationTemplateCapabilitiesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConfigurationTemplateCapabilities")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetConfigurationTemplateCapabilitiesResponseObject); ok {
		if err := validResponse.VisitGetConfigurationTemplateCapabilitiesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostConfigurationTemplateByName operation middleware
func (sh *strictHandler) PostConfigurationTemplateByName(w http.ResponseWriter, r *http.Request, params PostConfigurationTemplateByNameParams) {
	var request PostConfigurationTemplateByNameRequestObject

	request.Params = params

	var body PostConfigurationTemplateByNameJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostConfigurationTemplateByName(ctx, request.(PostConfigurationTemplateByNameRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostConfigurationTemplateByName")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostConfigurationTemplateByNameResponseObject); ok {
		if err := validResponse.VisitPostConfigurationTemplateByNameResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteConfigurationTemplateByUID operation middleware
func (sh *strictHandler) DeleteConfigurationTemplateByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request DeleteConfigurationTemplateByUIDRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteConfigurationTemplateByUID(ctx, request.(DeleteConfigurationTemplateByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteConfigurationTemplateByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteConfigurationTemplateByUIDResponseObject); ok {
		if err := validResponse.VisitDeleteConfigurationTemplateByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetConfigurationTemplateByUID operation middleware
func (sh *strictHandler) GetConfigurationTemplateByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request GetConfigurationTemplateByUIDRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetConfigurationTemplateByUID(ctx, request.(GetConfigurationTemplateByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConfigurationTemplateByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetConfigurationTemplateByUIDResponseObject); ok {
		if err := validResponse.VisitGetConfigurationTemplateByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PutConfigurationTemplateByUID operation middleware
func (sh *strictHandler) PutConfigurationTemplateByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request PutConfigurationTemplateByUIDRequestObject

	request.UID = uid

	var body PutConfigurationTemplateByUIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PutConfigurationTemplateByUID(ctx, request.(PutConfigurationTemplateByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PutConfigurationTemplateByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PutConfigurationTemplateByUIDResponseObject); ok {
		if err := validResponse.VisitPutConfigurationTemplateByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetConfigurationUnitByUID operation middleware
func (sh *strictHandler) GetConfigurationUnitByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request GetConfigurationUnitByUIDRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetConfigurationUnitByUID(ctx, request.(GetConfigurationUnitByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConfigurationUnitByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetConfigurationUnitByUIDResponseObject); ok {
		if err := validResponse.VisitGetConfigurationUnitByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PutConfigurationUnitByUID operation middleware
func (sh *strictHandler) PutConfigurationUnitByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request PutConfigurationUnitByUIDRequestObject

	request.UID = uid

	var body PutConfigurationUnitByUIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PutConfigurationUnitByUID(ctx, request.(PutConfigurationUnitByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PutConfigurationUnitByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PutConfigurationUnitByUIDResponseObject); ok {
		if err := validResponse.VisitPutConfigurationUnitByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostInstallCodeBySerial operation middleware
func (sh *strictHandler) PostInstallCodeBySerial(w http.ResponseWriter, r *http.Request, serial string) {
	var request PostInstallCodeBySerialRequestObject

	request.Serial = serial

	var body PostInstallCodeBySerialJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostInstallCodeBySerial(ctx, request.(PostInstallCodeBySerialRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostInstallCodeBySerial")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostInstallCodeBySerialResponseObject); ok {
		if err := validResponse.VisitPostInstallCodeBySerialResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetRadioBasesList operation middleware
func (sh *strictHandler) GetRadioBasesList(w http.ResponseWriter, r *http.Request) {
	var request GetRadioBasesListRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetRadioBasesList(ctx, request.(GetRadioBasesListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetRadioBasesList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetRadioBasesListResponseObject); ok {
		if err := validResponse.VisitGetRadioBasesListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetRadioBaseBySerial operation middleware
func (sh *strictHandler) GetRadioBaseBySerial(w http.ResponseWriter, r *http.Request, serial string) {
	var request GetRadioBaseBySerialRequestObject

	request.Serial = serial

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetRadioBaseBySerial(ctx, request.(GetRadioBaseBySerialRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetRadioBaseBySerial")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetRadioBaseBySerialResponseObject); ok {
		if err := validResponse.VisitGetRadioBaseBySerialResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostResetCodeBySerial operation middleware
func (sh *strictHandler) PostResetCodeBySerial(w http.ResponseWriter, r *http.Request, serial string) {
	var request PostResetCodeBySerialRequestObject

	request.Serial = serial

	var body PostResetCodeBySerialJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostResetCodeBySerial(ctx, request.(PostResetCodeBySerialRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostResetCodeBySerial")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostResetCodeBySerialResponseObject); ok {
		if err := validResponse.VisitPostResetCodeBySerialResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostStartSubscriptionBySerial operation middleware
func (sh *strictHandler) PostStartSubscriptionBySerial(w http.ResponseWriter, r *http.Request, serial string) {
	var request PostStartSubscriptionBySerialRequestObject

	request.Serial = serial

	var body PostStartSubscriptionBySerialJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostStartSubscriptionBySerial(ctx, request.(PostStartSubscriptionBySerialRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostStartSubscriptionBySerial")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostStartSubscriptionBySerialResponseObject); ok {
		if err := validResponse.VisitPostStartSubscriptionBySerialResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostStopSubscriptionBySerial operation middleware
func (sh *strictHandler) PostStopSubscriptionBySerial(w http.ResponseWriter, r *http.Request, serial string) {
	var request PostStopSubscriptionBySerialRequestObject

	request.Serial = serial

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostStopSubscriptionBySerial(ctx, request.(PostStopSubscriptionBySerialRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostStopSubscriptionBySerial")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostStopSubscriptionBySerialResponseObject); ok {
		if err := validResponse.VisitPostStopSubscriptionBySerialResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSubscriptionStateByUid operation middleware
func (sh *strictHandler) GetSubscriptionStateByUid(w http.ResponseWriter, r *http.Request, uid string) {
	var request GetSubscriptionStateByUidRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetSubscriptionStateByUid(ctx, request.(GetSubscriptionStateByUidRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSubscriptionStateByUid")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetSubscriptionStateByUidResponseObject); ok {
		if err := validResponse.VisitGetSubscriptionStateByUidResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOverview operation middleware
func (sh *strictHandler) GetOverview(w http.ResponseWriter, r *http.Request) {
	var request GetOverviewRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOverview(ctx, request.(GetOverviewRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOverview")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOverviewResponseObject); ok {
		if err := validResponse.VisitGetOverviewResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOverviewDevicesList operation middleware
func (sh *strictHandler) GetOverviewDevicesList(w http.ResponseWriter, r *http.Request) {
	var request GetOverviewDevicesListRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOverviewDevicesList(ctx, request.(GetOverviewDevicesListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOverviewDevicesList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOverviewDevicesListResponseObject); ok {
		if err := validResponse.VisitGetOverviewDevicesListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOverviewDeviceByUID operation middleware
func (sh *strictHandler) GetOverviewDeviceByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request GetOverviewDeviceByUIDRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOverviewDeviceByUID(ctx, request.(GetOverviewDeviceByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOverviewDeviceByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOverviewDeviceByUIDResponseObject); ok {
		if err := validResponse.VisitGetOverviewDeviceByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOverviewGlobals operation middleware
func (sh *strictHandler) GetOverviewGlobals(w http.ResponseWriter, r *http.Request) {
	var request GetOverviewGlobalsRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOverviewGlobals(ctx, request.(GetOverviewGlobalsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOverviewGlobals")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOverviewGlobalsResponseObject); ok {
		if err := validResponse.VisitGetOverviewGlobalsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOverviewGroupsList operation middleware
func (sh *strictHandler) GetOverviewGroupsList(w http.ResponseWriter, r *http.Request) {
	var request GetOverviewGroupsListRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOverviewGroupsList(ctx, request.(GetOverviewGroupsListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOverviewGroupsList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOverviewGroupsListResponseObject); ok {
		if err := validResponse.VisitGetOverviewGroupsListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOverviewGroupByUID operation middleware
func (sh *strictHandler) GetOverviewGroupByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request GetOverviewGroupByUIDRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOverviewGroupByUID(ctx, request.(GetOverviewGroupByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOverviewGroupByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOverviewGroupByUIDResponseObject); ok {
		if err := validResponse.VisitGetOverviewGroupByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOverviewTemplatesList operation middleware
func (sh *strictHandler) GetOverviewTemplatesList(w http.ResponseWriter, r *http.Request) {
	var request GetOverviewTemplatesListRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOverviewTemplatesList(ctx, request.(GetOverviewTemplatesListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOverviewTemplatesList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOverviewTemplatesListResponseObject); ok {
		if err := validResponse.VisitGetOverviewTemplatesListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOverviewTemplateByUID operation middleware
func (sh *strictHandler) GetOverviewTemplateByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request GetOverviewTemplateByUIDRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOverviewTemplateByUID(ctx, request.(GetOverviewTemplateByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOverviewTemplateByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOverviewTemplateByUIDResponseObject); ok {
		if err := validResponse.VisitGetOverviewTemplateByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostOverviewTemplateByUID operation middleware
func (sh *strictHandler) PostOverviewTemplateByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request PostOverviewTemplateByUIDRequestObject

	request.UID = uid

	var body PostOverviewTemplateByUIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostOverviewTemplateByUID(ctx, request.(PostOverviewTemplateByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostOverviewTemplateByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostOverviewTemplateByUIDResponseObject); ok {
		if err := validResponse.VisitPostOverviewTemplateByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOverviewTriggersList operation middleware
func (sh *strictHandler) GetOverviewTriggersList(w http.ResponseWriter, r *http.Request) {
	var request GetOverviewTriggersListRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOverviewTriggersList(ctx, request.(GetOverviewTriggersListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOverviewTriggersList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOverviewTriggersListResponseObject); ok {
		if err := validResponse.VisitGetOverviewTriggersListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOverviewTriggerByUID operation middleware
func (sh *strictHandler) GetOverviewTriggerByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request GetOverviewTriggerByUIDRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOverviewTriggerByUID(ctx, request.(GetOverviewTriggerByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOverviewTriggerByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOverviewTriggerByUIDResponseObject); ok {
		if err := validResponse.VisitGetOverviewTriggerByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PutOverviewTriggerByUID operation middleware
func (sh *strictHandler) PutOverviewTriggerByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request PutOverviewTriggerByUIDRequestObject

	request.UID = uid

	var body PutOverviewTriggerByUIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PutOverviewTriggerByUID(ctx, request.(PutOverviewTriggerByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PutOverviewTriggerByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PutOverviewTriggerByUIDResponseObject); ok {
		if err := validResponse.VisitPutOverviewTriggerByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOverviewUnitsList operation middleware
func (sh *strictHandler) GetOverviewUnitsList(w http.ResponseWriter, r *http.Request) {
	var request GetOverviewUnitsListRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOverviewUnitsList(ctx, request.(GetOverviewUnitsListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOverviewUnitsList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOverviewUnitsListResponseObject); ok {
		if err := validResponse.VisitGetOverviewUnitsListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOverviewUnitByUID operation middleware
func (sh *strictHandler) GetOverviewUnitByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request GetOverviewUnitByUIDRequestObject

	request.UID = uid

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOverviewUnitByUID(ctx, request.(GetOverviewUnitByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOverviewUnitByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOverviewUnitByUIDResponseObject); ok {
		if err := validResponse.VisitGetOverviewUnitByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PutOverviewUnitByUID operation middleware
func (sh *strictHandler) PutOverviewUnitByUID(w http.ResponseWriter, r *http.Request, uid string) {
	var request PutOverviewUnitByUIDRequestObject

	request.UID = uid

	var body PutOverviewUnitByUIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PutOverviewUnitByUID(ctx, request.(PutOverviewUnitByUIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PutOverviewUnitByUID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PutOverviewUnitByUIDResponseObject); ok {
		if err := validResponse.VisitPutOverviewUnitByUIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}
